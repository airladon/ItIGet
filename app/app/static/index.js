(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Fig", [], factory);
	else if(typeof exports === 'object')
		exports["Fig"] = factory();
	else
		root["Fig"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./js/tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _js_tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _js_diagram_Diagram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./js/diagram/Diagram */ "./src/js/diagram/Diagram.js");
/* harmony import */ var _js_tools_color__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./js/tools/color */ "./src/js/tools/color.js");
/* harmony import */ var _js_tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./js/tools/htmlGenerator */ "./src/js/tools/htmlGenerator.js");
/* harmony import */ var _js_tools_tools__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./js/tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _js_tools_styleSheets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./js/tools/styleSheets */ "./src/js/tools/styleSheets.js");
/* harmony import */ var _js_diagram_Element__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./js/diagram/Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _js_diagram_DrawContext2D__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./js/diagram/DrawContext2D */ "./src/js/diagram/DrawContext2D.js");
/* harmony import */ var _js_diagram_webgl_webgl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./js/diagram/webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _js_diagram_AnimationPhase__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./js/diagram/AnimationPhase */ "./src/js/diagram/AnimationPhase.js");
/* harmony import */ var _js_diagram_DrawingObjects_DrawingObject__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./js/diagram/DrawingObjects/DrawingObject */ "./src/js/diagram/DrawingObjects/DrawingObject.js");
/* harmony import */ var _js_diagram_DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./js/diagram/DrawingObjects/VertexObject/VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
/* harmony import */ var _js_diagram_DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./js/diagram/DrawingObjects/TextObject/TextObject */ "./src/js/diagram/DrawingObjects/TextObject/TextObject.js");
/* harmony import */ var _js_diagram_DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./js/diagram/DrawingObjects/HTMLObject/HTMLObject */ "./src/js/diagram/DrawingObjects/HTMLObject/HTMLObject.js");
/* harmony import */ var _js_diagram_DiagramElements_Equation_HTMLEquation__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./js/diagram/DiagramElements/Equation/HTMLEquation */ "./src/js/diagram/DiagramElements/Equation/HTMLEquation.js");
/* harmony import */ var _js_diagram_DiagramObjects_Angle__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./js/diagram/DiagramObjects/Angle */ "./src/js/diagram/DiagramObjects/Angle.js");
/* harmony import */ var _js_diagram_DiagramObjects_Line__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./js/diagram/DiagramObjects/Line */ "./src/js/diagram/DiagramObjects/Line.js");
/* harmony import */ var _js_diagram_DiagramObjects_EqnNavigator__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./js/diagram/DiagramObjects/EqnNavigator */ "./src/js/diagram/DiagramObjects/EqnNavigator.js");
/* harmony import */ var _js_diagram_DiagramObjects_EquationLabel__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./js/diagram/DiagramObjects/EquationLabel */ "./src/js/diagram/DiagramObjects/EquationLabel.js");
/* harmony import */ var _js_diagram_DiagramElements_Equation_GLEquation__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./js/diagram/DiagramElements/Equation/GLEquation */ "./src/js/diagram/DiagramElements/Equation/GLEquation.js");
/* harmony import */ var _js_diagram_DiagramElements_Equation_Equation__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./js/diagram/DiagramElements/Equation/Equation */ "./src/js/diagram/DiagramElements/Equation/Equation.js");
/* harmony import */ var _js_diagram_DiagramElements_Equation_EquationForm__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./js/diagram/DiagramElements/Equation/EquationForm */ "./src/js/diagram/DiagramElements/Equation/EquationForm.js");























var tools = {
  math: _js_tools_math__WEBPACK_IMPORTED_MODULE_1__,
  g2: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__,
  color: _js_tools_color__WEBPACK_IMPORTED_MODULE_3__,
  css: _js_tools_styleSheets__WEBPACK_IMPORTED_MODULE_6__,
  html: _js_tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_4__,
  misc: _js_tools_tools__WEBPACK_IMPORTED_MODULE_5__
};
var FigureOne = {
  tools: tools,
  Diagram: _js_diagram_Diagram__WEBPACK_IMPORTED_MODULE_2__["default"],
  //
  DiagramElement: _js_diagram_Element__WEBPACK_IMPORTED_MODULE_7__["DiagramElement"],
  DiagramElementCollection: _js_diagram_Element__WEBPACK_IMPORTED_MODULE_7__["DiagramElementCollection"],
  DiagramElementPrimative: _js_diagram_Element__WEBPACK_IMPORTED_MODULE_7__["DiagramElementPrimative"],
  DrawContext2D: _js_diagram_DrawContext2D__WEBPACK_IMPORTED_MODULE_8__["default"],
  WebGLInstance: _js_diagram_webgl_webgl__WEBPACK_IMPORTED_MODULE_9__["default"],
  AnimationPhase: _js_diagram_AnimationPhase__WEBPACK_IMPORTED_MODULE_10__["AnimationPhase"],
  ColorAnimationPhase: _js_diagram_AnimationPhase__WEBPACK_IMPORTED_MODULE_10__["ColorAnimationPhase"],
  CustomAnimationPhase: _js_diagram_AnimationPhase__WEBPACK_IMPORTED_MODULE_10__["CustomAnimationPhase"],
  //
  DrawingObject: _js_diagram_DrawingObjects_DrawingObject__WEBPACK_IMPORTED_MODULE_11__["default"],
  VertexObject: _js_diagram_DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_12__["default"],
  TextObject: _js_diagram_DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_13__["TextObject"],
  DiagramText: _js_diagram_DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_13__["DiagramText"],
  DiagramFont: _js_diagram_DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_13__["DiagramFont"],
  HTMLObject: _js_diagram_DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_14__["default"],
  //
  DiagramObjectAngle: _js_diagram_DiagramObjects_Angle__WEBPACK_IMPORTED_MODULE_16__["default"],
  DiagramObjectLine: _js_diagram_DiagramObjects_Line__WEBPACK_IMPORTED_MODULE_17__["default"],
  EqnNavigator: _js_diagram_DiagramObjects_EqnNavigator__WEBPACK_IMPORTED_MODULE_18__["default"],
  EquationLabel: _js_diagram_DiagramObjects_EquationLabel__WEBPACK_IMPORTED_MODULE_19__["default"],
  //
  EquationLegacy: _js_diagram_DiagramElements_Equation_GLEquation__WEBPACK_IMPORTED_MODULE_20__["Equation"],
  EquationForm: _js_diagram_DiagramElements_Equation_EquationForm__WEBPACK_IMPORTED_MODULE_22__["default"],
  Equation: _js_diagram_DiagramElements_Equation_Equation__WEBPACK_IMPORTED_MODULE_21__["EquationNew"],
  //
  HTMLEquation: _js_diagram_DiagramElements_Equation_HTMLEquation__WEBPACK_IMPORTED_MODULE_15__["default"],
  //
  Point: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"],
  Line: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"],
  Rect: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"],
  Transform: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"],
  TransformLimit: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["TransformLimit"],
  Translation: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Translation"],
  Scale: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Scale"],
  Rotation: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"]
};
/* harmony default export */ __webpack_exports__["default"] = (FigureOne);

/***/ }),

/***/ "./src/js/diagram/Animation/Animation.js":
/*!***********************************************!*\
  !*** ./src/js/diagram/Animation/Animation.js ***!
  \***********************************************/
/*! exports provided: PositionAnimationStep, AnimationBuilder, ParallelAnimationStep, SerialAnimationStep, TransformAnimationStep, AnimationStep, DelayStep, TriggerStep, inParallel, inSerial, trigger, delay, ColorAnimationStep, DissolveInAnimationStep, dissolveIn, DissolveOutAnimationStep, dissolveOut, CustomAnimationStep, custom, AnimationManager, RotationAnimationStep, ScaleAnimationStep, PulseAnimationStep, OpacityAnimationStep */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _AnimationStep_ElementAnimationStep_PositionAnimationStep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/PositionAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/PositionAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PositionAnimationStep", function() { return _AnimationStep_ElementAnimationStep_PositionAnimationStep__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_ColorAnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/ColorAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/ColorAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColorAnimationStep", function() { return _AnimationStep_ElementAnimationStep_ColorAnimationStep__WEBPACK_IMPORTED_MODULE_1__["ColorAnimationStep"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/OpacityAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/OpacityAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DissolveInAnimationStep", function() { return _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_2__["DissolveInAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dissolveIn", function() { return _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_2__["dissolveIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DissolveOutAnimationStep", function() { return _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_2__["DissolveOutAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dissolveOut", function() { return _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_2__["dissolveOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OpacityAnimationStep", function() { return _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_2__["OpacityAnimationStep"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_TransformAnimationStep__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/TransformAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/TransformAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransformAnimationStep", function() { return _AnimationStep_ElementAnimationStep_TransformAnimationStep__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_RotationAnimationStep__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/RotationAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/RotationAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RotationAnimationStep", function() { return _AnimationStep_ElementAnimationStep_RotationAnimationStep__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_ScaleAnimationStep__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/ScaleAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/ScaleAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScaleAnimationStep", function() { return _AnimationStep_ElementAnimationStep_ScaleAnimationStep__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_PulseAnimationStep__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/PulseAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/PulseAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PulseAnimationStep", function() { return _AnimationStep_ElementAnimationStep_PulseAnimationStep__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _AnimationStep_TriggerStep__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./AnimationStep/TriggerStep */ "./src/js/diagram/Animation/AnimationStep/TriggerStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TriggerStep", function() { return _AnimationStep_TriggerStep__WEBPACK_IMPORTED_MODULE_7__["TriggerStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "trigger", function() { return _AnimationStep_TriggerStep__WEBPACK_IMPORTED_MODULE_7__["trigger"]; });

/* harmony import */ var _AnimationStep_CustomStep__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./AnimationStep/CustomStep */ "./src/js/diagram/Animation/AnimationStep/CustomStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CustomAnimationStep", function() { return _AnimationStep_CustomStep__WEBPACK_IMPORTED_MODULE_8__["CustomAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "custom", function() { return _AnimationStep_CustomStep__WEBPACK_IMPORTED_MODULE_8__["custom"]; });

/* harmony import */ var _AnimationStep_ParallelAnimationStep__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./AnimationStep/ParallelAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ParallelAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ParallelAnimationStep", function() { return _AnimationStep_ParallelAnimationStep__WEBPACK_IMPORTED_MODULE_9__["ParallelAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inParallel", function() { return _AnimationStep_ParallelAnimationStep__WEBPACK_IMPORTED_MODULE_9__["inParallel"]; });

/* harmony import */ var _AnimationStep_SerialAnimationStep__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./AnimationStep/SerialAnimationStep */ "./src/js/diagram/Animation/AnimationStep/SerialAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SerialAnimationStep", function() { return _AnimationStep_SerialAnimationStep__WEBPACK_IMPORTED_MODULE_10__["SerialAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inSerial", function() { return _AnimationStep_SerialAnimationStep__WEBPACK_IMPORTED_MODULE_10__["inSerial"]; });

/* harmony import */ var _AnimationStep_DelayStep__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./AnimationStep/DelayStep */ "./src/js/diagram/Animation/AnimationStep/DelayStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DelayStep", function() { return _AnimationStep_DelayStep__WEBPACK_IMPORTED_MODULE_11__["DelayStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "delay", function() { return _AnimationStep_DelayStep__WEBPACK_IMPORTED_MODULE_11__["delay"]; });

/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./AnimationStep */ "./src/js/diagram/Animation/AnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationStep", function() { return _AnimationStep__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _AnimationManager__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./AnimationManager */ "./src/js/diagram/Animation/AnimationManager.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationManager", function() { return _AnimationManager__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _AnimationBuilder__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./AnimationBuilder */ "./src/js/diagram/Animation/AnimationBuilder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationBuilder", function() { return _AnimationBuilder__WEBPACK_IMPORTED_MODULE_14__["default"]; });


















/***/ }),

/***/ "./src/js/diagram/Animation/AnimationBuilder.js":
/*!******************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationBuilder.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimationBuilder; });
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animation */ "./src/js/diagram/Animation/Animation.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

// import * as tools from '../../tools/math';

// import PositionAnimationStep from './AnimationStep/ElementAnimationStep/PositionAnimationStep';
// import SerialAnimationStep from './AnimationStep/SerialAnimationStep';



var AnimationBuilder =
/*#__PURE__*/
function (_animation$SerialAnim) {
  _inherits(AnimationBuilder, _animation$SerialAnim);

  function AnimationBuilder() {
    var _this;

    var elementOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AnimationBuilder);

    var defaultOptions = {};
    var options;

    for (var _len = arguments.length, optionsIn = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      optionsIn[_key - 1] = arguments[_key];
    }

    if (elementOrOptionsIn instanceof _Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElement"]) {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      options.element = elementOrOptionsIn;
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, elementOrOptionsIn].concat(optionsIn));
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimationBuilder).call(this, options));
    _this.element = options.element;
    return _possibleConstructorReturn(_this, _assertThisInitialized(_assertThisInitialized(_this)));
  }

  _createClass(AnimationBuilder, [{
    key: "custom",
    value: function custom() {
      for (var _len2 = arguments.length, optionsIn = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        optionsIn[_key2] = arguments[_key2];
      }

      this.then(_construct(_Animation__WEBPACK_IMPORTED_MODULE_1__["CustomAnimationStep"], optionsIn));
      return this;
    }
  }, {
    key: "rotation",
    value: function rotation() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len3 = arguments.length, optionsIn = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          optionsIn[_key3] = arguments[_key3];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["RotationAnimationStep"](options));
      }

      return this;
    }
  }, {
    key: "position",
    value: function position() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len4 = arguments.length, optionsIn = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          optionsIn[_key4] = arguments[_key4];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["PositionAnimationStep"](options));
      }

      return this;
    }
  }, {
    key: "scale",
    value: function scale() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len5 = arguments.length, optionsIn = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          optionsIn[_key5] = arguments[_key5];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["ScaleAnimationStep"](options));
      }

      return this;
    } // moveTo(...optionsIn: Array<TypePositionAnimationStepInputOptions>) {
    //   return this.moveToPosition(...optionsIn);
    // }
    // positionTo(...optionsIn: Array<TypePositionAnimationStepInputOptions>) {
    //   return this.moveToPosition(...optionsIn);
    // }

  }, {
    key: "transform",
    value: function transform() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len6 = arguments.length, optionsIn = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          optionsIn[_key6] = arguments[_key6];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["TransformAnimationStep"](options));
      }

      return this;
    }
  }, {
    key: "scenario",
    value: function scenario() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len7 = arguments.length, optionsIn = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          optionsIn[_key7] = arguments[_key7];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
        this.then(options.element.anim.scenario(options));
      }

      return this;
    }
  }, {
    key: "color",
    value: function color() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len8 = arguments.length, optionsIn = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
          optionsIn[_key8] = arguments[_key8];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["ColorAnimationStep"](options));
      }

      return this;
    }
  }, {
    key: "opacity",
    value: function opacity() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len9 = arguments.length, optionsIn = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
          optionsIn[_key9] = arguments[_key9];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["OpacityAnimationStep"](options));
      }

      return this;
    }
  }, {
    key: "dissolveOut",
    value: function dissolveOut() {
      var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        element: this.element
      };
      var options;

      for (var _len10 = arguments.length, args = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
        args[_key10 - 1] = arguments[_key10];
      }

      if (typeof timeOrOptionsIn === 'number') {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, {
          duration: timeOrOptionsIn
        }].concat(args));
      } else {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["dissolveOut"](options));
      return this;
    }
  }, {
    key: "dissolveIn",
    value: function dissolveIn() {
      var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        element: this.element
      };
      var options;

      for (var _len11 = arguments.length, args = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
        args[_key11 - 1] = arguments[_key11];
      }

      if (typeof timeOrOptionsIn === 'number') {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, {
          duration: timeOrOptionsIn
        }].concat(args));
      } else {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["dissolveIn"](options));
      return this;
    }
  }, {
    key: "delay",
    value: function delay() {
      var numOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      for (var _len12 = arguments.length, args = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {
        args[_key12 - 1] = arguments[_key12];
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["delay"].apply(_Animation__WEBPACK_IMPORTED_MODULE_1__, [numOrOptionsIn].concat(args)));
      return this;
    }
  }, {
    key: "trigger",
    value: function trigger() {
      var triggerOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      for (var _len13 = arguments.length, optionsIn = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {
        optionsIn[_key13 - 1] = arguments[_key13];
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["trigger"].apply(_Animation__WEBPACK_IMPORTED_MODULE_1__, [triggerOrOptionsIn].concat(optionsIn)));
      return this;
    }
  }, {
    key: "inParallel",
    value: function inParallel() {
      var stepsOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      for (var _len14 = arguments.length, optionsIn = new Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {
        optionsIn[_key14 - 1] = arguments[_key14];
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["inParallel"].apply(_Animation__WEBPACK_IMPORTED_MODULE_1__, [stepsOrOptionsIn].concat(optionsIn)));
      return this;
    }
  }, {
    key: "inSerial",
    value: function inSerial() {
      var stepsOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      for (var _len15 = arguments.length, optionsIn = new Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {
        optionsIn[_key15 - 1] = arguments[_key15];
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["inSerial"].apply(_Animation__WEBPACK_IMPORTED_MODULE_1__, [stepsOrOptionsIn].concat(optionsIn)));
      return this;
    }
  }, {
    key: "pulse",
    value: function pulse() {
      var defaultOptions = {
        element: this.element
      };

      for (var _len16 = arguments.length, optionsIn = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
        optionsIn[_key16] = arguments[_key16];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["PulseAnimationStep"](options));
      return this;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.steps = [];
      this.state = 'idle';
    } // whenFinished(callback: (boolean) => void) {
    //   super.whenFinished(callback);
    //   return this;
    // }

  }, {
    key: "_dup",
    value: function _dup() {
      var newBuilder = new AnimationBuilder();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicateFromTo"])(this, newBuilder, ['element']);
      newBuilder.element = this.element;
      return newBuilder;
    }
  }]);

  return AnimationBuilder;
}(_Animation__WEBPACK_IMPORTED_MODULE_1__["SerialAnimationStep"]);



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationManager.js":
/*!******************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationManager.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimationManager; });
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animation */ "./src/js/diagram/Animation/Animation.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// import * as tools from '../../tools/math';
 // import type { TypeSerialAnimationStepInputOptions } from './AnimationStep/SerialAnimationStep';
// import type {
//   TypePositionAnimationStepInputOptions, TypeParallelAnimationStepInputOptions,
//   TypeDelayStepInputOptions, TypeTriggerStepInputOptions,
//   TypeColorAnimationStepInputOptions, TypeCustomAnimationStepInputOptions,
// } from './Animation';




var AnimationManager =
/*#__PURE__*/
function () {
  function AnimationManager() {
    var elementOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AnimationManager);

    var defaultOptions = {};
    var options;

    for (var _len = arguments.length, optionsIn = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      optionsIn[_key - 1] = arguments[_key];
    }

    if (elementOrOptionsIn instanceof _Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElement"]) {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      options.element = elementOrOptionsIn;
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, elementOrOptionsIn].concat(optionsIn));
    }

    this.element = options.element;
    this.animations = [];
    this.state = 'idle';
    return this;
  }

  _createClass(AnimationManager, [{
    key: "nextFrame",
    value: function nextFrame(now) {
      // console.log('animation manager', now)
      var animationsToRemove = [];
      var remaining = -1;
      var isAnimating = false;
      this.animations.forEach(function (animation, index) {
        var animationIsAnimating = false;

        if (animation.state === 'waitingToStart' || animation.state === 'animating') {
          var stepRemaining = animation.nextFrame(now);

          if (remaining === -1) {
            remaining = stepRemaining;
          }

          if (stepRemaining < remaining) {
            remaining = stepRemaining;
          }

          animationIsAnimating = true;
        }

        if (animation.state === 'finished' && animation.removeOnFinish) {
          animationIsAnimating = false;
          animationsToRemove.push(index);
        }

        if (animationIsAnimating) {
          isAnimating = true;
        }
      });

      if (isAnimating) {
        this.state = 'animating';
      } else {
        this.state = 'idle';
      }

      for (var i = animationsToRemove.length - 1; i >= 0; i -= 1) {
        this.animations.splice(animationsToRemove[i], 1);
      }

      return remaining;
    }
  }, {
    key: "cleanAnimations",
    value: function cleanAnimations() {
      var animationsToRemove = [];
      var isAnimating = false;

      for (var i = 0; i < this.animations.length; i += 1) {
        var animation = this.animations[i];

        if (animation.state === 'finished' && animation.removeOnFinish) {
          animationsToRemove.push(i);
        } else {
          isAnimating = true;
        }
      }

      for (var _i = animationsToRemove.length - 1; _i >= 0; _i -= 1) {
        this.animations.splice(animationsToRemove[_i], 1);
      }

      if (isAnimating) {
        this.state = 'animating';
      } else {
        this.state = 'idle';
      }
    } // Cancel all primary animations with the name
    // animations will be cleaned up on next frame

  }, {
    key: "cancel",
    value: function cancel(name) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (name == null) {
        this.cancelAll(force);
      } else {
        for (var i = 0; i < this.animations.length; i += 1) {
          var animation = this.animations[i];

          if (animation.name === name) {
            animation.cancel(force);
          }
        }

        this.cleanAnimations();
      }
    }
  }, {
    key: "cancelAll",
    value: function cancelAll() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      for (var i = 0; i < this.animations.length; i += 1) {
        this.animations[i].cancel(force);
      }

      this.cleanAnimations();
    }
  }, {
    key: "start",
    value: function start(name) {
      if (name == null) {
        this.startAll();
      } else {
        for (var i = 0; i < this.animations.length; i += 1) {
          var animation = this.animations[i];

          if (animation.name === name) {
            if (animation.state !== 'animating') {
              animation.start();
              this.state = 'animating';
            }
          }
        }
      }
    }
  }, {
    key: "startAll",
    value: function startAll() {
      for (var i = 0; i < this.animations.length; i += 1) {
        var animation = this.animations[i];

        if (animation.state !== 'animating') {
          animation.start();
          this.state = 'animating';
        }
      }
    }
  }, {
    key: "addTo",
    value: function addTo(name) {
      for (var i = 0; i < this.animations.length; i += 1) {
        var animation = this.animations[i];

        if (animation.name === name) {
          return animation;
        }
      }

      return this.new(name);
    }
  }, {
    key: "new",
    value: function _new(nameOrStep) {
      if (typeof nameOrStep === 'string' || nameOrStep == null) {
        var options = {};

        if (this.element != null) {
          options.element = this.element;
        }

        if (nameOrStep != null) {
          options.name = nameOrStep;
        }

        var animation = new _Animation__WEBPACK_IMPORTED_MODULE_1__["AnimationBuilder"](options);
        this.animations.push(animation);
        return animation;
      }

      if (nameOrStep != null) {
        this.animations.push(nameOrStep);
      }

      return nameOrStep;
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var newManager = new AnimationManager();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicateFromTo"])(this, newManager, ['element']);
      newManager.element = this.element;
      return newManager;
    }
  }]);

  return AnimationManager;
}();



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep.js":
/*!***************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimationStep; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// import {
//   Transform, Point,
//   Rotation, getDeltaAngle, getMaxTimeFromVelocity,
// } from '../tools/g2';
// import * as tools from '../tools/math';
// import type { pathOptionsType } from '../tools/g2';
// eslint-disable-next-line import/no-cycle
// import { DiagramElement } from './Element';


var AnimationStep =
/*#__PURE__*/
function () {
  // animations: Array<AnimationStep>;
  function AnimationStep() {
    var optionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AnimationStep);

    var defaultOptions = {
      onFinish: null,
      completeOnCancel: null,
      removeOnFinish: true,
      name: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["generateRandomString"])(),
      duration: 0,
      delay: 0
    };
    var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"])({}, defaultOptions, optionsIn);
    this.onFinish = options.onFinish;
    this.completeOnCancel = options.completeOnCancel;
    this.duration = options.duration;
    this.startTime = -1;
    this.state = 'idle';
    this.name = options.name;
    this.startDelay = options.delay; // This is only for it this step is a primary path in an Animation Manager

    this.removeOnFinish = options.removeOnFinish; // Each animation frame will typically calculate a percent complete,
    // which is based on the duration, and from the percent complete calculate
    // the position of the current animation.
    // However, if you want to start an animation not from 0 percent, then this
    // value can be used. When startTimeOffset != 0, then the first frame
    // will be calculated at this.progression(startTimeOffset). The animation
    // will still go to 1, but will be reduced in duration by startTimeOffset.
    // When progressions aren't linear, then this time is non-trival.

    this.startTimeOffset = 0;
    return this;
  } // returns remaining time if this step completes
  // Return of 0 means this step is still going


  _createClass(AnimationStep, [{
    key: "nextFrame",
    value: function nextFrame(now) {
      if (this.startTime === -1) {
        this.startTime = now - this.startTimeOffset;
      }

      var remainingTime = 0;
      var deltaTime = now - this.startTime;

      if (deltaTime >= this.startDelay) {
        var deltaTimeAfterDelay = deltaTime - this.startDelay;

        if (deltaTimeAfterDelay > this.duration) {
          remainingTime = deltaTimeAfterDelay - this.duration;
          deltaTimeAfterDelay = this.duration;
        }

        this.setFrame(deltaTimeAfterDelay);

        if (remainingTime > 0) {
          this.finish();
        }
      }

      return remainingTime;
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {}
  }, {
    key: "startWaiting",
    value: function startWaiting() {
      this.state = 'waitingToStart';
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "start",
    value: function start() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      this.startTime = startTime;
      this.state = 'animating';
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "setToEnd",
    value: function setToEnd() {} // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "finish",
    value: function finish() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      // this.startTime = -2;
      // this.onFinish(false);
      if (this.state === 'idle' || this.state === 'finished') {
        return;
      }

      var oldState = this.state;
      this.state = 'finished';

      if (cancelled && force === 'complete') {
        if (oldState === 'waitingToStart') {
          this.start();
        }

        this.setToEnd();
      }

      if (cancelled && force == null && this.completeOnCancel === true) {
        if (oldState === 'waitingToStart') {
          this.start();
        }

        this.setToEnd();
      }

      if (cancelled === false) {
        if (oldState === 'waitingToStart') {
          this.start();
        }

        this.setToEnd();
      }

      if (this.onFinish != null) {
        this.onFinish(cancelled);
      }
    }
  }, {
    key: "cancel",
    value: function cancel() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.finish(true, force);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new AnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["duplicateFromTo"])(this, step);
      return step;
    }
  }, {
    key: "whenFinished",
    value: function whenFinished(callback) {
      this.onFinish = callback;
      return this;
    }
  }, {
    key: "ifCanceledThenComplete",
    value: function ifCanceledThenComplete() {
      this.completeOnCancel = true;
      return this;
    }
  }, {
    key: "ifCanceledThenStop",
    value: function ifCanceledThenStop() {
      this.completeOnCancel = false;
      return this;
    }
  }]);

  return AnimationStep;
}();



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/CustomStep.js":
/*!**************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/CustomStep.js ***!
  \**************************************************************/
/*! exports provided: CustomAnimationStep, custom */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomAnimationStep", function() { return CustomAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "custom", function() { return custom; });
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/diagram/Animation/AnimationStep.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var CustomAnimationStep =
/*#__PURE__*/
function (_AnimationStep) {
  _inherits(CustomAnimationStep, _AnimationStep);

  function CustomAnimationStep() {
    var _this;

    _classCallCheck(this, CustomAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var AnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}].concat(optionsIn));
    _this = _possibleConstructorReturn(this, _getPrototypeOf(CustomAnimationStep).call(this, AnimationStepOptionsIn));
    var defaultPositionOptions = {
      callback: null,
      startPercent: 0,
      progression: 'linear'
    };
    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultPositionOptions].concat(optionsIn));

    if (options.progression === 'linear') {
      _this.progression = _tools_math__WEBPACK_IMPORTED_MODULE_0__["linear"];
    } else if (options.progression === 'easein') {
      _this.progression = _tools_math__WEBPACK_IMPORTED_MODULE_0__["easein"];
    } else if (options.progression === 'easeout') {
      _this.progression = _tools_math__WEBPACK_IMPORTED_MODULE_0__["easeout"];
    } else if (options.progression === 'easeinout') {
      _this.progression = _tools_math__WEBPACK_IMPORTED_MODULE_0__["easeinout"];
    } else {
      _this.progression = options.progression;
    }

    _this.callback = options.callback;
    _this.startPercent = options.startPercent;

    if (typeof _this.progression === 'function') {
      _this.startTimeOffset = _this.progression(options.startPercent, true) * options.duration;
    }

    _this.duration = options.duration;
    return _this;
  }

  _createClass(CustomAnimationStep, [{
    key: "setFrame",
    value: function setFrame(deltaTime) {
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.progression(percentTime);

      if (this.callback != null) {
        this.callback(percentComplete);
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      if (this.callback != null) {
        this.callback(1);
      }
    } // finish(cancelled: boolean = false, force: ?'complete' | 'noComplete' = null) {
    //   if (this.state === 'idle') {
    //     return;
    //   }
    //   super.finish(cancelled, force);
    //   const setToEnd = () => {
    //     if (this.callback != null) {
    //       this.callback(1);
    //     }
    //   };
    //   if (cancelled && force === 'complete') {
    //     setToEnd();
    //   }
    //   if (cancelled && force == null && this.completeOnCancel === true) {
    //     setToEnd();
    //   }
    //   if (cancelled === false) {
    //     setToEnd();
    //   }
    //   if (this.onFinish != null) {
    //     this.onFinish(cancelled);
    //   }
    // }

  }, {
    key: "_dup",
    value: function _dup() {
      var step = new CustomAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step);
      return step;
    }
  }]);

  return CustomAnimationStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_2__["default"]);
function custom() {
  for (var _len2 = arguments.length, optionsIn = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    optionsIn[_key2] = arguments[_key2];
  }

  return _construct(CustomAnimationStep, optionsIn);
}

/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/DelayStep.js":
/*!*************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/DelayStep.js ***!
  \*************************************************************/
/*! exports provided: DelayStep, delay */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DelayStep", function() { return DelayStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "delay", function() { return delay; });
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/diagram/Animation/AnimationStep.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import * as tools from '../../tools/math';
// import { DiagramElement } from '../Element';


// Animations get started from a parent, but finish themselves
var DelayStep =
/*#__PURE__*/
function (_AnimationStep) {
  _inherits(DelayStep, _AnimationStep);

  function DelayStep() {
    var numOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DelayStep);

    var options = {};
    var defaultOptions = {
      duration: 0
    };

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (typeof numOrOptionsIn === 'number') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions, {
        duration: numOrOptionsIn
      }].concat(args));
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions, numOrOptionsIn].concat(args));
    }

    return _possibleConstructorReturn(this, _getPrototypeOf(DelayStep).call(this, options)); // this.duration = options.duration;
  }

  _createClass(DelayStep, [{
    key: "_dup",
    value: function _dup() {
      var dup = new DelayStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, dup);
      return dup;
    }
  }]);

  return DelayStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_0__["default"]);
function delay() {
  var numOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  return _construct(DelayStep, [numOrOptionsIn].concat(args));
}

/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js":
/*!************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ElementAnimationStep; });
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/diagram/Animation/AnimationStep.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

 // import { DiagramElement } from '../../Element';




var ElementAnimationStep =
/*#__PURE__*/
function (_AnimationStep) {
  _inherits(ElementAnimationStep, _AnimationStep);

  function ElementAnimationStep() {
    var _this;

    var optionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ElementAnimationStep);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ElementAnimationStep).call(this, optionsIn));
    var defaultProgression = 'easeinout';

    if (optionsIn.type === 'color' || optionsIn.type === 'custom') {
      defaultProgression = 'linear';
    }

    var defaultOptions = {
      element: null,
      type: 'custom',
      progression: defaultProgression,
      duration: 0
    };
    var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultOptions, optionsIn);
    _this.element = options.element;
    _this.type = options.type;
    _this.onFinish = options.onFinish;
    _this.duration = options.duration;

    if (options.progression === 'linear') {
      _this.progression = _tools_math__WEBPACK_IMPORTED_MODULE_0__["linear"];
    } else if (options.progression === 'easein') {
      _this.progression = _tools_math__WEBPACK_IMPORTED_MODULE_0__["easein"];
    } else if (options.progression === 'easeout') {
      _this.progression = _tools_math__WEBPACK_IMPORTED_MODULE_0__["easeout"];
    } else if (options.progression === 'easeinout') {
      _this.progression = _tools_math__WEBPACK_IMPORTED_MODULE_0__["easeinout"];
    } else {
      _this.progression = options.progression;
    }

    return _this;
  }

  _createClass(ElementAnimationStep, [{
    key: "_dup",
    value: function _dup() {
      var step = new ElementAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return ElementAnimationStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/ColorAnimationStep.js":
/*!*******************************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/ColorAnimationStep.js ***!
  \*******************************************************************************************/
/*! exports provided: ColorAnimationStep, DissolveInAnimationStep, dissolveIn, DissolveOutAnimationStep, dissolveOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorAnimationStep", function() { return ColorAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DissolveInAnimationStep", function() { return DissolveInAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dissolveIn", function() { return dissolveIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DissolveOutAnimationStep", function() { return DissolveOutAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dissolveOut", function() { return dissolveOut; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import {
//   Transform, Point, getMaxTimeFromVelocity,
// } from '../../../../tools/g2';



var addColors = function addColors(color1, color2) {
  return color1.map(function (c, index) {
    return Math.min(c + color2[index], 1);
  });
};

var subtractColors = function subtractColors(color1, color2) {
  return color1.map(function (c, index) {
    return c - color2[index];
  });
};

var ColorAnimationStep =
/*#__PURE__*/
function (_ElementAnimationStep) {
  _inherits(ColorAnimationStep, _ElementAnimationStep);

  function ColorAnimationStep() {
    var _this;

    _classCallCheck(this, ColorAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}].concat(optionsIn, [{
      type: 'color'
    }]));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'dissolve']);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(ColorAnimationStep).call(this, ElementAnimationStepOptionsIn));
    var defaultPositionOptions = {
      start: null,
      target: null,
      delta: null,
      dissolve: null
    };
    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultPositionOptions].concat(optionsIn)); // $FlowFixMe

    _this.color = {};
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["copyKeysFromTo"])(options, _this.color, ['start', 'delta', 'target', 'dissolve']);
    return _this;
  } // On start, calculate the duration, target and delta if not already present.
  // This is done here in case the start is defined as null meaning it is
  // going to start from present transform.
  // Setting a duration to 0 will effectively skip this animation step


  _createClass(ColorAnimationStep, [{
    key: "start",
    value: function start(startTime) {
      var element = this.element;

      if (element != null) {
        _get(_getPrototypeOf(ColorAnimationStep.prototype), "start", this).call(this, startTime);

        if (this.color.start == null) {
          this.color.start = element.color.slice();
        }

        if (this.color.delta == null && this.color.target == null) {
          this.color.target = this.color.start.slice();
        } else if (this.color.delta != null) {
          this.color.target = addColors(this.color.start, this.color.delta);
        }

        this.color.whenComplete = this.color.target.slice();

        if (this.color.dissolve === 'out') {
          this.color.target[3] = 0.001;
        }

        if (this.color.dissolve === 'in') {
          this.color.start[3] = 0.001;
          element.setColor(this.color.start);
          element.showAll();
        }

        this.color.delta = subtractColors(this.color.target, this.color.start);
      } else {
        this.duration = 0;
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      var _this2 = this;

      var percentTime = deltaTime / this.duration;
      var percentComplete = this.progression(percentTime);
      var p = percentComplete;
      var next = this.color.start.map(function (c, index) {
        var newColor = c + _this2.color.delta[index] * p;

        if (newColor > 1) {
          newColor = 1;
        }

        if (newColor < 0) {
          newColor = 0;
        }

        return newColor;
      });

      if (this.element != null) {
        this.element.setColor(next);
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      var element = this.element;

      if (element != null) {
        // console.log(this.name, this.color.whenComplete)
        element.setColor(this.color.whenComplete);

        if (this.color.dissolve === 'out') {
          element.hide();
        }
      }
    } // finish(cancelled: boolean = false, force: ?'complete' | 'noComplete' = null) {
    //   if (this.state === 'idle') {
    //     return;
    //   }
    //   super.finish(cancelled, force);
    //   const setToEnd = () => {
    //     const { element } = this;
    //     if (element != null) {
    //       element.setColor(this.color.whenComplete);
    //       if (this.color.dissolve === 'out') {
    //         element.hide();
    //       }
    //     }
    //   };
    //   if (cancelled && force === 'complete') {
    //     setToEnd();
    //   }
    //   if (cancelled && force == null && this.completeOnCancel === true) {
    //     setToEnd();
    //   }
    //   if (cancelled === false) {
    //     setToEnd();
    //   }
    //   if (this.onFinish != null) {
    //     this.onFinish(cancelled);
    //   }
    // }

  }, {
    key: "_dup",
    value: function _dup() {
      var step = new ColorAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return ColorAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__["default"]);
var DissolveInAnimationStep =
/*#__PURE__*/
function (_ColorAnimationStep) {
  _inherits(DissolveInAnimationStep, _ColorAnimationStep);

  function DissolveInAnimationStep() {
    var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DissolveInAnimationStep);

    var options = {};
    var defaultOptions = {
      duration: 1,
      dissolve: 'in',
      completeOnCancel: true
    };

    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    if (typeof timeOrOptionsIn === 'number') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, {
        duration: timeOrOptionsIn
      }].concat(args));
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
    }

    return _possibleConstructorReturn(this, _getPrototypeOf(DissolveInAnimationStep).call(this, options));
  }

  return DissolveInAnimationStep;
}(ColorAnimationStep);
function dissolveIn() {
  var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return _construct(DissolveInAnimationStep, [timeOrOptionsIn].concat(args));
}
var DissolveOutAnimationStep =
/*#__PURE__*/
function (_ColorAnimationStep2) {
  _inherits(DissolveOutAnimationStep, _ColorAnimationStep2);

  function DissolveOutAnimationStep() {
    var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DissolveOutAnimationStep);

    var options = {};
    var defaultOptions = {
      duration: 1,
      dissolve: 'out',
      completeOnCancel: true
    };

    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }

    if (typeof timeOrOptionsIn === 'number') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, {
        duration: timeOrOptionsIn
      }].concat(args));
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
    }

    return _possibleConstructorReturn(this, _getPrototypeOf(DissolveOutAnimationStep).call(this, options));
  }

  return DissolveOutAnimationStep;
}(ColorAnimationStep);
function dissolveOut() {
  var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }

  return _construct(DissolveOutAnimationStep, [timeOrOptionsIn].concat(args));
}

/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/OpacityAnimationStep.js":
/*!*********************************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/OpacityAnimationStep.js ***!
  \*********************************************************************************************/
/*! exports provided: OpacityAnimationStep, DissolveInAnimationStep, dissolveIn, DissolveOutAnimationStep, dissolveOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OpacityAnimationStep", function() { return OpacityAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DissolveInAnimationStep", function() { return DissolveInAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dissolveIn", function() { return dissolveIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DissolveOutAnimationStep", function() { return DissolveOutAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dissolveOut", function() { return dissolveOut; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import {
//   Transform, Point, getMaxTimeFromVelocity,
// } from '../../../../tools/g2';


var OpacityAnimationStep =
/*#__PURE__*/
function (_ElementAnimationStep) {
  _inherits(OpacityAnimationStep, _ElementAnimationStep);

  function OpacityAnimationStep() {
    var _this;

    _classCallCheck(this, OpacityAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}].concat(optionsIn, [{
      type: 'color'
    }]));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'dissolve']);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(OpacityAnimationStep).call(this, ElementAnimationStepOptionsIn));
    var defaultPositionOptions = {
      start: null,
      target: null,
      delta: null,
      dissolve: null
    };
    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultPositionOptions].concat(optionsIn)); // $FlowFixMe

    _this.opacity = {};
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["copyKeysFromTo"])(options, _this.opacity, ['start', 'delta', 'target', 'dissolve']);
    return _this;
  } // On start, calculate the duration, target and delta if not already present.
  // This is done here in case the start is defined as null meaning it is
  // going to start from present transform.
  // Setting a duration to 0 will effectively skip this animation step


  _createClass(OpacityAnimationStep, [{
    key: "start",
    value: function start(startTime) {
      var element = this.element;

      if (element != null) {
        _get(_getPrototypeOf(OpacityAnimationStep.prototype), "start", this).call(this, startTime);

        if (this.opacity.start == null) {
          // eslint-disable-next-line prefer-destructuring
          this.opacity.start = element.color[3];
        }

        if (this.opacity.delta == null && this.opacity.target == null) {
          this.opacity.target = this.opacity.start;
        } else if (this.opacity.delta != null) {
          this.opacity.target = this.opacity.start + this.opacity.delta;
        }

        this.opacity.whenComplete = this.opacity.target;

        if (this.opacity.dissolve === 'out') {
          this.opacity.target = 0.001;
        }

        if (this.opacity.dissolve === 'in') {
          this.opacity.start = 0.001;
          element.setOpacity(this.opacity.start);
          element.showAll();
        }

        this.opacity.delta = this.opacity.target - this.opacity.start;
      } else {
        this.duration = 0;
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.progression(percentTime);
      var p = percentComplete;
      var next = this.opacity.start + this.opacity.delta * p;

      if (next > 1) {
        next = 1;
      }

      if (next < 0) {
        next = 0;
      }

      if (this.element != null) {
        this.element.setOpacity(next);
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      var element = this.element;

      if (element != null) {
        // console.log(this.name, this.color.whenComplete)
        element.setOpacity(this.opacity.whenComplete);

        if (this.opacity.dissolve === 'out') {
          element.hide();
        }
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new OpacityAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return OpacityAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__["default"]);
var DissolveInAnimationStep =
/*#__PURE__*/
function (_OpacityAnimationStep) {
  _inherits(DissolveInAnimationStep, _OpacityAnimationStep);

  function DissolveInAnimationStep() {
    var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DissolveInAnimationStep);

    var options = {};
    var defaultOptions = {
      duration: 1,
      dissolve: 'in',
      completeOnCancel: true
    };

    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    if (typeof timeOrOptionsIn === 'number') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, {
        duration: timeOrOptionsIn
      }].concat(args));
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
    }

    return _possibleConstructorReturn(this, _getPrototypeOf(DissolveInAnimationStep).call(this, options));
  }

  return DissolveInAnimationStep;
}(OpacityAnimationStep);
function dissolveIn() {
  var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return _construct(DissolveInAnimationStep, [timeOrOptionsIn].concat(args));
}
var DissolveOutAnimationStep =
/*#__PURE__*/
function (_OpacityAnimationStep2) {
  _inherits(DissolveOutAnimationStep, _OpacityAnimationStep2);

  function DissolveOutAnimationStep() {
    var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DissolveOutAnimationStep);

    var options = {};
    var defaultOptions = {
      duration: 1,
      dissolve: 'out',
      completeOnCancel: true
    };

    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }

    if (typeof timeOrOptionsIn === 'number') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, {
        duration: timeOrOptionsIn
      }].concat(args));
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
    }

    return _possibleConstructorReturn(this, _getPrototypeOf(DissolveOutAnimationStep).call(this, options));
  }

  return DissolveOutAnimationStep;
}(OpacityAnimationStep);
function dissolveOut() {
  var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }

  return _construct(DissolveOutAnimationStep, [timeOrOptionsIn].concat(args));
}

/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/PositionAnimationStep.js":
/*!**********************************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/PositionAnimationStep.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PositionAnimationStep; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var PositionAnimationStep =
/*#__PURE__*/
function (_ElementAnimationStep) {
  _inherits(PositionAnimationStep, _ElementAnimationStep);

  function PositionAnimationStep() {
    var _this;

    _classCallCheck(this, PositionAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, {
      type: 'position'
    }].concat(optionsIn));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'translationStyle', 'translationOptions', 'velocity']);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PositionAnimationStep).call(this, ElementAnimationStepOptionsIn));
    var defaultPositionOptions = {
      start: null,
      target: null,
      delta: null,
      translationStyle: 'linear',
      translationOptions: {
        rot: 1,
        magnitude: 0.5,
        offset: 0.5,
        controlPoint: null,
        direction: ''
      },
      velocity: null
    };
    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultPositionOptions].concat(optionsIn)); // $FlowFixMe

    _this.position = {
      translationOptions: {}
    };
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["copyKeysFromTo"])(options, _this.position, ['start', 'delta', 'target', 'translationStyle', 'velocity']);
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(options.translationOptions, _this.position.translationOptions);
    return _this;
  } // On start, calculate the duration, target and delta if not already present.
  // This is done here in case the start is defined as null meaning it is
  // going to start from present transform.
  // Setting a duration to 0 will effectively skip this animation step


  _createClass(PositionAnimationStep, [{
    key: "start",
    value: function start(startTime) {
      _get(_getPrototypeOf(PositionAnimationStep.prototype), "start", this).call(this, startTime);

      if (this.position.start === null) {
        if (this.element != null) {
          this.position.start = this.element.getPosition();
        } else {
          this.duration = 0;
          return;
        }
      } // if delta is null, then calculate it from start and target


      if (this.position.delta == null && this.position.target != null && this.position.start != null) {
        var delta = this.position.target.sub(this.position.start);
        this.position.delta = delta;
      } else if (this.position.delta != null && this.position.start != null) {
        this.position.target = this.position.start.add(this.position.delta);
      } else {
        this.duration = 0;
      } // If Velocity is defined, then use it to calculate duration


      var _this$position = this.position,
          target = _this$position.target,
          start = _this$position.start,
          velocity = _this$position.velocity;

      if (velocity != null && start != null && target != null) {
        var velocityToUse = velocity;

        if (typeof velocity === 'number') {
          velocityToUse = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](velocity, velocity);
        }

        this.duration = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(start), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(target), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(velocityToUse));
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.progression(percentTime);
      var p = percentComplete;

      if (this.position.delta != null && this.position.start != null) {
        var next = this.position.start.toDelta(this.position.delta, p, this.position.translationStyle, this.position.translationOptions);

        if (this.element != null) {
          this.element.setPosition(next);
        }
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      if (this.element != null) {
        this.element.setPosition(this.position.target);
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new PositionAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return PositionAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/PulseAnimationStep.js":
/*!*******************************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/PulseAnimationStep.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PulseAnimationStep; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var PulseAnimationStep =
/*#__PURE__*/
function (_ElementAnimationStep) {
  _inherits(PulseAnimationStep, _ElementAnimationStep);

  function PulseAnimationStep() {
    var _this;

    _classCallCheck(this, PulseAnimationStep);

    // const ElementAnimationStepOptionsIn =
    //   joinObjects({}, { type: 'pulse' }, ...optionsIn);
    // super(ElementAnimationStepOptionsIn);
    var defaultOptions = {
      scale: 1.5,
      numLines: 1,
      type: 'pulse',
      duration: 1,
      frequency: 0
    };

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PulseAnimationStep).call(this, options));
    _this.scale = options.scale;
    _this.numLines = options.numLines;
    _this.duration = options.duration;
    _this.frequency = options.frequency;
    return _this;
  } // On start, calculate the duration, target and delta if not already present.
  // This is done here in case the start is defined as null meaning it is
  // going to start from present transform.
  // Setting a duration to 0 will effectively skip this animation step


  _createClass(PulseAnimationStep, [{
    key: "start",
    value: function start(startTime) {
      _get(_getPrototypeOf(PulseAnimationStep.prototype), "start", this).call(this, startTime);

      var element = this.element;

      if (element != null) {
        if (this.numLines === 1) {
          element.pulseScaleNow(this.duration, this.scale, this.frequency);
        } else {
          element.pulseThickNow(this.duration, this.scale, this.numLines);
        }
      }
    } // setFrame(deltaTime: number) {
    // }

  }, {
    key: "setToEnd",
    value: function setToEnd() {
      if (this.element != null) {
        this.element.stopPulsing(true);
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new PulseAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return PulseAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/RotationAnimationStep.js":
/*!**********************************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/RotationAnimationStep.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RotationAnimationStep; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





// A transform animation unit manages a transform animation on an element.
//
// The start transform can either be defined initially, or null. Null means
// the start transform is whatever the current element transform is when the
// unit is started with start().
//
// The transform target is defined with either the target or delta properties.
// Target is used to predefine the target.
// Delta is used to calculate the target when the unit is started with start()
//
var RotationAnimationStep =
/*#__PURE__*/
function (_ElementAnimationStep) {
  _inherits(RotationAnimationStep, _ElementAnimationStep);

  function RotationAnimationStep() {
    var _this;

    _classCallCheck(this, RotationAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, {
      type: 'rotation'
    }].concat(optionsIn));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'direction', 'velocity', 'clipTo']);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(RotationAnimationStep).call(this, ElementAnimationStepOptionsIn));
    var defaultTransformOptions = {
      start: null,
      target: null,
      delta: null,
      direction: 0,
      velocity: null,
      clipTo: null
    };
    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultTransformOptions].concat(optionsIn)); // $FlowFixMe

    _this.rotation = {};
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["copyKeysFromTo"])(options, _this.rotation, ['start', 'delta', 'target', 'velocity', 'direction', 'clipTo']);
    return _this;
  } // On start, calculate the duration, target and delta if not already present.
  // This is done here in case the start is defined as null meaning it is
  // going to start from present transform.
  // Setting a duration to 0 will effectively skip this animation step


  _createClass(RotationAnimationStep, [{
    key: "start",
    value: function start(startTime) {
      _get(_getPrototypeOf(RotationAnimationStep.prototype), "start", this).call(this, startTime);

      if (this.rotation.start === null) {
        if (this.element != null) {
          this.rotation.start = this.element.transform.r() || 0;
        } else {
          this.duration = 0;
          return;
        }
      } // if delta is null, then calculate it from start and target


      if (this.rotation.delta == null && this.rotation.target != null) {
        var delta = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getDeltaAngle"])(this.rotation.start, this.rotation.target, this.rotation.direction);
        this.rotation.delta = delta;
      } else if (this.rotation.delta != null) {
        this.rotation.target = this.rotation.start + this.rotation.delta;
      } else {
        this.duration = 0;
      } // If Velocity is defined, then use it to calculate duration


      var velocity = this.rotation.velocity;

      if (velocity != null) {
        this.duration = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(this.rotation.start), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(this.rotation.target), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(velocity), this.rotation.direction);
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.progression(percentTime);
      var p = percentComplete;
      var nextR = this.rotation.start + this.rotation.delta * p;
      nextR = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(nextR, this.rotation.clipTo);
      var element = this.element;

      if (element != null) {
        element.setRotation(nextR);
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      var element = this.element;

      if (element != null) {
        element.transform.updateRotation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(this.rotation.target, this.rotation.clipTo));
        element.setTransformCallback(element.transform);
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new RotationAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return RotationAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/ScaleAnimationStep.js":
/*!*******************************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/ScaleAnimationStep.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ScaleAnimationStep; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var ScaleAnimationStep =
/*#__PURE__*/
function (_ElementAnimationStep) {
  _inherits(ScaleAnimationStep, _ElementAnimationStep);

  function ScaleAnimationStep() {
    var _this;

    _classCallCheck(this, ScaleAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, {
      type: 'position'
    }].concat(optionsIn));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'velocity']);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScaleAnimationStep).call(this, ElementAnimationStepOptionsIn));
    var defaultPositionOptions = {
      start: null,
      target: null,
      delta: null,
      velocity: null
    };
    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultPositionOptions].concat(optionsIn)); // $FlowFixMe

    _this.scale = {};

    if (typeof options.start === 'number') {
      options.start = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](options.start, options.start);
    }

    if (typeof options.target === 'number') {
      options.target = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](options.target, options.target);
    }

    if (typeof options.delta === 'number') {
      options.delta = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](options.delta, options.delta);
    }

    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["copyKeysFromTo"])(options, _this.scale, ['start', 'delta', 'target', 'translationStyle', 'velocity']);
    return _this;
  } // On start, calculate the duration, target and delta if not already present.
  // This is done here in case the start is defined as null meaning it is
  // going to start from present transform.
  // Setting a duration to 0 will effectively skip this animation step


  _createClass(ScaleAnimationStep, [{
    key: "start",
    value: function start(startTime) {
      _get(_getPrototypeOf(ScaleAnimationStep.prototype), "start", this).call(this, startTime);

      if (this.scale.start === null) {
        if (this.element != null) {
          this.scale.start = this.element.getScale();
        } else {
          this.duration = 0;
          return;
        }
      } // if delta is null, then calculate it from start and target


      if (this.scale.delta == null && this.scale.target != null && this.scale.start != null) {
        var delta = this.scale.target.sub(this.scale.start);
        this.scale.delta = delta;
      } else if (this.scale.delta != null && this.scale.start != null) {
        this.scale.target = this.scale.start.add(this.scale.delta);
      } else {
        this.duration = 0;
      } // If Velocity is defined, then use it to calculate duration


      var _this$scale = this.scale,
          target = _this$scale.target,
          start = _this$scale.start,
          velocity = _this$scale.velocity;

      if (velocity != null && target != null && start != null) {
        var velocityToUse = velocity;

        if (typeof velocity === 'number') {
          velocityToUse = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](velocity, velocity);
        }

        this.duration = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(start), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(target), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(velocityToUse));
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.progression(percentTime);
      var p = percentComplete;

      if (this.scale.start != null && this.scale.delta != null) {
        var next = this.scale.start.toDelta(this.scale.delta, p);

        if (this.element != null) {
          this.element.setScale(next);
        }
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      if (this.element != null) {
        this.element.setScale(this.scale.target);
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new ScaleAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return ScaleAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/TransformAnimationStep.js":
/*!***********************************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ElementAnimationStep/TransformAnimationStep.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TransformAnimationStep; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/diagram/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





// A transform animation unit manages a transform animation on an element.
//
// The start transform can either be defined initially, or null. Null means
// the start transform is whatever the current element transform is when the
// unit is started with start().
//
// The transform target is defined with either the target or delta properties.
// Target is used to predefine the target.
// Delta is used to calculate the target when the unit is started with start()
//
var TransformAnimationStep =
/*#__PURE__*/
function (_ElementAnimationStep) {
  _inherits(TransformAnimationStep, _ElementAnimationStep);

  function TransformAnimationStep() {
    var _this;

    _classCallCheck(this, TransformAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, {
      type: 'transform'
    }].concat(optionsIn));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'rotDirection', 'translationStyle', 'translationOptions', 'velocity', 'clipRotationTo']);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(TransformAnimationStep).call(this, ElementAnimationStepOptionsIn));
    var defaultTransformOptions = {
      start: null,
      target: null,
      delta: null,
      translationStyle: 'linear',
      rotDirection: 0,
      translationOptions: {
        rot: 1,
        magnitude: 0.5,
        offset: 0.5,
        controlPoint: null,
        direction: ''
      },
      velocity: null,
      clipRotationTo: null
    };
    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultTransformOptions].concat(optionsIn)); // $FlowFixMe

    _this.transform = {
      translationOptions: {}
    };
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["copyKeysFromTo"])(options, _this.transform, ['start', 'delta', 'target', 'translationStyle', 'velocity', 'rotDirection', 'clipRotationTo']);
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(options.translationOptions, _this.transform.translationOptions);
    return _this;
  } // On start, calculate the duration, target and delta if not already present.
  // This is done here in case the start is defined as null meaning it is
  // going to start from present transform.
  // Setting a duration to 0 will effectively skip this animation step


  _createClass(TransformAnimationStep, [{
    key: "start",
    value: function start(startTime) {
      var _this2 = this;

      _get(_getPrototypeOf(TransformAnimationStep.prototype), "start", this).call(this, startTime);

      if (this.transform.start === null) {
        if (this.element != null) {
          this.transform.start = this.element.transform._dup();
        } else {
          this.duration = 0;
          return;
        }
      } // if delta is null, then calculate it from start and target


      if (this.transform.delta == null && this.transform.target != null) {
        var delta = this.transform.target.sub(this.transform.start);
        delta.order.forEach(function (deltaStep, index) {
          var startStep = _this2.transform.start.order[index];
          var targetStep = _this2.transform.target.order[index];

          if (deltaStep instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"] && startStep instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"] && targetStep instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"]) {
            var rotDiff = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getDeltaAngle"])(startStep.r, targetStep.r, _this2.transform.rotDirection); // eslint-disable-next-line no-param-reassign

            deltaStep.r = rotDiff;
          }
        });
        this.transform.delta = delta;
      } else if (this.transform.delta != null) {
        this.transform.target = this.transform.start.add(this.transform.delta);
      } else {
        this.duration = 0;
      } // If Velocity is defined, then use it to calculate duration


      if (this.transform.velocity != null) {
        this.duration = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(this.transform.start, this.transform.target, this.transform.velocity, this.transform.rotDirection);
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      // const start = phase.startTransform._dup();
      // const delta = phase.deltaTransform._dup();
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.progression(percentTime);
      var p = percentComplete; // let next = delta._dup().constant(p);
      // next = start.add(delta.mul(next));

      var next = this.transform.start.toDelta(this.transform.delta, p, this.transform.translationStyle, this.transform.translationOptions);

      if (this.transform.clipRotationTo !== null) {
        next.clipRotation(this.transform.clipRotationTo);
      }

      if (this.element != null) {
        this.element.setTransform(next);
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      if (this.element != null) {
        this.element.setTransform(this.transform.target);
      }
    } // finish(cancelled: boolean = false, force: ?'complete' | 'noComplete' = null) {
    //   if (this.state === 'idle') {
    //     return;
    //   }
    //   super.finish(cancelled, force);
    //   const setToEnd = () => {
    //     if (this.element != null) {
    //       this.element.setTransform(this.transform.target);
    //     }
    //   };
    //   if (cancelled && force === 'complete') {
    //     setToEnd();
    //   }
    //   if (cancelled && force == null && this.completeOnCancel === true) {
    //     setToEnd();
    //   }
    //   if (cancelled === false) {
    //     setToEnd();
    //   }
    //   if (this.onFinish != null) {
    //     this.onFinish(cancelled);
    //   }
    // }

  }, {
    key: "_dup",
    value: function _dup() {
      var step = new TransformAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return TransformAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/ParallelAnimationStep.js":
/*!*************************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/ParallelAnimationStep.js ***!
  \*************************************************************************/
/*! exports provided: ParallelAnimationStep, inParallel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParallelAnimationStep", function() { return ParallelAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inParallel", function() { return inParallel; });
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/diagram/Animation/AnimationStep.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import * as tools from '../../tools/math';
// import { DiagramElement } from '../Element';


// Animations get started from a parent, but finish themselves
var ParallelAnimationStep =
/*#__PURE__*/
function (_AnimationStep) {
  _inherits(ParallelAnimationStep, _AnimationStep);

  function ParallelAnimationStep() {
    var _this;

    var stepsOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ParallelAnimationStep);

    var defaultOptions = {
      steps: []
    };
    var options;

    for (var _len = arguments.length, optionsIn = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      optionsIn[_key - 1] = arguments[_key];
    }

    if (Array.isArray(stepsOrOptionsIn)) {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      options.steps = stepsOrOptionsIn;
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions, stepsOrOptionsIn].concat(optionsIn));
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ParallelAnimationStep).call(this, options));
    _this.steps = [];

    if (!Array.isArray(options.steps) && options.steps != null) {
      _this.steps = [options.steps];
    } else if (options.steps != null) {
      _this.steps = options.steps;
    }

    return _this;
  }

  _createClass(ParallelAnimationStep, [{
    key: "nextFrame",
    value: function nextFrame(now) {
      var remaining = -1;
      this.steps.forEach(function (step) {
        var stepRemaining = step.nextFrame(now); // console.log(step.element.uid, stepRemaining)

        if (remaining === -1) {
          remaining = stepRemaining;
        }

        if (stepRemaining < remaining) {
          remaining = stepRemaining;
        }
      });

      if (remaining > 0) {
        this.finish();
      }

      return remaining;
    }
  }, {
    key: "startWaiting",
    value: function startWaiting() {
      _get(_getPrototypeOf(ParallelAnimationStep.prototype), "startWaiting", this).call(this);

      this.steps.forEach(function (step) {
        step.startWaiting();
      });
    }
  }, {
    key: "start",
    value: function start(startTime) {
      this.startWaiting();

      _get(_getPrototypeOf(ParallelAnimationStep.prototype), "start", this).call(this, startTime);

      this.steps.forEach(function (step) {
        step.start(startTime);
      });
    }
  }, {
    key: "finish",
    value: function finish() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (this.state === 'idle' || this.state === 'finished') {
        return;
      } // super.finish(cancelled, force);


      this.state = 'finished';
      var forceToUse = null;

      if (this.completeOnCancel === true) {
        forceToUse = 'complete';
      }

      if (this.completeOnCancel === false) {
        forceToUse = 'noComplete';
      }

      if (force != null) {
        forceToUse = force;
      }

      this.steps.forEach(function (step) {
        if (step.state !== 'idle' && step.state !== 'finished') {
          step.finish(cancelled, forceToUse);
        }
      });

      if (this.onFinish != null) {
        this.onFinish(cancelled);
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new ParallelAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step);
      return step;
    }
  }]);

  return ParallelAnimationStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_0__["default"]);
function inParallel() {
  var stepsOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len2 = arguments.length, optionsIn = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    optionsIn[_key2 - 1] = arguments[_key2];
  }

  return _construct(ParallelAnimationStep, [stepsOrOptionsIn].concat(optionsIn));
}

/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/SerialAnimationStep.js":
/*!***********************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/SerialAnimationStep.js ***!
  \***********************************************************************/
/*! exports provided: SerialAnimationStep, inSerial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SerialAnimationStep", function() { return SerialAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inSerial", function() { return inSerial; });
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/diagram/Animation/AnimationStep.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import * as tools from '../../tools/math';
// import { DiagramElement } from '../Element';


var SerialAnimationStep =
/*#__PURE__*/
function (_AnimationStep) {
  _inherits(SerialAnimationStep, _AnimationStep);

  function SerialAnimationStep() {
    var _this;

    var stepsOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, SerialAnimationStep);

    var defaultOptions = {
      steps: []
    };
    var options;

    for (var _len = arguments.length, optionsIn = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      optionsIn[_key - 1] = arguments[_key];
    }

    if (Array.isArray(stepsOrOptionsIn)) {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      options.steps = stepsOrOptionsIn;
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions, stepsOrOptionsIn].concat(optionsIn));
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SerialAnimationStep).call(this, options));
    _this.index = 0;
    _this.steps = [];

    if (!Array.isArray(options.steps) && options.steps != null) {
      _this.steps = [options.steps];
    } else if (options.steps != null) {
      _this.steps = options.steps;
    }

    return _this;
  } // constructor(optionsIn: TypeSerialAnimationStepInputOptions = {}) {
  //   super(optionsIn);
  //   this.index = 0;
  //   const defaultOptions = {};
  //   const options = joinObjects({}, defaultOptions, optionsIn);
  //   this.steps = [];
  //   if (!Array.isArray(options.steps) && options.steps != null) {
  //     this.steps = [options.steps];
  //   } else if (options.steps != null) {
  //     this.steps = options.steps;
  //   }
  //   return this;
  // }


  _createClass(SerialAnimationStep, [{
    key: "then",
    value: function then(step) {
      this.steps.push(step);
      return this;
    }
  }, {
    key: "startWaiting",
    value: function startWaiting() {
      _get(_getPrototypeOf(SerialAnimationStep.prototype), "startWaiting", this).call(this);

      this.steps.forEach(function (step) {
        step.startWaiting();
      });
    }
  }, {
    key: "start",
    value: function start(startTime) {
      if (this.state !== 'animating') {
        this.startWaiting();

        _get(_getPrototypeOf(SerialAnimationStep.prototype), "start", this).call(this, startTime);

        this.index = 0;

        if (this.steps.length > 0) {
          this.steps[0].start(startTime);
        }
      }
    }
  }, {
    key: "nextFrame",
    value: function nextFrame(now) {
      var remaining = -1;

      if (this.index <= this.steps.length - 1) {
        remaining = this.steps[this.index].nextFrame(now); // console.log('serial', now, this.index, remaining)

        if (remaining > 0) {
          if (this.index === this.steps.length - 1) {
            this.finish();
            return remaining;
          }

          this.index += 1;
          this.steps[this.index].start(now - remaining);
          return this.nextFrame(now);
        }
      }

      return remaining;
    }
  }, {
    key: "finish",
    value: function finish() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (this.state === 'idle' || this.state === 'finished') {
        return;
      } // super.finish(cancelled, force);


      this.state = 'finished';
      var forceToUse = null;

      if (this.completeOnCancel === true) {
        forceToUse = 'complete';
      }

      if (this.completeOnCancel === false) {
        forceToUse = 'noComplete';
      }

      if (force != null) {
        forceToUse = force;
      }

      this.steps.forEach(function (step) {
        if (step.state !== 'idle' && step.state !== 'finished') {
          step.finish(cancelled, forceToUse);
        }
      });

      if (this.onFinish != null) {
        this.onFinish(cancelled);
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new SerialAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step);
      return step;
    }
  }]);

  return SerialAnimationStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_0__["default"]);
function inSerial() {
  var stepsOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len2 = arguments.length, optionsIn = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    optionsIn[_key2 - 1] = arguments[_key2];
  }

  return _construct(SerialAnimationStep, [stepsOrOptionsIn].concat(optionsIn));
}

/***/ }),

/***/ "./src/js/diagram/Animation/AnimationStep/TriggerStep.js":
/*!***************************************************************!*\
  !*** ./src/js/diagram/Animation/AnimationStep/TriggerStep.js ***!
  \***************************************************************/
/*! exports provided: TriggerStep, trigger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriggerStep", function() { return TriggerStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trigger", function() { return trigger; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/diagram/Animation/AnimationStep.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var TriggerStep =
/*#__PURE__*/
function (_AnimationStep) {
  _inherits(TriggerStep, _AnimationStep);

  function TriggerStep() {
    var _this;

    var triggerOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, TriggerStep);

    var defaultOptions = {
      payload: null,
      duration: 0
    };
    var options;

    for (var _len = arguments.length, optionsIn = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      optionsIn[_key - 1] = arguments[_key];
    }

    if (typeof triggerOrOptionsIn === 'function') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      options.callback = triggerOrOptionsIn;
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, triggerOrOptionsIn].concat(optionsIn));
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TriggerStep).call(this, options));
    _this.callback = options.callback;
    _this.payload = options.payload;
    _this.duration = options.duration;
    return _this;
  }

  _createClass(TriggerStep, [{
    key: "setFrame",
    value: function setFrame() {
      if (this.callback != null) {
        this.callback(this.payload);
        this.callback = null;
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new TriggerStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["duplicateFromTo"])(this, step, ['element']);
      return step;
    }
  }]);

  return TriggerStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_1__["default"]);
function trigger() {
  var triggerOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len2 = arguments.length, optionsIn = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    optionsIn[_key2 - 1] = arguments[_key2];
  }

  return _construct(TriggerStep, [triggerOrOptionsIn].concat(optionsIn));
}

/***/ }),

/***/ "./src/js/diagram/AnimationPhase.js":
/*!******************************************!*\
  !*** ./src/js/diagram/AnimationPhase.js ***!
  \******************************************/
/*! exports provided: AnimationPhase, ColorAnimationPhase, CustomAnimationPhase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationPhase", function() { return AnimationPhase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorAnimationPhase", function() { return ColorAnimationPhase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomAnimationPhase", function() { return CustomAnimationPhase; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Element */ "./src/js/diagram/Element.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



// eslint-disable-next-line import/no-cycle
 // import { joinObjects } from '../tools/tools';
// Planned Animation

var AnimationPhase =
/*#__PURE__*/
function () {
  // The target transform to animate to
  // animation time or velocity.
  // If velocity=0, it is disregarded.
  // Time for all transform operations will be equal to the time of the longest
  // operation.
  // animation time
  // Direction of rotation
  // Animation style
  // Time when phase started
  // Transform at start of phase
  // Transform delta from start to target
  function AnimationPhase() {
    var startTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var targetTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
    var timeOrVelocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var rotDirection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var finishOnCancel = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    var animationStyle = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : _tools_math__WEBPACK_IMPORTED_MODULE_1__["easeinout"];
    var translationStyle = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'linear';
    var translationOptions = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : {
      rot: 1,
      magnitude: 0.5,
      offset: 0.5,
      controlPoint: null,
      direction: ''
    };

    _classCallCheck(this, AnimationPhase);

    if (startTransform == null) {
      this.startTransform = null;
    } else {
      this.startTransform = startTransform._dup();
    }

    this.targetTransform = targetTransform._dup();
    this.timeOrVelocity = timeOrVelocity;
    this.rotDirection = rotDirection;
    this.animationStyle = animationStyle;
    this.translationStyle = translationStyle;
    this.translationOptions = translationOptions;
    this.callback = callback;
    this.finishOnCancel = finishOnCancel;
    this.startTime = -1; // this.startTransform = new Transform();

    this.deltaTransform = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
  }

  _createClass(AnimationPhase, [{
    key: "_dup",
    value: function _dup() {
      var c = new AnimationPhase(this.startTransform, this.targetTransform, this.timeOrVelocity, this.rotDirection, this.callback, this.finishOnCancel, this.animationStyle, this.translationStyle, Object.assign({}, this.translationOptions));
      c.startTime = this.startTime; // this.startTransform = this.startTransform._dup();

      c.deltaTransform = this.deltaTransform._dup();
      return c;
    }
  }, {
    key: "start",
    value: function start(currentTransform) {
      var _this = this;

      if (this.startTransform == null) {
        this.startTransform = currentTransform._dup();
      }

      var startTransform = this.startTransform;

      if (startTransform != null) {
        this.deltaTransform = this.targetTransform.sub(startTransform);
        var time = 0;

        if (typeof this.timeOrVelocity === 'number') {
          time = this.timeOrVelocity;
        } else {
          time = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(startTransform, this.targetTransform, this.timeOrVelocity, this.rotDirection);
        }

        if (time === 0) {
          this.time = 1;
        } else {
          this.time = time;
        }

        this.deltaTransform.order.forEach(function (delta, index) {
          var start = startTransform.order[index];
          var target = _this.targetTransform.order[index];

          if (delta instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"] && start instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"] && target instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"]) {
            var rotDiff = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getDeltaAngle"])(start.r, target.r, _this.rotDirection); // eslint-disable-next-line no-param-reassign

            delta.r = rotDiff;
          }
        });
        this.startTime = -1;
      }
    }
  }, {
    key: "finish",
    value: function finish( // eslint-disable-next-line no-use-before-define
    element) {
      var _this2 = this;

      var cancelled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var forceSetToEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      // console.log('finished', this.callback)
      var setToEnd = function setToEnd() {
        element.setTransform(_this2.targetTransform);
      };

      if (forceSetToEnd === null) {
        if (!cancelled || this.finishOnCancel) {
          setToEnd();
        }
      }

      if (forceSetToEnd === true) {
        setToEnd();
      }

      if (this.callback != null) {
        this.callback(cancelled);
      }
    }
  }]);

  return AnimationPhase;
}(); // Planned Animation

var ColorAnimationPhase =
/*#__PURE__*/
function () {
  // The target transform to animate to
  // animation time
  // Animation style
  // Time when phase started
  // callbackOnCancel: boolean;
  function ColorAnimationPhase() {
    var startColor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var targetColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0, 1];
    var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var disolve = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var finishOnCancel = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    var animationStyle = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : _tools_math__WEBPACK_IMPORTED_MODULE_1__["linear"];

    _classCallCheck(this, ColorAnimationPhase);

    this.targetColor = targetColor.slice();
    this.endColor = targetColor.slice();

    if (disolve === 'out') {
      this.targetColor[3] = 0.01;
    }

    this.time = time;
    this.animationStyle = animationStyle;
    this.disolve = disolve;
    this.finishOnCancel = finishOnCancel; // this.callbackOnCancel = callbackOnCancel;

    this.startTime = -1;
    this.startColor = startColor;
    this.deltaColor = [0, 0, 0, 1];
    this.callback = callback;
  }

  _createClass(ColorAnimationPhase, [{
    key: "_dup",
    value: function _dup() {
      var c = new ColorAnimationPhase(this.startColor, this.targetColor, this.time, this.disolve, this.callback, this.finishOnCancel, // this.callbackOnCancel,
      this.animationStyle);
      c.startTime = this.startTime; // this.startColor = this.startColor.slice();

      c.deltaColor = this.deltaColor.slice();
      return c;
    } // eslint-disable-next-line no-use-before-define

  }, {
    key: "start",
    value: function start(element) {
      if (this.startColor == null) {
        this.startColor = element.color.slice();
      }

      var startColor = this.startColor;

      if (startColor != null) {
        if (this.disolve === 'in') {
          this.startColor[3] = 0.01;
          element.setColor(startColor.slice());
          element.showAll();
        }

        this.deltaColor = this.targetColor.map(function (c, index) {
          return c - startColor[index];
        });
      }

      this.startTime = -1;
    }
  }, {
    key: "finish",
    value: function finish( // eslint-disable-next-line no-use-before-define
    element) {
      var _this3 = this;

      var cancelled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var forceSetToEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var setToEnd = function setToEnd() {
        element.setColor(_this3.endColor);

        if (_this3.disolve === 'out') {
          element.hide();
        }
      };

      if (forceSetToEnd === null) {
        if (!cancelled || this.finishOnCancel) {
          setToEnd();
        }
      }

      if (forceSetToEnd === true) {
        setToEnd();
      }

      if (this.callback != null) {
        this.callback(cancelled);
      }
    }
  }]);

  return ColorAnimationPhase;
}(); // Planned Animation

var CustomAnimationPhase =
/*#__PURE__*/
function () {
  // animation time
  // Time when phase started
  function CustomAnimationPhase(animationCallback) {
    var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var startPercent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var finishOnCancel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    var animationStyle = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _tools_math__WEBPACK_IMPORTED_MODULE_1__["easeinout"];

    _classCallCheck(this, CustomAnimationPhase);

    this.time = time;
    this.startPercent = startPercent;
    this.animationCallback = animationCallback;
    this.startTime = -1;
    this.animationStyle = animationStyle;
    this.plannedStartTime = animationStyle(startPercent, true) * time;
    this.callback = callback;
    this.finishOnCancel = finishOnCancel;
  }

  _createClass(CustomAnimationPhase, [{
    key: "_dup",
    value: function _dup() {
      var c = new CustomAnimationPhase(this.animationCallback, this.time, this.startPercent, this.callback, this.finishOnCancel, this.animationStyle);
      c.startTime = this.startTime;
      return c;
    }
  }, {
    key: "start",
    value: function start() {
      // this.startColor = currentColor.slice();
      // this.deltaColor = this.targetColor.map((c, index) => c - this.startColor[index]);
      this.startTime = -1;
    }
  }, {
    key: "finish",
    value: function finish() {
      var _this4 = this;

      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var forceSetToEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var setToEnd = function setToEnd() {
        _this4.animationCallback(1);
      };

      if (forceSetToEnd === null) {
        if (!cancelled || this.finishOnCancel) {
          setToEnd();
        }
      }

      if (forceSetToEnd === true) {
        setToEnd();
      }

      if (this.callback != null) {
        this.callback(cancelled);
      }
    }
  }]);

  return CustomAnimationPhase;
}();

/***/ }),

/***/ "./src/js/diagram/Diagram.js":
/*!***********************************!*\
  !*** ./src/js/diagram/Diagram.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./webgl/GlobalAnimation */ "./src/js/diagram/webgl/GlobalAnimation.js");
/* harmony import */ var _Gesture__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Gesture */ "./src/js/diagram/Gesture.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DrawContext2D */ "./src/js/diagram/DrawContext2D.js");
/* harmony import */ var _DiagramPrimatives_DiagramPrimatives__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./DiagramPrimatives/DiagramPrimatives */ "./src/js/diagram/DiagramPrimatives/DiagramPrimatives.js");
/* harmony import */ var _DiagramEquation_DiagramEquation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./DiagramEquation/DiagramEquation */ "./src/js/diagram/DiagramEquation/DiagramEquation.js");
/* harmony import */ var _DiagramObjects_DiagramObjects__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./DiagramObjects/DiagramObjects */ "./src/js/diagram/DiagramObjects/DiagramObjects.js");
/* harmony import */ var _DiagramAddElements_addElements__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./DiagramAddElements/addElements */ "./src/js/diagram/DiagramAddElements/addElements.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

 // import getShaders from './webgl/shaders';




 // eslint-disable-next-line import/no-cycle








// There are several coordinate spaces that need to be considered for a
// diagram.
//
// In the simplest diagram, there will be in hierarchy:
//  - GL Canvas
//    - Diagram
//      - Element Collection
//        - Element Primative
//          - Drawing Object (e.g. shape, text) from primative vertices
//
// A shape is defined in Drawing Object space.
// It is then transformed by the element primative
// It is then transformed by the element colleciton
// It is then transformed by the diagram
// it is then transformed into GL Space
//
// Diagram elements can also be rendered to an image in a HTML 2D canvas
// element. To do so, pass in:
//    - Diagram Element (primative or collection) to render
//    - HTML element (which is a 2D canvas)
//    - Window of diagram to render
//    - Window scaling (how does the window fit within the HTML Element)
//      - fit: diagram units will be scaled so that diagram window limits
//             aspect ratio fits within the element aspect ratio
//      - 1em: diagram units will be scaled so 0.2 diagram units (default font
//             size) looks like 1em of the html element font size in pixels
//      - 10px: diagram units will be scaled so that the max diagram window
//              limit will be the pixel count
//      - strech: diagram units will be scaled so that the diagram window
//                limits will be stretched to fit the html element width
//                and height
// Then the process is:
//    - html element size in pixels and aspect ratio found
//    - html element size in gl coordinates found
//    - 
var Diagram =
/*#__PURE__*/
function () {
  // gestureElement: HTMLElement;
  // addElements: DiagramAddElements;
  // addElementsLow: DiagramAddElements;
  // addElementsHigh: DiagramAddElements;
  // layout: Object;
  // draw2DFigures: Object;
  // glToDiagramSpaceTransform: Transform;
  // diagramToGLSpaceTransform: Transform;
  // pixelToDiagramSpaceTransform: Transform;
  // diagramToPixelSpaceTransform: Transform;
  // pixelToGLSpaceTransform: Transform;
  // glToPixelSpaceTransform: Transform;
  // diagramToCSSPercentSpaceTransform: Transform;
  // glToDiagramSpaceScale: Point;
  // diagramToGLSpaceScale: Point;
  // pixelToDiagramSpaceScale: Point;
  // diagramToPixelSpaceScale: Point;
  // glToPixelSpaceScale: Point;
  // pixelToGLSpaceScale: Point;
  function Diagram( // canvas: HTMLCanvasElement,
  options) // limitsOrxMin: number | Rect = new Rect(-1, -1, 2, 2),
  // yMin: number = -1,
  // width: number = 2,
  // height: number = 2,
  // backgroundColor: Array<number> = [1, 1, 1, 1],
  // layout: Object = {},
  // vertexShader: string = 'simple',
  // fragmentShader: string = 'simple',
  {
    _classCallCheck(this, Diagram);

    var defaultOptions = {
      htmlId: 'id_figureone_canvases',
      limits: new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Rect"](-1, -1, 2, 2),
      backgroundColor: [1, 1, 1, 1],
      // layout: {},
      // vertexShader: 'simple',
      // fragmentShader: 'simple',
      fontScale: 1
    };
    this.scrolled = false;
    this.oldScrollY = 0;
    var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultOptions, options);
    var htmlId = optionsToUse.htmlId,
        backgroundColor = optionsToUse.backgroundColor,
        limits = optionsToUse.limits; // if (typeof containerIdOrOptions !== 'string') {
    //   optionsToUse = joinObjects(
    //     defaultOptions, containerIdOrOptions,
    //   );
    // } else {
    //   optionsToUse.htmlId = containerIdOrOptions;
    //   if (typeof limitsOrxMin === 'number') {
    //     optionsToUse.limits = new Rect(
    //       limitsOrxMin,
    //       yMin,
    //       width,
    //       height,
    //     );
    //   } else {
    //     optionsToUse.limits = limitsOrxMin;
    //   }
    //   optionsToUse.backgroundColor = backgroundColor;
    //   optionsToUse.layout = layout;
    //   optionsToUse.vertexShader = vertexShader;
    //   optionsToUse.fragmentShader = fragmentShader;
    // }
    // this.layout = layout;

    if (typeof htmlId === 'string') {
      var container = document.getElementById(htmlId);

      if (container instanceof HTMLElement) {
        var children = container.children;

        for (var i = 0; i < children.length; i += 1) {
          var child = children[i];

          if (child instanceof HTMLCanvasElement && child.classList.contains('diagram__gl')) {
            if (child.id === 'id_diagram__gl__low') {
              this.canvasLow = child;
            }

            if (child.id === 'id_diagram__gl__high') {
              this.canvasHigh = child;
            }
          }

          if (child instanceof HTMLCanvasElement && child.classList.contains('diagram__text')) {
            if (child.id === 'id_diagram__text__low') {
              this.textCanvasLow = child;
            }

            if (child.id === 'id_diagram__text__high') {
              this.textCanvasHigh = child;
            }
          }

          if (child.classList.contains('diagram__html')) {
            this.htmlCanvas = child;
          } // if (child.classList.contains('diagram__gesture')) {
          //   this.gestureElement = child;
          // }

        }

        this.backgroundColor = backgroundColor; // const shaders = getShaders(vertexShader, fragmentShader);

        var webglLow = new _webgl_webgl__WEBPACK_IMPORTED_MODULE_0__["default"](this.canvasLow, // shaders.vertexSource,
        // shaders.fragmentSource,
        // shaders.varNames,
        this.backgroundColor);
        var webglHigh = new _webgl_webgl__WEBPACK_IMPORTED_MODULE_0__["default"](this.canvasHigh, // shaders.vertexSource,
        // shaders.fragmentSource,
        // shaders.varNames,
        this.backgroundColor);
        this.webglLow = webglLow;
        this.webglHigh = webglHigh; // const draw2D = this.textCanvas.getContext('2d');

        this.draw2DLow = new _DrawContext2D__WEBPACK_IMPORTED_MODULE_6__["default"](this.textCanvasLow);
        this.draw2DHigh = new _DrawContext2D__WEBPACK_IMPORTED_MODULE_6__["default"](this.textCanvasHigh);
      }
    } // for (let i = 0; i < canvas2Ds.length; i += 1) {
    //   const canvas = canvas2Ds[i];
    //   console.log(i, canvas)
    //   if (canvas instanceof HTMLCanvasElement) {
    //     const draw2D = new DrawContext2D(canvas);
    //     const { id } = canvas;
    //     this.draw2DFigures[id] = draw2D;
    //   }
    // }


    if (optionsToUse.gestureCanvas != null) {
      var gestureCanvas = document.getElementById(optionsToUse.gestureCanvas);

      if (gestureCanvas != null) {
        this.gestureCanvas = gestureCanvas;
      }
    }

    if (this.gestureCanvas == null) {
      this.gestureCanvas = this.htmlCanvas;
    } // if (this.textCanvas instanceof HTMLCanvasElement) {
    //   this.draw2D = new DrawContext2D(this.textCanvas);
    // }


    if (this instanceof Diagram) {
      this.gesture = new _Gesture__WEBPACK_IMPORTED_MODULE_5__["default"](this);
    }

    this.fontScale = optionsToUse.fontScale; // let limits;
    // if (limitsOrxMin instanceof Rect) {
    //   const r = limitsOrxMin;
    //   limits = new Rect(r.left, r.bottom, r.width, r.height);
    // } else {
    //   limits = new Rect(limitsOrxMin, yMin, width, height);
    // }

    this.updateLimits(limits);
    this.drawQueued = false;
    this.lastDrawTime = 0;
    this.inTransition = false; // console.log(this.limits)

    this.beingMovedElements = [];
    this.beingTouchedElements = [];
    this.moveTopElementOnly = true;
    this.globalAnimation = new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_4__["default"]();
    this.shapesLow = this.getShapes(false);
    this.shapesHigh = this.getShapes(true);
    this.shapes = this.shapesLow;
    this.equationLow = this.getEquations(false);
    this.equationHigh = this.getEquations(true);
    this.equation = this.equationLow;
    this.objectsLow = this.getObjects(false);
    this.objectsHigh = this.getObjects(true);
    this.objects = this.objectsLow; // this.addElementsLow = this.getAddElements(false);
    // this.addElementsHigh = this.getAddElements(true);
    // this.addElements = this.getAddElements();

    this.createDiagramElements();

    if (this.elements.name === '') {
      this.elements.name = 'diagramRoot';
    }

    window.addEventListener('resize', this.resize.bind(this));
    this.sizeHtmlText();
    this.initialize();
    this.isTouchDevice = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["isTouchDevice"])();
    this.animateNextFrame();

    if (optionsToUse.elements) {
      // eslint-disable-next-line new-cap
      this.elements = new optionsToUse.elements(this);
      this.elements.diagramLimits = this.limits;
    }
  } // getFigureCanvases() {
  //   const canvas2Ds = document.getElementsByClassName('single_page_lesson__figure');
  //   console.log(canvas2Ds, canvas2Ds.length)
  //   this.draw2DFigures = {};
  //   // var list= document.getElementsByClassName("events");
  //   [].forEach.call(canvas2Ds, (canvas) => {
  //     console.log(canvas)
  //     if (canvas instanceof HTMLCanvasElement) {
  //       const draw2D = new DrawContext2D(canvas);
  //       const { id } = canvas;
  //       this.draw2DFigures[id] = draw2D;
  //     }
  //   });
  // }


  _createClass(Diagram, [{
    key: "addElements",
    value: function addElements(rootCollection, layout) {
      var addElementsKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'addElements';

      Object(_DiagramAddElements_addElements__WEBPACK_IMPORTED_MODULE_10__["default"])(this.shapes, this.equation, this.objects, rootCollection, layout, addElementsKey);
    }
  }, {
    key: "getShapes",
    value: function getShapes() {
      var high = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var webgl = this.webglLow;
      var draw2D = this.draw2DLow;

      if (high) {
        webgl = this.webglHigh;
        draw2D = this.draw2DHigh;
      }

      return new _DiagramPrimatives_DiagramPrimatives__WEBPACK_IMPORTED_MODULE_7__["default"](webgl, draw2D, // this.draw2DFigures,
      this.htmlCanvas, this.limits, this.spaceTransforms, this.animateNextFrame.bind(this));
    }
  }, {
    key: "getEquations",
    value: function getEquations() {
      var high = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var shapes = this.shapesLow;

      if (high) {
        shapes = this.shapesHigh;
      }

      return new _DiagramEquation_DiagramEquation__WEBPACK_IMPORTED_MODULE_8__["default"](shapes, this.animateNextFrame.bind(this));
    }
  }, {
    key: "getObjects",
    value: function getObjects() {
      var high = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var shapes = this.shapesLow;
      var equation = this.equationLow;

      if (high) {
        shapes = this.shapesHigh;
        equation = this.equationHigh;
      }

      return new _DiagramObjects_DiagramObjects__WEBPACK_IMPORTED_MODULE_9__["default"](shapes, equation, this.isTouchDevice, this.animateNextFrame.bind(this));
    } // getAddElements(high: boolean = false) {
    //   let shapes = this.shapesLow;
    //   let objects = this.objectsLow;
    //   let equation = this.equationLow;
    //   if (high) {
    //     shapes = this.shapesHigh;
    //     objects = this.objectsHigh;
    //     equation = this.equationHigh;
    //   }
    //   return new DiagramAddElements(
    //     shapes,
    //     objects,
    //     equation,
    //   );
    // }

  }, {
    key: "sizeHtmlText",
    value: function sizeHtmlText() {
      var scale = this.fontScale * 1 / 35;
      var size = this.htmlCanvas.offsetWidth * scale - 1;
      this.htmlCanvas.style.fontSize = "".concat(size, "px");
      var style = window.getComputedStyle(document.documentElement);

      if (style) {
        var prop = '--lesson__diagram-font-size';
        var docElem = document.documentElement;

        if (docElem) {
          docElem.style.setProperty(prop, "".concat(size, "px"));
        }
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.gesture.destroy();
      this.webglLow.gl.getExtension('WEBGL_lose_context').loseContext();
      this.webglHigh.gl.getExtension('WEBGL_lose_context').loseContext();
    } // setGLDiagramSpaceTransforms() {
    //   const glSpace = {
    //     x: { bottomLeft: -1, width: 2 },
    //     y: { bottomLeft: -1, height: 2 },
    //   };
    //   const diagramSpace = {
    //     x: { bottomLeft: this.limits.left, width: this.limits.width },
    //     y: { bottomLeft: this.limits.bottom, height: this.limits.height },
    //   };
    //   this.diagramToGLSpaceTransformMatrix =
    //     spaceToSpaceTransformMatrix(glSpace, diagramSpace);
    //   this.glToDiagramSpaceTransformMatrix =
    //     spaceToSpaceTransformMatrix(diagramSpace, glSpace);
    // }

  }, {
    key: "setSpaceTransforms",
    value: function setSpaceTransforms() {
      var glSpace = {
        x: {
          bottomLeft: -1,
          width: 2
        },
        y: {
          bottomLeft: -1,
          height: 2
        }
      };
      var diagramSpace = {
        x: {
          bottomLeft: this.limits.left,
          width: this.limits.width
        },
        y: {
          bottomLeft: this.limits.bottom,
          height: this.limits.height
        }
      };
      var canvasRect = this.canvasLow.getBoundingClientRect();
      var pixelSpace = {
        x: {
          bottomLeft: 0,
          width: canvasRect.width
        },
        y: {
          bottomLeft: canvasRect.height,
          height: -canvasRect.height
        }
      };
      var percentSpace = {
        x: {
          bottomLeft: 0,
          width: 1
        },
        y: {
          bottomLeft: 1,
          height: -1
        }
      };
      this.spaceTransforms = {
        diagramToGL: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(diagramSpace, glSpace, 'Diagram'),
        glToDiagram: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(glSpace, diagramSpace),
        pixelToDiagram: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(pixelSpace, diagramSpace),
        diagramToPixel: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(diagramSpace, pixelSpace),
        pixelToGL: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(pixelSpace, glSpace),
        glToPixel: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(glSpace, pixelSpace),
        diagramToCSSPercent: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(diagramSpace, percentSpace)
      };
    }
  }, {
    key: "initialize",
    value: function initialize() {
      // this.setSpaceTransforms();
      this.setFirstTransform();
    }
  }, {
    key: "setFirstTransform",
    value: function setFirstTransform() {
      this.elements.setFirstTransform(this.spaceTransforms.diagramToGL);
    }
  }, {
    key: "updateLimits",
    value: function updateLimits(limits) {
      this.limits = limits._dup();
      this.setSpaceTransforms();
    }
  }, {
    key: "renderToCanvas",
    value: function renderToCanvas(canvas, diagramWindow, sx, sy, swidth, sheight, canvasWidth, canvasHeight) {
      var glSpace = {
        x: {
          bottomLeft: -1,
          width: 2
        },
        y: {
          bottomLeft: -1,
          height: 2
        }
      };
      var windowSpace = {
        x: {
          bottomLeft: diagramWindow.left,
          width: diagramWindow.width
        },
        y: {
          bottomLeft: diagramWindow.bottom,
          height: diagramWindow.height
        }
      };
      var windowToGL = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(windowSpace, glSpace);
      this.draw(-1, windowToGL);
      var ctx = canvas.getContext('2d');
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(this.webglLow.gl.canvas, sx, sy, swidth, sheight, 0, 0, canvas.width, canvas.height);
      ctx.drawImage(this.draw2DLow.canvas, sx, sy, swidth, sheight, 0, 0, canvas.width * 2, canvas.height * 2);
      console.log(canvas.width, canvas.height);
    }
  }, {
    key: "resize",
    value: function resize() {
      if (this.elements != null) {
        this.elements.updateLimits(this.limits, this.spaceTransforms);
      }

      this.webglLow.resize();
      this.webglHigh.resize();
      this.draw2DLow.resize();
      this.draw2DHigh.resize();
      this.setSpaceTransforms();
      this.sizeHtmlText();
      this.elements.resizeHtmlObject();
      this.updateHTMLElementTie();
      this.elements.resize();
      this.animateNextFrame();
    }
  }, {
    key: "updateHTMLElementTie",
    value: function updateHTMLElementTie() {
      if (this.elements != null) {
        this.elements.updateHTMLElementTie( // this.pixelToDiagramSpaceTransform,
        // this.diagramToPixelSpaceScale,
        // this.diagramToGLSpaceTransform.m(),
        this.canvasLow);
      }
    } // Handle touch down, or mouse click events within the canvas.
    // The default behavior is to be able to move objects that are touched
    // and dragged, then when they are released, for them to move freely before
    // coming to a stop.

  }, {
    key: "touchDownHandler",
    value: function touchDownHandler(clientPoint) {
      if (this.inTransition) {
        return false;
      } // Get the touched point in clip space


      var pixelPoint = this.clientToPixel(clientPoint); // console.log(pixelPoint)

      var glPoint = pixelPoint.transformBy(this.spaceTransforms.pixelToGL.matrix()); // console.log(glPoint.transformBy(this.glToDiagramSpaceTransform.matrix()))
      // const clipPoint = this.clientToClip(clientPoint);
      // Get all the diagram elements that were touched at this point (element
      // must have isTouchable = true to be considered)

      this.beingTouchedElements = this.elements.getTouched(glPoint);

      if (this.moveTopElementOnly) {
        if (this.beingTouchedElements.length > 0) {
          this.beingTouchedElements[0].click();
        }
      } else {
        this.beingTouchedElements.forEach(function (e) {
          return e.click();
        });
      } // Make a list of, and start moving elements that are being moved
      // (element must be touched and have isMovable = true to be in list)


      this.beingMovedElements = [];

      for (var i = 0; i < this.beingTouchedElements.length; i += 1) {
        var element = this.beingTouchedElements[i];

        if (element.isMovable) {
          this.beingMovedElements.push(element);
          element.startBeingMoved();
        }
      }

      if (this.beingMovedElements.length > 0) {
        this.animateNextFrame();
      }

      if (this.beingTouchedElements.length > 0) {
        return true;
      }

      return false;
    } // Handle touch up, or mouse click up events in the canvas. When an UP even
    // happens, the default behavior is to let any elements being moved to move
    // freely until they decelerate to 0.

  }, {
    key: "touchUpHandler",
    value: function touchUpHandler() {
      // console.log("before", this.elements._circle.transform.t())
      // console.log(this.beingMovedElements)
      for (var i = 0; i < this.beingMovedElements.length; i += 1) {
        var element = this.beingMovedElements[i];

        if (element.state.isBeingMoved) {
          element.stopBeingMoved();
          element.startMovingFreely();
        }
      }

      this.beingMovedElements = [];
      this.beingTouchedElements = []; // console.log("after", this.elements._circle.transform.t())
    }
  }, {
    key: "rotateElement",
    value: function rotateElement(element, previousClientPoint, currentClientPoint) {
      var centerDiagramSpace = element.getDiagramPosition();

      if (centerDiagramSpace == null) {
        centerDiagramSpace = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);
      }

      var center = centerDiagramSpace.transformBy(this.spaceTransforms.diagramToPixel.matrix());
      var previousPixelPoint = this.clientToPixel(previousClientPoint);
      var currentPixelPoint = this.clientToPixel(currentClientPoint); // const previousDiagramPoint =
      //   previousPixelPoint.transformBy(this.pixelToDiagramSpaceTransform.matrix());
      // const currentDiagramPoint =
      //   currentPixelPoint.transformBy(this.pixelToDiagramSpaceTransform.matrix());
      // const currentAngle = Math.atan2(
      //   currentDiagramPoint.y - center.y,
      //   currentDiagramPoint.x - center.x,
      // );
      // const previousAngle = Math.atan2(
      //   previousDiagramPoint.y - center.y,
      //   previousDiagramPoint.x - center.x,
      // );

      var currentAngle = Math.atan2(currentPixelPoint.y - center.y, currentPixelPoint.x - center.x);
      var previousAngle = Math.atan2(previousPixelPoint.y - center.y, previousPixelPoint.x - center.x);
      var diffAngle = -Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["minAngleDiff"])(previousAngle, currentAngle);

      var transform = element.transform._dup();

      var rot = transform.r();

      if (rot == null) {
        rot = 0;
      }

      var newAngle = rot - diffAngle; // if (newAngle < 0) {
      //   newAngle += 2 * Math.PI;
      // }
      // if (newAngle > 2 * Math.PI) {
      //   newAngle -= 2 * Math.PI;
      // }

      transform.updateRotation(newAngle);
      element.moved(transform._dup());
    }
  }, {
    key: "translateElement",
    value: function translateElement(element, previousClientPoint, currentClientPoint) {
      var previousPixelPoint = this.clientToPixel(previousClientPoint);
      var currentPixelPoint = this.clientToPixel(currentClientPoint);
      var previousDiagramPoint = previousPixelPoint.transformBy(this.spaceTransforms.pixelToDiagram.matrix());
      var currentDiagramPoint = currentPixelPoint.transformBy(this.spaceTransforms.pixelToDiagram.matrix());
      var m = element.diagramSpaceToVertexSpaceTransformMatrix();
      var currentVertexSpacePoint = currentDiagramPoint.transformBy(m);
      var previousVertexSpacePoint = previousDiagramPoint.transformBy(m); // const delta = currentDiagramPoint.sub(previousDiagramPoint);

      var elementSpaceDelta = currentVertexSpacePoint.sub(previousVertexSpacePoint); // console.log(delta, elementSpaceDelta)

      var currentTransform = element.transform._dup();

      var currentTranslation = currentTransform.t();

      if (currentTranslation != null) {
        var newTranslation = currentTranslation.add(elementSpaceDelta);
        currentTransform.updateTranslation(newTranslation);
        element.moved(currentTransform);
      }
    }
  }, {
    key: "scaleElement",
    value: function scaleElement(element, previousClientPoint, currentClientPoint) {
      var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      var previousPixelPoint = this.clientToPixel(previousClientPoint);
      var currentPixelPoint = this.clientToPixel(currentClientPoint); // const previousDiagramPoint =
      //   previousPixelPoint.transformBy(this.pixelToDiagramSpaceTransform.matrix());
      // const currentDiagramPoint =
      //   currentPixelPoint.transformBy(this.pixelToDiagramSpaceTransform.matrix());
      // const center = element.getDiagramPosition();
      // const previousMag = previousDiagramPoint.sub(center).distance();
      // const currentMag = currentDiagramPoint.sub(center).distance();

      var center = element.getDiagramPosition().transformBy(this.spaceTransforms.diagramToPixel.matrix());
      var previousMag = previousPixelPoint.sub(center).distance();
      var currentMag = currentPixelPoint.sub(center).distance();
      var currentScale = element.transform.s();

      if (currentScale != null) {
        var currentTransform = element.transform._dup();

        var newScaleX = currentScale.x * currentMag / previousMag;
        var newScaleY = currentScale.y * currentMag / previousMag;

        if (type === 'x') {
          currentTransform.updateScale(newScaleX, 1);
        } else if (type === 'y') {
          currentTransform.updateScale(1, newScaleY);
        } else {
          currentTransform.updateScale(newScaleX, newScaleY);
        }

        element.moved(currentTransform);
      }
    } // Handle touch/mouse move events in the canvas. These events will only be
    // sent if the initial touch down happened in the canvas.
    // The default behavior is to drag (move) any objects that were touched in
    // the down event to the new location.
    // This function should return true if the move event should NOT be processed
    // by the system. For example, on a touch device, a touch and drag would
    // normally scroll the screen. Typically, you would want to move the diagram
    // element and not the screen, so a true would be returned.

  }, {
    key: "touchMoveHandler",
    value: function touchMoveHandler(previousClientPoint, currentClientPoint) {
      if (this.inTransition) {
        return false;
      }

      if (this.beingMovedElements.length === 0) {
        return false;
      }

      var previousPixelPoint = this.clientToPixel(previousClientPoint); // const currentPixelPoint = this.clientToPixel(currentClientPoint);

      var previousGLPoint = previousPixelPoint.transformBy(this.spaceTransforms.pixelToGL.matrix()); // Go through each element being moved, get the current translation

      for (var i = 0; i < this.beingMovedElements.length; i += 1) {
        var element = this.beingMovedElements[i];

        if (element !== this.elements) {
          if (element.isBeingTouched(previousGLPoint) || element.move.canBeMovedAfterLoosingTouch) {
            var elementToMove = element.move.element == null ? element : element.move.element;

            if (elementToMove.state.isBeingMoved === false) {
              elementToMove.startBeingMoved();
            }

            if (this.beingMovedElements.indexOf(elementToMove) === -1) {
              this.beingMovedElements.push(elementToMove);
            }

            if (element.move.type === 'rotation') {
              this.rotateElement(elementToMove, previousClientPoint, currentClientPoint);
            } else if (element.move.type === 'scale') {
              this.scaleElement(elementToMove, previousClientPoint, currentClientPoint);
            } else if (element.move.type === 'scaleX') {
              this.scaleElement(elementToMove, previousClientPoint, currentClientPoint, 'x');
            } else if (element.move.type === 'scaleY') {
              this.scaleElement(elementToMove, previousClientPoint, currentClientPoint, 'y');
            } else {
              this.translateElement(elementToMove, previousClientPoint, currentClientPoint);
            }
          }
        }

        if (this.moveTopElementOnly) {
          i = this.beingMovedElements.length;
        }
      }

      this.animateNextFrame();
      return true;
    }
  }, {
    key: "stop",
    value: function stop() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var forceSetToEndOfPlan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.elements.stop(cancelled, forceSetToEndOfPlan);
    } // To add elements to a diagram, either this method can be overridden,
    // or the `add` method can be used.

  }, {
    key: "createDiagramElements",
    value: function createDiagramElements() {
      // $FlowFixMe
      this.elements = new _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementCollection"]();
      this.elements.diagramLimits = this.limits;
    }
  }, {
    key: "add",
    value: function add(name, diagramElement) {
      this.elements.add(name, diagramElement);
    }
  }, {
    key: "setElementsToCollection",
    value: function setElementsToCollection(collection) {
      this.elements = collection;
      this.setFirstTransform();
    }
  }, {
    key: "clearContext",
    value: function clearContext() {
      // const bc = this.backgroundColor;
      // this.webgl.gl.clearColor(bc[0], bc[1], bc[2], bc[3]);
      this.webglLow.gl.clearColor(0, 0, 0, 0);
      this.webglLow.gl.clear(this.webglLow.gl.COLOR_BUFFER_BIT);
      this.webglHigh.gl.clearColor(0, 0, 0, 0);
      this.webglHigh.gl.clear(this.webglHigh.gl.COLOR_BUFFER_BIT); // const t = new Date().getTime();

      this.elements.clear(); // console.log('clear time', new Date().getTime() - t);
      // if (this.draw2DLow) {
      //   this.draw2DLow.ctx.clearRect(
      //     0, 0, this.draw2DLow.ctx.canvas.width,
      //     this.draw2DLow.ctx.canvas.height,
      //   );
      // }
      // if (this.draw2DHigh) {
      //   this.draw2DHigh.ctx.clearRect(
      //     0, 0, this.draw2DHigh.ctx.canvas.width,
      //     this.draw2DHigh.ctx.canvas.height,
      //   );
      // }
    }
  }, {
    key: "draw",
    value: function draw(now) {
      var diagramTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.spaceTransforms.diagramToGL;

      if (now === -1) {
        now = this.lastDrawTime;
      } else {
        this.lastDrawTime = now;
      } // if (this.globalAnimation.previousNow == null) {
      //   this.globalAnimation.previousNow = now
      // }
      // console.log(this.scrolled)
      // if (this.webglLow.gl.canvas.style.display === 'none') {
      //   this.webglLow.gl.canvas.style.display = 'block';
      //   this.draw2DLow.canvas.style.display = 'block';
      //   this.resize();
      //   console.log('unhide')
      // }


      if (this.scrolled) {
        if (Math.abs(window.pageYOffset - this.oldScrollY) > this.webglLow.gl.canvas.clientHeight / 8) {
          var viewPortHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
          var newTop = window.pageYOffset + viewPortHeight / 2 - this.webglLow.gl.canvas.clientHeight / 2; // console.log('viewport', viewPortHeight)
          // console.log('gl canvas height', this.webglLow.gl.canvas.clientHeight)
          // console.log('old scroll', this.oldScrollY)
          // console.log('gl canvas position', this.webglLow.gl.canvas.getBoundingClientRect().top)
          // console.log('pageY Offset', window.pageYOffset)
          // console.log(newTop), window.pageYOffset, viewPortHeight, this.webglLow.gl.canvas.clientHeight)

          if (newTop < 0) {
            newTop = 0;
          }

          var oldTop = this.webglLow.gl.canvas.style.top;
          this.newTop = "".concat(newTop, "px"); // this.webglLow.gl.canvas.style.opacity = '0';
          // this.draw2DLow.canvas.style.opacity = '0';
          // this.clearContext();

          this.webglLow.gl.canvas.style.top = "".concat(newTop, "px");
          this.draw2DLow.canvas.style.top = "".concat(newTop, "px");
          this.resize(); // this.webglLow.gl.canvas.style.top = oldTop;
          // this.draw2DLow.canvas.style.top = oldTop;
          // this.webglLow.gl.canvas.style.opacity = '1';

          this.oldScrollY = window.pageYOffset;
          this.drawQueued = true;
          this.changeTop = 1; // console.log('hide4')
        } // this.resize();
        // console.log(this.webgl)


        this.scrolled = false;
      }

      if (this.drawQueued === false) {
        return;
      } // const t = new Date().getTime();
      // console.log('time since last draw:', t - this.globalAnimation.diagramDrawStart)
      // this.globalAnimation.diagramDrawStart = t;


      this.drawQueued = false;
      this.clearContext(); // console.log(now - this.globalAnimation.previousNow)
      // This transform converts standard gl clip space, to diagram clip space
      // defined in limits.
      // const normWidth = 2 / this.limits.width;
      // const normHeight = 2 / this.limits.height;
      // const clipTransform = new Transform()
      //   .scale(normWidth, normHeight)
      //   .translate(
      //     (-this.limits.width / 2 - this.limits.left) * normWidth,
      //     (this.limits.height / 2 - this.limits.top) * normHeight,
      //   );
      // const t1 = performance.now();

      this.elements.draw(diagramTransform, now);

      if (this.elements.isMoving()) {
        this.animateNextFrame();
      }

      if (this.changeTop > 1) {
        this.changeTop -= 1;
      } else if (this.changeTop === 1) {
        // this.webglLow.gl.canvas.style.opacity = '1';
        // this.draw2DLow.canvas.style.opacity = '1';
        // this.webglLow.gl.canvas.style.top = `${this.newTop}px`;
        // this.draw2DLow.canvas.style.top = `${this.newTop}px`;
        // console.log('show4')
        this.changeTop = 0;
      } // console.log('draw end', new Date().getTime() - this.globalAnimation.diagramDrawStart);

    }
  }, {
    key: "animateNextFrame",
    value: function animateNextFrame() {
      var draw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (!this.drawQueued) {
        if (draw) {
          this.drawQueued = true;
        }

        this.globalAnimation.queueNextFrame(this.draw.bind(this));
      }
    }
  }, {
    key: "isAnimating",
    value: function isAnimating() {
      return this.elements.state.isAnimating;
    }
  }, {
    key: "clientToPixel",
    value: function clientToPixel(clientLocation) {
      var canvas = this.canvasLow.getBoundingClientRect();
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](clientLocation.x - canvas.left, clientLocation.y - canvas.top);
    }
  }]);

  return Diagram;
}();

/* harmony default export */ __webpack_exports__["default"] = (Diagram);

/***/ }),

/***/ "./src/js/diagram/DiagramAddElements/addElements.js":
/*!**********************************************************!*\
  !*** ./src/js/diagram/DiagramAddElements/addElements.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _DiagramPrimatives_DiagramPrimatives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DiagramPrimatives/DiagramPrimatives */ "./src/js/diagram/DiagramPrimatives/DiagramPrimatives.js");
/* harmony import */ var _DiagramObjects_DiagramObjects__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DiagramObjects/DiagramObjects */ "./src/js/diagram/DiagramObjects/DiagramObjects.js");
/* harmony import */ var _DiagramEquation_DiagramEquation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DiagramEquation/DiagramEquation */ "./src/js/diagram/DiagramEquation/DiagramEquation.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






function addElements(shapes, equation, objects, rootCollection, layout, addElementsKey) {
  var getPath = function getPath(e, remainingPath) {
    if (!(remainingPath[0] in e)) {
      return null;
    }

    if (remainingPath.length === 1) {
      // $FlowFixMe
      return e[remainingPath[0]];
    } // $FlowFixMe


    return getPath(e[remainingPath[0]], remainingPath.slice(1));
  };

  var getMethod = function getMethod(method) {
    var methods = {
      collection: shapes.collection.bind(shapes),
      polyLine: shapes.polyLine.bind(shapes),
      polygon: shapes.polygon.bind(shapes),
      arrow: shapes.arrow.bind(shapes),
      text: shapes.txt.bind(shapes),
      textGL: shapes.textGL.bind(shapes),
      //
      line: objects.line.bind(objects),
      angle: objects.angle.bind(objects),
      //
      addEquation: equation.addEquation.bind(equation),
      addNavigator: equation.addNavigator.bind(equation)
    };

    if (method in methods) {
      return methods[method];
    }

    var diagram = {
      shapes: shapes,
      objects: objects,
      equation: equation
    };
    var splitMethod = method.split('/');
    var methodToUse = getPath(diagram, splitMethod);

    if (methodToUse == null) {
      // throw new Error(`Diagram addElements ERROR: Cannot find method ${method}`);
      return null;
    }

    methodToUse = methodToUse.bind(getPath(diagram, splitMethod.slice(0, -1)));
    return methodToUse;
  };

  if (Array.isArray(layout)) {
    layout.forEach(function (elementDefinition, index) {
      var methodPathToUse;
      var nameToUse;
      var pathToUse;
      var optionsToUse;
      var elementModsToUse;
      var addElementsToUse;
      var firstScenario; // Extract the parameters from the layout object

      if (Array.isArray(elementDefinition)) {
        var _elementDefinition = _slicedToArray(elementDefinition, 7);

        pathToUse = _elementDefinition[0];
        nameToUse = _elementDefinition[1];
        methodPathToUse = _elementDefinition[2];
        optionsToUse = _elementDefinition[3];
        elementModsToUse = _elementDefinition[4];
        addElementsToUse = _elementDefinition[5];
        firstScenario = _elementDefinition[6];
      } else {
        nameToUse = elementDefinition.name;
        pathToUse = elementDefinition.path;
        optionsToUse = elementDefinition.options;
        addElementsToUse = elementDefinition[addElementsKey];
        methodPathToUse = elementDefinition.method;
        elementModsToUse = elementDefinition.mods;
        firstScenario = elementDefinition.scenario;
      }

      var collectionPath;

      if (pathToUse == null || pathToUse === '') {
        collectionPath = rootCollection;
      } else {
        var path = pathToUse.split('/');
        collectionPath = getPath(rootCollection, path);
      } // Check for critical errors


      if (nameToUse == null || nameToUse === '') {
        throw new Error("Diagram addElement ERROR  at index ".concat(index, " in collection ").concat(rootCollection.name, ": missing name property"));
      }

      if (methodPathToUse == null || methodPathToUse === '') {
        throw new Error("Diagram addElement ERROR  at index ".concat(index, " in collection ").concat(rootCollection.name, ": missing method property"));
      }

      if (!(collectionPath instanceof _Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElementCollection"])) {
        throw new Error("Diagram addElement ERROR at index ".concat(index, " in collection ").concat(rootCollection.name, ": missing or incorrect path property"));
      }

      var methodPath = methodPathToUse.split('/');
      var method = getMethod(methodPathToUse);

      if (typeof method !== 'function') {
        return;
      }

      if (typeof method !== 'function') {
        throw new Error("Layout addElement at index ".concat(index, " in collection ").concat(rootCollection.name, ": incorrect method property"));
      }

      if (methodPath.slice(-1)[0].startsWith('add')) {
        var element = method(collectionPath, nameToUse, optionsToUse);

        if (elementModsToUse != null && elementModsToUse !== {}) {
          element.setProperties(elementModsToUse);
        }

        if (firstScenario != null && firstScenario in element.scenarios) {
          element.setScenario(firstScenario);
        }
      } else {
        var _element;

        if (Array.isArray(optionsToUse)) {
          _element = method.apply(void 0, _toConsumableArray(optionsToUse));
        } else {
          _element = method(optionsToUse);
        }

        if (_element == null) {
          return;
        }

        if (elementModsToUse != null && elementModsToUse !== {}) {
          _element.setProperties(elementModsToUse);
        }

        if (collectionPath instanceof _Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElementCollection"]) {
          collectionPath.add(nameToUse, _element);
        }

        if (firstScenario != null && firstScenario in _element.scenarios) {
          _element.setScenario(firstScenario);
        }
      }

      if ("_".concat(nameToUse) in rootCollection && addElementsToUse != null && addElementsToUse !== {}) {
        addElements(shapes, equation, objects, // $FlowFixMe
        rootCollection["_".concat(nameToUse)], addElementsToUse, addElementsKey);
      }
    });
  }
}

/* harmony default export */ __webpack_exports__["default"] = (addElements);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Arrow.js":
/*!*************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Arrow.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Arrow; });
/* harmony import */ var _DrawingObjects_VertexObject_VertexArrow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexArrow */ "./src/js/diagram/DrawingObjects/VertexObject/VertexArrow.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");




function Arrow(webgl) {
  var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var legWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
  var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var legHeight = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
  var tip = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](0, 0);
  var rotation = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  var color = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [1, 1, 1, 1];
  var transformOrLocation = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](0, 0);
  var diagramLimits = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Rect"](-1, -1, 2, 2);
  var vertexLine = new _DrawingObjects_VertexObject_VertexArrow__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, width, legWidth, height, legHeight, tip, rotation);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"](vertexLine, transform, color, diagramLimits);
}

/***/ }),

/***/ "./src/js/diagram/DiagramElements/DashedLine.js":
/*!******************************************************!*\
  !*** ./src/js/diagram/DiagramElements/DashedLine.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawingObjects_VertexObject_VertexDashedLine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexDashedLine */ "./src/js/diagram/DrawingObjects/VertexObject/VertexDashedLine.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");





function DashedLine(webgl, start, length, width, rotation, dashStyle, color, transformOrLocation, diagramLimits) {
  var vertexLine = new _DrawingObjects_VertexObject_VertexDashedLine__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, start, length, width, rotation, dashStyle);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"](vertexLine, transform, color, diagramLimits);
}

/* harmony default export */ __webpack_exports__["default"] = (DashedLine);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Elements/Annotation.js":
/*!************************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Elements/Annotation.js ***!
  \************************************************************************/
/*! exports provided: AnnotationInformation, Annotation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationInformation", function() { return AnnotationInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Annotation", function() { return Annotation; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Element */ "./src/js/diagram/DiagramElements/Equation/Elements/Element.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }




var AnnotationInformation = function AnnotationInformation(content) {
  var xPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'right';
  var yPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'top';
  var xAlign = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'left';
  var yAlign = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'bottom';
  var annotationScale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.5;

  _classCallCheck(this, AnnotationInformation);

  this.content = content;
  this.xPosition = xPosition == null ? 'right' : xPosition;
  this.yPosition = yPosition == null ? 'top' : yPosition;
  this.xAlign = xAlign == null ? 'left' : xAlign;
  this.yAlign = yAlign == null ? 'bottom' : yAlign;
  this.annotationScale = annotationScale == null ? 0.5 : annotationScale;
}; // Create an annotation to a set of Elements
// x/yPosition: annotation location relative to mainContent
// x/yAlign: annotation alignment relative to its location
// Position and Align can be words or numbers where:
//    left: 0
//    right: 1
//    center: 0.5
//    bottom: 0
//    top: 1
//    middle: 0.5
//    baseline: descent / height
//    numbers can be anything (not just between 0 and 1)
//      For example, xPosition of -1 would position the annotation
//      one mainContent width to the left of the mainContent left point

var Annotation =
/*#__PURE__*/
function (_Elements) {
  _inherits(Annotation, _Elements);

  function Annotation(mainContent, annotationOrAnnotationArray) {
    var _this;

    var xPositionOrAnnotationInSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'right';
    var yPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'top';
    var xAlign = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'left';
    var yAlign = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'bottom';
    var annotationScale = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0.5;
    var annotationInSize = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;

    _classCallCheck(this, Annotation);

    if (Array.isArray(annotationOrAnnotationArray)) {
      var annotationElements = [mainContent];
      annotationOrAnnotationArray.forEach(function (annotationInfo) {
        annotationElements.push(annotationInfo.content);
      });
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Annotation).call(this, annotationElements));
    } else {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Annotation).call(this, [mainContent, annotationOrAnnotationArray]));
    } // super([mainContent, annotation]);


    _this.mainContent = mainContent;
    _this.annotations = [];

    if (Array.isArray(annotationOrAnnotationArray)) {
      _this.annotations = annotationOrAnnotationArray;

      if (typeof xPositionOrAnnotationInSize === 'boolean') {
        _this.annotationInSize = xPositionOrAnnotationInSize;
      } else {
        _this.annotationInSize = false;
      }
    } else {
      var xPosition = 'right';

      if (typeof xPositionOrAnnotationInSize !== 'boolean') {
        xPosition = xPositionOrAnnotationInSize;
      }

      _this.annotations = [new AnnotationInformation(annotationOrAnnotationArray, xPosition, yPosition, xAlign, yAlign, annotationScale)];
      _this.annotationInSize = annotationInSize;
    }

    return _possibleConstructorReturn(_this);
  }

  _createClass(Annotation, [{
    key: "_dup",
    value: function _dup(namedCollection) {
      // const annotationsCopy = [];
      var annotationsCopy = this.annotations.map(function (annotationInfo) {
        return new AnnotationInformation(annotationInfo.content._dup(namedCollection), annotationInfo.xPosition, annotationInfo.yPosition, annotationInfo.xAlign, annotationInfo.yAlign, annotationInfo.annotationScale);
      });
      var annotationCopy = new Annotation(this.mainContent._dup(namedCollection), annotationsCopy, this.annotationInSize);
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, annotationCopy, ['mainContent', 'annotations']);
      return annotationCopy;
    }
  }, {
    key: "calcSize",
    value: function calcSize(location, incomingScale) {
      var _this2 = this;

      this.location = location._dup();
      this.mainContent.calcSize(location, incomingScale);
      var minX = this.mainContent.location.x;
      var minY = this.mainContent.location.y - this.mainContent.descent;
      var maxX = this.mainContent.location.x + this.mainContent.width;
      var maxY = this.mainContent.location.y + this.mainContent.ascent;
      this.annotations.forEach(function (annotationInfo) {
        var annotation = annotationInfo.content;
        var xPosition = annotationInfo.xPosition,
            yPosition = annotationInfo.yPosition,
            xAlign = annotationInfo.xAlign,
            yAlign = annotationInfo.yAlign,
            annotationScale = annotationInfo.annotationScale;
        annotation.calcSize(location, incomingScale * annotationScale);

        var annotationLoc = _this2.location._dup();

        var xPos = 0;
        var yPos = _this2.mainContent.descent / _this2.mainContent.height;

        if (xPosition === 'right') {
          xPos = 1;
        } else if (xPosition === 'center') {
          xPos = 0.5;
        } else if (typeof xPosition === 'number') {
          xPos = xPosition;
        }

        annotationLoc.x += _this2.mainContent.width * xPos;

        if (yPosition === 'bottom') {
          yPos = 0;
        } else if (yPosition === 'top') {
          yPos = 1;
        } else if (yPosition === 'middle') {
          yPos = 0.5;
        } else if (typeof yPosition === 'number') {
          yPos = yPosition;
        }

        annotationLoc.y += -_this2.mainContent.descent + _this2.mainContent.height * yPos;
        var xOffset = 0;
        var yOffset = annotation.descent / annotation.height;

        if (xAlign === 'right') {
          xOffset = 1;
        } else if (xAlign === 'center') {
          xOffset = 0.5;
        } else if (typeof xAlign === 'number') {
          xOffset = xAlign;
        }

        if (yAlign === 'bottom') {
          yOffset = 0;
        } else if (yAlign === 'top') {
          yOffset = 1;
        } else if (yAlign === 'middle') {
          yOffset = 0.5;
        } else if (typeof yAlign === 'number') {
          yOffset = yAlign;
        }

        var annotationOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-xOffset * annotation.width, annotation.descent - yOffset * annotation.height);
        annotation.calcSize(annotationLoc, incomingScale * annotationScale);
        annotation.offsetLocation(annotationOffset);
        var annotationMaxX = annotation.location.x + annotation.width;
        var annotationMaxY = annotation.location.y + annotation.ascent;
        var annotationMinX = annotation.location.x;
        var annotationMinY = annotation.location.y - annotation.descent;
        maxX = annotationMaxX > maxX ? annotationMaxX : maxX;
        maxY = annotationMaxY > maxY ? annotationMaxY : maxY;
        minX = annotationMinX < minX ? annotationMinX : minX;
        minY = annotationMinY < minY ? annotationMinY : minY;
      });

      if (this.annotationInSize) {
        var bottomLeft = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](minX, minY);
        var topRight = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](maxX, maxY);
        this.width = topRight.x - bottomLeft.x;
        this.ascent = topRight.y - this.mainContent.location.y;
        this.descent = this.mainContent.location.y - bottomLeft.y;
        var xOffset = this.mainContent.location.x - bottomLeft.x;

        if (xOffset) {
          this.mainContent.offsetLocation(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](xOffset, 0));
          this.annotations.forEach(function (annotationInfo) {
            return annotationInfo.content.offsetLocation(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](xOffset, 0));
          });
        }
      } else {
        this.width = this.mainContent.width;
        this.ascent = this.mainContent.ascent;
        this.descent = this.mainContent.descent;
      }

      this.height = this.descent + this.ascent;
    }
  }, {
    key: "getAllElements",
    value: function getAllElements() {
      var elements = [];

      if (this.mainContent) {
        elements = [].concat(_toConsumableArray(elements), _toConsumableArray(this.mainContent.getAllElements()));
      }

      this.annotations.forEach(function (annotationInfo) {
        elements = [].concat(_toConsumableArray(elements), _toConsumableArray(annotationInfo.content.getAllElements()));
      });
      return elements;
    }
  }, {
    key: "setPositions",
    value: function setPositions() {
      this.mainContent.setPositions();
      this.annotations.forEach(function (annotationInfo) {
        annotationInfo.content.setPositions();
      }); // this.annotation.setPositions();
    }
  }, {
    key: "offsetLocation",
    value: function offsetLocation() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.location = this.location.add(offset);
      this.mainContent.offsetLocation(offset);
      this.annotations.forEach(function (annotationInfo) {
        annotationInfo.content.offsetLocation(offset);
      }); // this.annotation.offsetLocation(offset);
    }
  }]);

  return Annotation;
}(_Element__WEBPACK_IMPORTED_MODULE_2__["Elements"]);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Elements/Bounds.js":
/*!********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Elements/Bounds.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Bounds; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Bounds = function Bounds() {
  _classCallCheck(this, Bounds);

  this.width = 0;
  this.height = 0;
  this.ascent = 0;
  this.descent = 0;
};



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Elements/Brackets.js":
/*!**********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Elements/Brackets.js ***!
  \**********************************************************************/
/*! exports provided: Brackets, Bar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Brackets", function() { return Brackets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bar", function() { return Bar; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Element */ "./src/js/diagram/DiagramElements/Equation/Elements/Element.js");
/* harmony import */ var _Bounds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Bounds */ "./src/js/diagram/DiagramElements/Equation/Elements/Bounds.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






var Brackets =
/*#__PURE__*/
function (_Elements) {
  _inherits(Brackets, _Elements);

  function Brackets(content, glyph, rightGlyph) {
    var _this;

    var insideSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.03;
    var outsideSpace = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.05;
    var minLineHeight = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var heightScale = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1.2;

    _classCallCheck(this, Brackets);

    var left = glyph !== null ? new _Element__WEBPACK_IMPORTED_MODULE_3__["Element"](glyph) : null;
    var right = rightGlyph !== null ? new _Element__WEBPACK_IMPORTED_MODULE_3__["Element"](rightGlyph) : null;
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Brackets).call(this, [left, content, right]));
    _this.glyph = glyph;
    _this.rightGlyph = rightGlyph;
    _this.mainContent = content;
    _this.glyphLocation = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    _this.rightGlyphLocation = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    _this.glyphScale = 1;
    _this.insideSpace = insideSpace;
    _this.outsideSpace = outsideSpace;
    _this.minLineHeight = minLineHeight;
    _this.heightScale = heightScale;
    return _this;
  }

  _createClass(Brackets, [{
    key: "_dup",
    value: function _dup(namedCollection) {
      var content = this.mainContent == null ? null : this.mainContent._dup(namedCollection);
      var lglyph = this.glyph;

      if (this.glyph != null && namedCollection) {
        lglyph = namedCollection[this.glyph.name];
      }

      var rglyph = this.rightGlyph;

      if (this.rightGlyph != null && namedCollection) {
        rglyph = namedCollection[this.rightGlyph.name];
      }

      var bracketCopy = new Brackets(content, lglyph, rglyph, this.insideSpace, this.outsideSpace);
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicateFromTo"])(this, bracketCopy, ['content', 'glyph', 'rightGlyph']); // console.log(this.glyph.getPosition()._dup(), this.rightGlyph.getPosition()._dup());

      return bracketCopy;
    }
  }, {
    key: "getAllElements",
    value: function getAllElements() {
      var elements = [];

      if (this.mainContent) {
        elements = [].concat(_toConsumableArray(elements), _toConsumableArray(this.mainContent.getAllElements()));
      }

      if (this.glyph) {
        elements = [].concat(_toConsumableArray(elements), [this.glyph]);
      }

      if (this.rightGlyph) {
        elements = [].concat(_toConsumableArray(elements), [this.rightGlyph]);
      } // console.log(this.glyph.getPosition()._dup(), this.rightGlyph.getPosition()._dup());


      return elements;
    }
  }, {
    key: "setPositions",
    value: function setPositions() {
      var glyph = this.glyph,
          rightGlyph = this.rightGlyph;

      if (glyph != null) {
        glyph.transform.updateScale(this.glyphScale, this.glyphScale);
        glyph.transform.updateTranslation(this.glyphLocation.x, this.glyphLocation.y);
      }

      if (rightGlyph != null) {
        rightGlyph.transform.updateScale(this.glyphScale, this.glyphScale);
        rightGlyph.transform.updateTranslation(this.rightGlyphLocation.x, this.rightGlyphLocation.y);
      }

      if (this.mainContent) {
        this.mainContent.setPositions();
      }
    }
  }, {
    key: "offsetLocation",
    value: function offsetLocation() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.location = this.location.add(offset);
      var glyph = this.glyph,
          rightGlyph = this.rightGlyph;

      if (glyph != null) {
        this.glyphLocation = this.glyphLocation.add(offset);
      }

      if (rightGlyph != null) {
        this.rightGlyphLocation = this.rightGlyphLocation.add(offset);
      }

      if (this.mainContent) {
        this.mainContent.offsetLocation(offset);
      } // console.log(this.glyph.getPosition()._dup(), this.rightGlyph.getPosition()._dup());

    }
  }, {
    key: "calcSize",
    value: function calcSize(location, scale) {
      this.location = location._dup();

      var loc = location._dup();

      var contentBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_4__["default"]();
      var glyphBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_4__["default"]();
      var rightGlyphBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_4__["default"]();
      var mainContent = this.mainContent;

      if (mainContent instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["Elements"]) {
        mainContent.calcSize(loc._dup(), scale);
        contentBounds.width = mainContent.width;
        contentBounds.height = mainContent.ascent + mainContent.descent;
        contentBounds.ascent = mainContent.ascent;
        contentBounds.descent = mainContent.descent;
      }

      var lineHeight = this.minLineHeight;

      if (lineHeight != null) {
        lineHeight.calcSize(loc._dup(), scale);
        contentBounds.height = Math.max(lineHeight.height, contentBounds.height);
        contentBounds.descent = Math.max(lineHeight.descent, contentBounds.descent);
      }

      var heightScale = this.heightScale;
      var height = contentBounds.height * heightScale;
      var bracketScale = height;
      var glyphDescent = contentBounds.descent + contentBounds.height * (heightScale - 1) / 2;
      var leftSymbolLocation = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](loc.x + this.outsideSpace * scale, loc.y - glyphDescent);
      var glyph = this.glyph;

      if (glyph instanceof _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"]) {
        glyph.show();
        glyph.transform.updateScale(bracketScale, bracketScale);
        glyph.transform.updateTranslation(leftSymbolLocation.x, leftSymbolLocation.y);
        this.glyphLocation = leftSymbolLocation;
        this.glyphScale = bracketScale;
        var bounds = glyph.drawingObject.getRelativeVertexSpaceBoundingRect();
        glyphBounds.width = bounds.width * bracketScale;
        glyphBounds.height = (-bounds.bottom + bounds.top) * bracketScale;
        glyphBounds.ascent = bounds.top * bracketScale;
        glyphBounds.descent = -bounds.bottom * bracketScale;
      }

      var rightSymbolLocation = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](loc.x + contentBounds.width + glyphBounds.width + (this.insideSpace * 2 + this.outsideSpace) * scale, leftSymbolLocation.y);
      var rightGlyph = this.rightGlyph;

      if (rightGlyph instanceof _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"]) {
        rightGlyph.show();
        rightGlyph.transform.updateScale(bracketScale, bracketScale);
        rightGlyph.transform.updateTranslation(rightSymbolLocation.x, rightSymbolLocation.y);
        this.rightGlyphLocation = rightSymbolLocation;

        var _bounds = rightGlyph.drawingObject.getRelativeVertexSpaceBoundingRect();

        rightGlyphBounds.width = _bounds.width * bracketScale;
        rightGlyphBounds.height = (-_bounds.bottom + _bounds.top) * bracketScale;
        rightGlyphBounds.ascent = _bounds.top * bracketScale;
        rightGlyphBounds.descent = -_bounds.bottom * bracketScale;
      }

      var contentLocation = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.location.x + glyphBounds.width + (this.insideSpace + this.outsideSpace) * scale, this.location.y);

      if (mainContent instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["Elements"]) {
        mainContent.offsetLocation(contentLocation.sub(mainContent.location));
      }

      this.width = glyphBounds.width + contentBounds.width + rightGlyphBounds.width + this.insideSpace * scale * 2 + this.outsideSpace * scale * 2;
      this.ascent = glyphBounds.height - glyphDescent;
      this.descent = glyphDescent;
      this.height = this.descent + this.ascent; // console.log(this.glyphLocation, this.rightGlyphLocation)
      // console.log(this.glyph.getPosition()._dup(), this.rightGlyph.getPosition()._dup());
    }
  }]);

  return Brackets;
}(_Element__WEBPACK_IMPORTED_MODULE_3__["Elements"]);
var Bar =
/*#__PURE__*/
function (_Brackets) {
  _inherits(Bar, _Brackets);

  // outsideSpace: number;
  function Bar(content, barGlyph) {
    var _this2;

    var space = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.03;
    var outsideSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.03;
    var barPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'top';

    _classCallCheck(this, Bar);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Bar).call(this, content, barGlyph, null, space, outsideSpace));
    _this2.barPosition = barPosition; // this.outsideSpace = outsideSpace;

    return _this2;
  }

  _createClass(Bar, [{
    key: "calcSize",
    value: function calcSize(location, scale) {
      this.location = location._dup();

      var loc = location._dup();

      var contentBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_4__["default"]();
      var glyphBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_4__["default"]();
      var mainContent = this.mainContent;

      if (mainContent instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["Elements"]) {
        mainContent.calcSize(loc._dup(), scale);
        contentBounds.width = mainContent.width;
        contentBounds.height = mainContent.ascent + mainContent.descent;
        contentBounds.ascent = mainContent.ascent;
        contentBounds.descent = mainContent.descent;
      }

      var widthScale = 1;
      var width = contentBounds.width * widthScale;
      var bracketScale = width;
      var leftSymbolLocation = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](loc.x - (widthScale - 1) * width / 2, loc.y + contentBounds.ascent + this.insideSpace * scale);

      if (this.barPosition === 'bottom') {
        leftSymbolLocation.y = loc.y - contentBounds.descent - this.insideSpace * scale;
      }

      var glyph = this.glyph;

      if (glyph instanceof _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"]) {
        glyph.show();
        glyph.transform.updateScale(bracketScale, bracketScale);
        glyph.transform.updateTranslation(leftSymbolLocation.x, leftSymbolLocation.y);
        this.glyphLocation = leftSymbolLocation;
        this.glyphScale = bracketScale;
        var bounds = glyph.drawingObject.getRelativeVertexSpaceBoundingRect();
        glyphBounds.width = bounds.width * bracketScale;
        glyphBounds.height = (-bounds.bottom + bounds.top) * bracketScale;
        glyphBounds.ascent = bounds.top * bracketScale;
        glyphBounds.descent = -bounds.bottom * bracketScale;
      }

      this.width = contentBounds.width;

      if (this.barPosition === 'top') {
        this.ascent = contentBounds.ascent + glyphBounds.height + this.insideSpace * scale + this.outsideSpace * scale;
        this.descent = contentBounds.descent;
      } else {
        this.ascent = contentBounds.ascent;
        this.descent = contentBounds.descent + glyphBounds.height + this.insideSpace * scale + this.outsideSpace * scale;
      }

      this.height = this.descent + this.ascent;
    } // Must make a dup method in a subclass or else the parent class will
    // create a new copy of its own class type

  }, {
    key: "_dup",
    value: function _dup(namedCollection) {
      var content = this.mainContent == null ? null : this.mainContent._dup(namedCollection);
      var glyph = this.glyph;

      if (this.glyph != null && namedCollection) {
        glyph = namedCollection[this.glyph.name];
      }

      var barCopy = new Bar(content, glyph, this.insideSpace, this.outsideSpace, this.barPosition);
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicateFromTo"])(this, barCopy, ['content', 'glyph']);
      return barCopy;
    }
  }]);

  return Bar;
}(Brackets);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Elements/Element.js":
/*!*********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Elements/Element.js ***!
  \*********************************************************************/
/*! exports provided: BlankElement, Element, Elements */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlankElement", function() { return BlankElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Element", function() { return Element; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Elements", function() { return Elements; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Element */ "./src/js/diagram/Element.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



 // Equation is a class that takes a set of drawing objects (TextObjects,
// DiagramElementPrimatives or DiagramElementCollections and HTML Objects
// and arranges their size in a )

var BlankElement =
/*#__PURE__*/
function () {
  function BlankElement() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.03;
    var ascent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var descent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, BlankElement);

    this.width = width;
    this.ascent = ascent;
    this.descent = descent;
    this.height = this.ascent + this.descent;
  }

  _createClass(BlankElement, [{
    key: "_dup",
    value: function _dup() {
      return new BlankElement(this.width, this.ascent, this.descent);
    }
  }]);

  return BlankElement;
}();

var Element =
/*#__PURE__*/
function () {
  function Element(content) {
    _classCallCheck(this, Element);

    this.content = content;
    this.ascent = 0;
    this.descent = 0;
    this.width = 0;
    this.location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    this.height = 0;
  }

  _createClass(Element, [{
    key: "calcSize",
    value: function calcSize(location, scale) {
      var content = this.content;

      if (content instanceof BlankElement) {
        this.width = content.width * scale;
        this.height = content.height * scale;
        this.ascent = content.ascent * scale;
        this.descent = content.descent * scale;
        this.location = location._dup();
        this.scale = scale;
      }

      if (content instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"] || content instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementPrimative"]) {
        // Update translation and scale
        content.transform.updateTranslation(location.x, location.y);
        content.transform.updateScale(scale, scale);
        content.updateLastDrawTransform(); // Get the boundaries of element
        // const t = content.lastDrawTransform._dup();
        // content.lastDrawTransform = content.transform._dup();

        var r = content.getRelativeVertexSpaceBoundingRect(); // content.lastDrawTransform = t;

        this.location = location._dup();
        this.scale = scale;
        this.ascent = r.top * scale;
        this.descent = -r.bottom * scale;
        this.height = r.height * scale;
        this.width = r.width * scale; // console.log(this.height)
      }
    }
  }, {
    key: "_dup",
    value: function _dup(namedCollection) {
      var c;

      if (this.content instanceof BlankElement) {
        c = new Element(this.content);
      } else if (namedCollection) {
        c = new Element(namedCollection[this.content.name]);
      } else {
        c = new Element(this.content);
      }

      c.ascent = this.ascent;
      c.descent = this.descent;
      c.width = this.width;
      c.location = this.location._dup();
      c.height = this.height;
      c.scale = this.scale;
      return c;
    }
  }, {
    key: "getAllElements",
    value: function getAllElements() {
      if (this.content instanceof BlankElement) {
        return [];
      }

      return [this.content];
    }
  }, {
    key: "setPositions",
    value: function setPositions() {
      var content = this.content;

      if (content instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"] || content instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementPrimative"]) {
        content.transform.updateTranslation(this.location.x, this.location.y);
        content.transform.updateScale(this.scale, this.scale);
        content.updateLastDrawTransform();
      }
    }
  }, {
    key: "offsetLocation",
    value: function offsetLocation() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.location = this.location.add(offset);
    }
  }]);

  return Element;
}();

var Elements =
/*#__PURE__*/
function () {
  function Elements(content) {
    _classCallCheck(this, Elements);

    var nonNullContent = [];
    content.forEach(function (c) {
      if (c !== null) {
        nonNullContent.push(c);
      }
    });
    this.content = nonNullContent;
    this.ascent = 0;
    this.descent = 0;
    this.width = 0;
    this.location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    this.height = 0;
  }

  _createClass(Elements, [{
    key: "_dup",
    value: function _dup(namedCollection) {
      var contentCopy = []; // console.log("Asdf", this.content, namedCollection)

      this.content.forEach(function (element) {
        return contentCopy.push(element._dup(namedCollection));
      });
      var c = new Elements(contentCopy);
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, c, ['content']);
      return c;
    }
  }, {
    key: "calcSize",
    value: function calcSize(location, scale) {
      var des = 0;
      var asc = 0;

      var loc = location._dup();

      this.content.forEach(function (element) {
        element.calcSize(loc, scale);
        loc.x += element.width;

        if (element.descent > des) {
          des = element.descent;
        }

        if (element.ascent > asc) {
          asc = element.ascent;
        }
      }); // if (this.content.length === 4 && this.content[0] instanceof Fraction) {
      //   console.log(this.content)
      //   console.log(this.content[0].location, this.content[1].location)
      //   // debugger;
      // }

      this.width = loc.x - location.x;
      this.ascent = asc;
      this.descent = des;
      this.location = location._dup();
      this.height = this.descent + this.ascent;
    }
  }, {
    key: "getAllElements",
    value: function getAllElements() {
      var elements = [];
      this.content.forEach(function (e) {
        // if (e instanceof Element && !(e.content instanceof BlankElement)) {
        //   elements.push(e.content);
        // } else {
        elements = [].concat(_toConsumableArray(elements), _toConsumableArray(e.getAllElements())); // }
      });
      return elements;
    }
  }, {
    key: "setPositions",
    value: function setPositions() {
      this.content.forEach(function (e) {
        e.setPositions();
      });
    }
  }, {
    key: "offsetLocation",
    value: function offsetLocation() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.location = this.location.add(offset);
      this.content.forEach(function (e) {
        e.offsetLocation(offset);
      });
    }
  }]);

  return Elements;
}();



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Elements/Fraction.js":
/*!**********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Elements/Fraction.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Fraction; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Element */ "./src/js/diagram/DiagramElements/Equation/Elements/Element.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




 // // Equation is a class that takes a set of drawing objects (TextObjects,
// // DiagramElementPrimatives or DiagramElementCollections and HTML Objects
// // and arranges their size in a )

var Fraction =
/*#__PURE__*/
function (_Elements) {
  _inherits(Fraction, _Elements);

  // mini: boolean;
  function Fraction(numerator, denominator, vinculum) {
    var _this;

    _classCallCheck(this, Fraction);

    if (vinculum) {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Fraction).call(this, [numerator, denominator, new _Element__WEBPACK_IMPORTED_MODULE_3__["Element"](vinculum)]));
    } else {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Fraction).call(this, [numerator, denominator]));
    }

    _this.vinculum = vinculum;
    _this.numerator = numerator;
    _this.denominator = denominator;
    _this.vSpaceNum = 0;
    _this.vSpaceDenom = 0;
    _this.lineVAboveBaseline = 0;
    _this.lineWidth = 0; // this.mini = false;

    _this.scaleModifier = 1;
    _this.vinculumPosition = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    _this.vinculumScale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1, 0.01);
    return _possibleConstructorReturn(_this);
  }

  _createClass(Fraction, [{
    key: "_dup",
    value: function _dup(namedCollection) {
      var vinculum = this.vinculum;

      if (this.vinculum != null && namedCollection) {
        vinculum = namedCollection[this.vinculum.name];
      }

      var fractionCopy = new Fraction(this.numerator._dup(namedCollection), this.denominator._dup(namedCollection), vinculum);
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, fractionCopy, ['numerator', 'denominator', 'vinculum', 'content']);
      return fractionCopy;
    }
  }, {
    key: "calcSize",
    value: function calcSize(location, incomingScale) {
      var scale = incomingScale * this.scaleModifier;
      this.location = location._dup();
      this.numerator.calcSize(location, scale);
      this.denominator.calcSize(location, scale);
      this.width = Math.max(this.numerator.width, this.denominator.width) * 1.3;
      var xNumerator = (this.width - this.numerator.width) / 2;
      var xDenominator = (this.width - this.denominator.width) / 2;
      this.vSpaceNum = scale * 0.05;
      this.vSpaceDenom = scale * 0.05;
      this.lineVAboveBaseline = scale * 0.07 / this.scaleModifier;
      this.lineWidth = Math.max(scale * 0.01, 0.008);
      var yNumerator = this.numerator.descent + this.vSpaceNum + this.lineVAboveBaseline;
      var yDenominator = this.denominator.ascent + this.vSpaceDenom - this.lineVAboveBaseline;
      var yScale = 1;
      var loc = this.location;
      this.numerator.calcSize(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](loc.x + xNumerator, loc.y + yScale * yNumerator), scale);
      this.denominator.calcSize(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](loc.x + xDenominator, loc.y - yScale * yDenominator), scale);
      this.descent = this.vSpaceNum + this.lineWidth / 2 - this.lineVAboveBaseline + this.denominator.ascent + this.denominator.descent;

      if (this.descent < 0) {
        this.descent = 0;
      }

      this.ascent = this.vSpaceNum + this.lineWidth / 2 + this.lineVAboveBaseline + this.numerator.ascent + this.numerator.descent;
      this.height = this.descent + this.ascent;
      var vinculum = this.vinculum;

      if (vinculum) {
        this.vinculumPosition = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.location.x, this.location.y + this.lineVAboveBaseline);
        this.vinculumScale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.width, this.lineWidth);
        vinculum.transform.updateScale(this.vinculumScale);
        vinculum.transform.updateTranslation(this.vinculumPosition);
        vinculum.show();
      }
    }
  }, {
    key: "getAllElements",
    value: function getAllElements() {
      var elements = [];

      if (this.numerator) {
        elements = [].concat(_toConsumableArray(elements), _toConsumableArray(this.numerator.getAllElements()));
      }

      if (this.denominator) {
        elements = [].concat(_toConsumableArray(elements), _toConsumableArray(this.denominator.getAllElements()));
      }

      if (this.vinculum) {
        elements = [].concat(_toConsumableArray(elements), [this.vinculum]);
      }

      return elements;
    }
  }, {
    key: "setPositions",
    value: function setPositions() {
      this.numerator.setPositions();
      this.denominator.setPositions();
      var vinculum = this.vinculum;

      if (vinculum) {
        vinculum.transform.updateScale(this.vinculumScale);
        vinculum.transform.updateTranslation(this.vinculumPosition);
      }
    }
  }, {
    key: "offsetLocation",
    value: function offsetLocation() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.location = this.location.add(offset);
      this.numerator.offsetLocation(offset);
      this.denominator.offsetLocation(offset);
      this.vinculumPosition = this.vinculumPosition.add(offset);
    }
  }]);

  return Fraction;
}(_Element__WEBPACK_IMPORTED_MODULE_3__["Elements"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Elements/Padding.js":
/*!*********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Elements/Padding.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Padding; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Element */ "./src/js/diagram/DiagramElements/Equation/Elements/Element.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


 // import {
//   DiagramElementPrimative, DiagramElementCollection,
// } from '../../../Element';

 // // Equation is a class that takes a set of drawing objects (TextObjects,
// // DiagramElementPrimatives or DiagramElementCollections and HTML Objects
// // and arranges their size in a )

var Padding =
/*#__PURE__*/
function (_Elements) {
  _inherits(Padding, _Elements);

  function Padding(mainContent) {
    var _this;

    var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var right = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var bottom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var left = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

    _classCallCheck(this, Padding);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Padding).call(this, [mainContent]));
    _this.left = left == null ? 0 : left;
    _this.right = right == null ? 0 : right;
    _this.top = top == null ? 0 : top;
    _this.bottom = bottom == null ? 0 : bottom;
    _this.mainContent = mainContent;
    return _this;
  }

  _createClass(Padding, [{
    key: "_dup",
    value: function _dup(namedCollection) {
      var paddingCopy = new Padding(this.mainContent._dup(namedCollection), this.top, this.right, this.bottom, this.left);
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, paddingCopy, ['mainContent']);
      return paddingCopy;
    }
  }, {
    key: "calcSize",
    value: function calcSize(location, scale) {
      this.location = location._dup();
      this.mainContent.calcSize(location.add(this.left, 0), scale);
      this.descent = this.mainContent.descent + this.bottom;
      this.ascent = this.mainContent.ascent + this.top;
      this.width = this.mainContent.width + this.left + this.right;
    }
  }, {
    key: "getAllElements",
    value: function getAllElements() {
      var elements = [];

      if (this.mainContent) {
        elements = [].concat(_toConsumableArray(elements), _toConsumableArray(this.mainContent.getAllElements()));
      }

      return elements;
    }
  }, {
    key: "setPositions",
    value: function setPositions() {
      this.mainContent.setPositions();
    }
  }, {
    key: "offsetLocation",
    value: function offsetLocation() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.location = this.location.add(offset);
      this.mainContent.offsetLocation(offset);
    }
  }]);

  return Padding;
}(_Element__WEBPACK_IMPORTED_MODULE_2__["Elements"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Elements/Strike.js":
/*!********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Elements/Strike.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Strike; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Element */ "./src/js/diagram/DiagramElements/Equation/Elements/Element.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




 // // Equation is a class that takes a set of drawing objects (TextObjects,
// // DiagramElementPrimatives or DiagramElementCollections and HTML Objects
// // and arranges their size in a )

var Strike =
/*#__PURE__*/
function (_Elements) {
  _inherits(Strike, _Elements);

  function Strike(mainContent, strike) {
    var _this;

    var strikeInSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var space = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    _classCallCheck(this, Strike);

    if (strike) {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Strike).call(this, [mainContent, new _Element__WEBPACK_IMPORTED_MODULE_3__["Element"](strike)]));
    } else {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Strike).call(this, [mainContent]));
    }

    _this.strike = strike;
    _this.scaleModifier = 1;
    _this.lineWidth = 0.1;
    _this.mainContent = mainContent;

    if (strikeInSize == null) {
      _this.strikeInSize = false;
    } else {
      _this.strikeInSize = strikeInSize;
    }

    _this.space = space == null ? 0 : space;
    return _possibleConstructorReturn(_this);
  }

  _createClass(Strike, [{
    key: "_dup",
    value: function _dup(namedCollection) {
      var strike = null;

      if (this.strike != null && namedCollection) {
        strike = namedCollection[this.strike.name];
      } else {
        strike = this.strike;
      }

      var strikeCopy = new Strike(this.mainContent._dup(namedCollection), strike);
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, strikeCopy, ['strike', 'mainContent']);
      return strikeCopy;
    }
  }, {
    key: "calcSize",
    value: function calcSize(location, incomingScale) {
      var scale = incomingScale * this.scaleModifier;
      this.location = location._dup();
      this.mainContent.calcSize(location, scale);
      this.lineWidth = scale * 0.02;
      var lineExtension = this.lineWidth * 1;
      var bottomLeft = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](location.x, location.y - this.mainContent.descent);
      var topRight = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](location.x + this.mainContent.width, location.y + this.mainContent.ascent * 0.8);
      var strikeLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](bottomLeft, topRight);
      var strikeBottomLeft = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](bottomLeft, lineExtension, strikeLine.angle() + Math.PI).getPoint(2);
      var strikeLength = strikeLine.length() + lineExtension * 2;

      if (this.strikeInSize) {
        var strikeTopRight = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](topRight, lineExtension, strikeLine.angle()).getPoint(2);
        this.width = strikeTopRight.x - strikeBottomLeft.x;
        this.ascent = Math.max(this.mainContent.ascent, strikeTopRight.y - location.y) + this.space;
        this.descent = Math.max(this.mainContent.descent, location.y - strikeBottomLeft.y) + this.space;
        var xOffset = this.mainContent.location.x - strikeBottomLeft.x;
        this.mainContent.offsetLocation(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](xOffset, 0));
        strikeBottomLeft.x += xOffset;
      } else {
        this.width = this.mainContent.width;
        this.ascent = this.mainContent.ascent + this.space;
        this.descent = this.mainContent.descent + this.space;
      }

      this.height = this.descent + this.ascent;
      var strike = this.strike;

      if (strike) {
        if (strike instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"]) {
          this.strikePosition = strikeBottomLeft._dup();
          this.strikeScale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](strikeLength, this.lineWidth * 0.8);
          this.strikeRotation = strikeLine.angle();
          var width = this.strikeScale.x * Math.cos(this.strikeRotation); // $FlowFixMe

          strike._s1.transform.updateScale(this.strikeScale); // $FlowFixMe


          strike._s1.transform.updateTranslation(this.strikePosition); // $FlowFixMe


          strike._s1.transform.updateRotation(this.strikeRotation); // $FlowFixMe


          strike._s2.transform.updateScale(this.strikeScale); // $FlowFixMe


          strike._s2.transform.updateTranslation(this.strikePosition.add(width, 0)); // $FlowFixMe


          strike._s2.transform.updateRotation(Math.PI - this.strikeRotation);

          strike.showAll();
        } else {
          this.strikePosition = strikeBottomLeft._dup();
          this.strikeScale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](strikeLength, this.lineWidth);
          this.strikeRotation = strikeLine.angle();
          strike.transform.updateScale(this.strikeScale);
          strike.transform.updateTranslation(this.strikePosition);
          strike.transform.updateRotation(this.strikeRotation);
          strike.show();
        }
      }
    }
  }, {
    key: "getAllElements",
    value: function getAllElements() {
      var elements = [];

      if (this.mainContent) {
        elements = [].concat(_toConsumableArray(elements), _toConsumableArray(this.mainContent.getAllElements()));
      }

      if (this.strike) {
        elements = [].concat(_toConsumableArray(elements), [this.strike]);
      }

      return elements;
    }
  }, {
    key: "setPositions",
    value: function setPositions() {
      this.mainContent.setPositions();
      var strike = this.strike;

      if (strike) {
        if (strike instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"]) {
          var width = this.strikeScale.x * Math.cos(this.strikeRotation); // $FlowFixMe

          strike._s1.transform.updateScale(this.strikeScale); // $FlowFixMe


          strike._s1.transform.updateTranslation(this.strikePosition); // $FlowFixMe


          strike._s1.transform.updateRotation(this.strikeRotation); // $FlowFixMe


          strike._s2.transform.updateScale(this.strikeScale); // $FlowFixMe


          strike._s2.transform.updateTranslation(this.strikePosition.add(width, 0)); // $FlowFixMe


          strike._s2.transform.updateRotation(Math.PI - this.strikeRotation);
        } else {
          strike.transform.updateScale(this.strikeScale);
          strike.transform.updateTranslation(this.strikePosition);
          strike.transform.updateRotation(this.strikeRotation);
        }
      }
    }
  }, {
    key: "offsetLocation",
    value: function offsetLocation() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.location = this.location.add(offset);
      this.mainContent.offsetLocation(offset);
      this.strikePosition = this.strikePosition.add(offset);
    }
  }]);

  return Strike;
}(_Element__WEBPACK_IMPORTED_MODULE_3__["Elements"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Elements/SuperSub.js":
/*!**********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Elements/SuperSub.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SuperSub; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Element */ "./src/js/diagram/DiagramElements/Equation/Elements/Element.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var SuperSub =
/*#__PURE__*/
function (_Elements) {
  _inherits(SuperSub, _Elements);

  // subscriptXBias: number;
  // xBias: number;
  function SuperSub(content, superscript, subscript) // xBias: number = 0,
  // subscriptXBias: number = 0,
  {
    var _this;

    var scriptScale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var superBias = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var subBias = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

    _classCallCheck(this, SuperSub);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SuperSub).call(this, [content, superscript, subscript]));
    _this.superscript = superscript;
    _this.subscript = subscript; // this.subscriptXBias = subscriptXBias;

    _this.mainContent = content; // this.xBias = xBias;

    _this.scriptScale = scriptScale == null ? 0.5 : scriptScale;
    _this.superBias = superBias == null ? new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0) : superBias;
    _this.subBias = subBias == null ? new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0) : subBias;
    return _this;
  }

  _createClass(SuperSub, [{
    key: "_dup",
    value: function _dup(namedCollection) {
      var superscript = this.superscript == null ? null : this.superscript._dup(namedCollection);
      var subscript = this.subscript == null ? null : this.subscript._dup(namedCollection);
      var superSubCopy = new SuperSub(this.mainContent._dup(namedCollection), superscript, subscript, this.scriptScale, this.superBias, this.subBias);
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, superSubCopy, ['mainContent', 'superscript', 'subscript', 'content']);
      return superSubCopy;
    }
  }, {
    key: "calcSize",
    value: function calcSize(location, scale) {
      this.location = location._dup();

      var loc = location._dup();

      this.mainContent.calcSize(loc, scale);
      var w = this.mainContent.width;
      var asc = this.mainContent.ascent;
      var des = this.mainContent.descent;
      var superscript = this.superscript;

      if (superscript !== null) {
        var superLoc = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.location.x + this.mainContent.width + this.superBias.x, this.location.y + this.mainContent.ascent * 0.7 + this.superBias.y);
        superscript.calcSize(superLoc, this.scriptScale * scale);
        w = Math.max(w, superLoc.x - this.location.x + superscript.width);
        asc = Math.max(asc, superscript.ascent + superLoc.y - this.location.y);
        des = Math.max(des, this.location.y - (superLoc.y - superscript.descent));
      }

      var subscript = this.subscript;

      if (subscript !== null) {
        // get the height of the subscript content
        subscript.calcSize(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), this.scriptScale * scale);
        var subLoc = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.location.x + this.mainContent.width + this.subBias.x, // this.location.x + this.mainContent.width - this.subscriptXBias + this.xBias,
        this.location.y - subscript.ascent * 0.7 + this.subBias.y);
        subscript.calcSize(subLoc, this.scriptScale * scale);
        w = Math.max(w, subLoc.x - this.location.x + subscript.width);
        asc = Math.max(asc, subscript.ascent + subLoc.y - this.location.y);
        des = Math.max(des, subscript.descent + (this.location.y - subLoc.y));
      }

      this.width = w;
      this.ascent = asc;
      this.descent = des;
      this.height = this.descent + this.ascent;
    }
  }, {
    key: "getAllElements",
    value: function getAllElements() {
      var elements = [];

      if (this.superscript) {
        elements = [].concat(_toConsumableArray(elements), _toConsumableArray(this.superscript.getAllElements()));
      }

      if (this.subscript) {
        elements = [].concat(_toConsumableArray(elements), _toConsumableArray(this.subscript.getAllElements()));
      }

      if (this.mainContent) {
        elements = [].concat(_toConsumableArray(elements), _toConsumableArray(this.mainContent.getAllElements()));
      }

      return elements;
    }
  }, {
    key: "setPositions",
    value: function setPositions() {
      this.mainContent.setPositions();

      if (this.superscript) {
        this.superscript.setPositions();
      }

      if (this.subscript) {
        this.subscript.setPositions();
      }
    }
  }, {
    key: "offsetLocation",
    value: function offsetLocation() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.location = this.location.add(offset);
      this.mainContent.offsetLocation(offset);

      if (this.superscript) {
        this.superscript.offsetLocation(offset);
      }

      if (this.subscript) {
        this.subscript.offsetLocation(offset);
      }
    }
  }]);

  return SuperSub;
}(_Element__WEBPACK_IMPORTED_MODULE_2__["Elements"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Equation.js":
/*!*************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Equation.js ***!
  \*************************************************************/
/*! exports provided: foo, EquationNew */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "foo", function() { return foo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquationNew", function() { return EquationNew; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _tools_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../tools/color */ "./src/js/tools/color.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../DrawingObjects/TextObject/TextObject */ "./src/js/diagram/DrawingObjects/TextObject/TextObject.js");
/* harmony import */ var _Elements_Element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Elements/Element */ "./src/js/diagram/DiagramElements/Equation/Elements/Element.js");
/* harmony import */ var _EquationForm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EquationForm */ "./src/js/diagram/DiagramElements/Equation/EquationForm.js");
/* harmony import */ var _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../tools/htmlGenerator */ "./src/js/tools/htmlGenerator.js");
/* harmony import */ var _EquationSymbols__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./EquationSymbols */ "./src/js/diagram/DiagramElements/Equation/EquationSymbols.js");
/* harmony import */ var _EquationFunctions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./EquationFunctions */ "./src/js/diagram/DiagramElements/Equation/EquationFunctions.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }








// import HTMLObject from '../../DrawingObjects/HTMLObject/HTMLObject';



var foo = function foo() {}; // An Equation is a collection of elements that can be arranged into different
// forms.
// Equation allows setting of forms, and navigating through form series
// Eqn manages different forms of the

var EquationNew =
/*#__PURE__*/
function (_DiagramElementCollec) {
  _inherits(EquationNew, _DiagramElementCollec);

  // isTouchDevice: boolean;
  // animateNextFrame: void => void;
  function EquationNew(shapes) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, EquationNew);

    var color = options.color;

    if (color == null) {
      color = [0.5, 0.5, 0.5, 1];
    }

    var defaultOptions = {
      color: color,
      fontMath: new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_4__["DiagramFont"]('Times New Roman', 'normal', 0.2, '200', 'left', 'alphabetic', color),
      fontText: new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_4__["DiagramFont"]('Times New Roman', 'italic', 0.2, '200', 'left', 'alphabetic', color),
      position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      scale: 0.7,
      defaultFormAlignment: {
        fixTo: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
        alignH: 'left',
        alignV: 'baseline'
      },
      elements: {},
      forms: {},
      formSeries: []
    };
    var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, options);
    optionsToUse.position = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["parsePoint"])(optionsToUse.position, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
    optionsToUse.defaultFormAlignment.fixTo = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["parsePoint"])(optionsToUse.defaultFormAlignment.fixTo, optionsToUse.defaultFormAlignment.fixTo);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(EquationNew).call(this, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Equation').scale(1, 1).rotate(0).translate(0, 0), shapes.limits));
    _this.shapes = shapes;
    _this.color = optionsToUse.color; // this.isTouchDevice = isTouchDevice;
    // this.animateNextFrame = animateNextFrame;
    // Set default values

    _this.eqn = {
      forms: {},
      currentForm: '',
      currentSubForm: '',
      subFormPriority: ['base'],
      formSeries: [],
      currentFormSeries: '',
      scale: optionsToUse.scale,
      defaultFormAlignment: optionsToUse.defaultFormAlignment,
      functions: new _EquationFunctions__WEBPACK_IMPORTED_MODULE_9__["EquationFunctions"](_this.elements),
      symbols: new _EquationSymbols__WEBPACK_IMPORTED_MODULE_8__["default"](_this.shapes, _this.color),
      fontMath: optionsToUse.fontMath,
      fontText: optionsToUse.fontText,
      isAnimating: false,
      descriptionElement: null,
      descriptionPosition: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0)
    };

    _this.setPosition(optionsToUse.position);

    if (optionsToUse.elements != null) {
      _this.addElements(optionsToUse.elements);
    }

    if (optionsToUse.forms != null) {
      _this.addForms(optionsToUse.forms);
    }

    if (optionsToUse.formSeries != null) {
      _this.setFormSeries(optionsToUse.formSeries);
    }

    return _this;
  }

  _createClass(EquationNew, [{
    key: "addElements",
    value: function addElements(elems) {
      var _this2 = this;

      // Helper function to add text element
      var makeTextElem = function makeTextElem(options) {
        // Priority:
        //  1. color
        //  2. font
        //  3. style
        var fontToUse = _this2.eqn.fontMath;

        if (options.text.match(/[A-Z,a-z]/)) {
          fontToUse = _this2.eqn.fontText;
        }

        if (options.style != null) {
          if (options.style === 'italic') {
            fontToUse = _this2.eqn.fontText;
          }

          if (options.style === 'normal') {
            fontToUse = _this2.eqn.fontMath;
          }
        }

        if (options.font != null) {
          fontToUse = options.font;
        }

        var p = _this2.shapes.txt(options.text, {
          position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
          font: fontToUse
        }); // if (options.color != null) {
        //   p.setColor(options.color);
        // } else {
        //   p.setColor(RGBToArray(p.drawingObject.text[0].font.color));
        // }


        return p;
      }; // Helper function to add symbol element


      var makeSymbolElem = function makeSymbolElem(options) {
        var symbol = _this2.eqn.symbols.get(options.symbol, options); // console.log('got', symbol)


        if (symbol == null) {
          symbol = makeTextElem({
            text: "Symbol ".concat(options.symbol, " not valid")
          });
        }

        if (options.color == null) {
          symbol.setColor(_this2.color);
        }

        return symbol;
      }; // Go through each element and add it


      Object.keys(elems).forEach(function (key) {
        // const [key, elem] = entry;
        var elem = elems[key];

        if (typeof elem === 'string') {
          if (!key.startsWith('space')) {
            _this2.add(key, makeTextElem({
              text: elem
            }));
          }
        } else if (elem instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementPrimative"]) {
          _this2.add(key, elem);
        } else if (elem instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementCollection"]) {
          _this2.add(key, elem);
        } else {
          var diagramElem;

          if (elem.symbol != null && typeof elem.symbol === 'string') {
            // console.log(elem.symbol)
            // $FlowFixMe
            diagramElem = makeSymbolElem(elem);
          } else if (elem.text != null && elem.text) {
            // $FlowFixMe
            diagramElem = makeTextElem(elem);
          }

          if (diagramElem != null) {
            if (elem.elementOptions != null) {
              diagramElem.setProperties(elem.elementOptions);
            }

            _this2.add(key, diagramElem);
          }
        }
      });
      var fullLineHeightPrimative = makeTextElem({
        text: 'gh'
      });
      var form = this.createForm({
        elem: fullLineHeightPrimative
      });
      form.content = [this.eqn.functions.contentToElement(fullLineHeightPrimative)];
      form.arrange(this.eqn.scale, 'left', 'baseline', new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
      this.eqn.functions.fullLineHeight = form;
      this.setFirstTransform(this.transform);
    }
  }, {
    key: "addDescriptionElement",
    value: function addDescriptionElement() {
      var descriptionElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var descriptionPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.eqn.descriptionElement = descriptionElement;
      this.eqn.descriptionPosition = descriptionPosition;

      if (this.eqn.descriptionElement) {
        this.eqn.descriptionElement.setPosition(this.getDiagramPosition().add(descriptionPosition));
      }
    }
  }, {
    key: "setPosition",
    value: function setPosition(pointOrX) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      _get(_getPrototypeOf(EquationNew.prototype), "setPosition", this).call(this, pointOrX, y);

      var position = this.getDiagramPosition(); // console.log(this.eqn, this.eqn.descriptionElement)

      if (this.eqn.descriptionElement != null) {
        this.eqn.descriptionElement.setPosition(position.add(this.eqn.descriptionPosition));
      }
    } // scaleForm(name: string, scale: number, subForm: string = 'base') {
    //   // console.log(name, this.form, formType, this.form[name][formType])
    //   if (name in this.eqn.forms) {
    //     if (subForm in this.eqn.forms[name]) {
    //       this.eqn.forms[name][subForm].arrange(
    //         scale,
    //         this.eqn.formAlignment.hAlign,
    //         this.eqn.formAlignment.vAlign,
    //         this.eqn.formAlignment.fixTo,
    //       );
    //     }
    //   }
    // }
    // scale(scale: number) {
    //   Object.keys(this.form).forEach((name) => {
    //     Object.keys(this.form[name]).forEach((formType) => {
    //       if (formType !== 'name') {
    //         this.scaleForm(name, scale, formType);
    //       }
    //     });
    //   });
    // }

  }, {
    key: "addPhrases",
    value: function addPhrases(phrases) {
      var _this3 = this;

      Object.keys(phrases).forEach(function (phraseName) {
        var phrase = phrases[phraseName];
        _this3.eqn.functions.phrases[phraseName] = phrase;
      });
    }
  }, {
    key: "addForms",
    value: function addForms(forms) {
      var _this4 = this;

      var isFormString = function isFormString(form) {
        return typeof form === 'string';
      };

      var isFormArray = function isFormArray(form) {
        return Array.isArray(form);
      };

      var isFormMethodDefinition = function isFormMethodDefinition(form) {
        if (isFormString(form) || isFormArray(form)) {
          return false;
        }

        if (form != null && _typeof(form) === 'object') {
          // $FlowFixMe
          var keys = Object.keys(form);

          if (keys.length === 1 && keys[0] in _this4.eqn.functions) {
            return true;
          }
        }

        return false;
      };

      var isFormElements = function isFormElements(form) {
        return form instanceof _Elements_Element__WEBPACK_IMPORTED_MODULE_5__["Elements"];
      };

      var isFormFullObject = function isFormFullObject(form) {
        if (isFormString(form) || isFormArray(form) || isFormMethodDefinition(form) || isFormElements(form)) {
          return false;
        }

        if (form != null && _typeof(form) === 'object' && form.content != null) {
          return true;
        }

        return false;
      };

      var addFormNormal = function addFormNormal(name, form) {
        // $FlowFixMe
        var formContent = [_this4.eqn.functions.contentToElement(form)];

        _this4.addForm(name, formContent);
      };

      var addFormFullObject = function addFormFullObject(name, form) {
        // $FlowFixMe
        var formContent = [_this4.eqn.functions.contentToElement(form.content)];
        var subForm = form.subForm,
            addToSeries = form.addToSeries,
            elementMods = form.elementMods,
            time = form.time,
            alignment = form.alignment,
            scale = form.scale,
            description = form.description,
            modifiers = form.modifiers;
        var options = {
          subForm: subForm,
          addToSeries: addToSeries,
          elementMods: elementMods,
          time: time,
          alignment: alignment,
          scale: scale,
          description: description,
          modifiers: modifiers
        }; // $FlowFixMe

        _this4.addForm(name, formContent, options);
      };

      Object.keys(forms).forEach(function (name) {
        var form = forms[name];

        if (isFormString(form) || isFormArray(form) || isFormMethodDefinition(form) || isFormElements(form)) {
          addFormNormal(name, form);
        } else if (isFormFullObject(form)) {
          addFormFullObject(name, form);
        } else {
          Object.entries(form).forEach(function (subFormEntry) {
            var _subFormEntry = _slicedToArray(subFormEntry, 2),
                subFormName = _subFormEntry[0],
                subFormValue = _subFormEntry[1]; // const subFormOption = { subForm: subFormName };


            if (isFormString(subFormValue) || isFormArray(subFormValue) || isFormMethodDefinition(subFormValue) || isFormElements(subFormValue)) {
              // $FlowFixMe
              addFormFullObject(name, {
                content: subFormValue,
                subForm: subFormName
              });
            } else {
              // $FlowFixMe
              addFormFullObject(name, Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(subFormValue, {
                subForm: subFormName
              }));
            }
          });
        }
      });
    }
  }, {
    key: "checkFixTo",
    value: function checkFixTo(fixTo) {
      if (typeof fixTo === 'string') {
        var element = Object(_EquationFunctions__WEBPACK_IMPORTED_MODULE_9__["getDiagramElement"])(this, fixTo);

        if (element != null) {
          return element;
        }

        return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      }

      if (fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementPrimative"] || fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementCollection"] || fixTo instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        return fixTo;
      }

      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    }
  }, {
    key: "createForm",
    value: function createForm() {
      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.elements;
      return new _EquationForm__WEBPACK_IMPORTED_MODULE_6__["default"](elements, {
        getAllElements: this.getAllElements.bind(this),
        hideAll: this.hideAll.bind(this),
        show: this.show.bind(this),
        showOnly: this.showOnly.bind(this),
        stop: this.stop.bind(this),
        getElementTransforms: this.getElementTransforms.bind(this),
        setElementTransforms: this.setElementTransforms.bind(this),
        animateToTransforms: this.animateToTransforms.bind(this)
      });
    }
  }, {
    key: "addForm",
    value: function addForm(name, content) {
      var _this5 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!(name in this.eqn.forms)) {
        // $FlowFixMe   - its ok for this to start undefined, it will be filled.
        this.eqn.forms[name] = {};
      }

      var defaultOptions = {
        subForm: 'base',
        elementMods: {},
        time: null,
        // use velocities instead of time
        description: '',
        modifiers: {},
        scale: this.eqn.scale,
        alignment: this.eqn.defaultFormAlignment
      };
      var optionsToUse = defaultOptions;

      if (options) {
        optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, options);
      }

      var _optionsToUse = optionsToUse,
          subForm = _optionsToUse.subForm,
          description = _optionsToUse.description,
          modifiers = _optionsToUse.modifiers,
          time = _optionsToUse.time,
          elementMods = _optionsToUse.elementMods;
      this.eqn.forms[name].name = name;
      var form = this.eqn.forms[name];
      form[subForm] = this.createForm(); // form[subForm].name = subForm;

      form[subForm].description = description;
      form[subForm].modifiers = modifiers;
      form[subForm].name = name;
      form[subForm].subForm = subForm;
      form[subForm].elementMods = {};

      if (typeof time === 'number') {
        form[subForm].time = {
          fromPrev: time,
          fromNext: time,
          fromAny: time
        };
      } else if (time == null) {
        form[subForm].time = null;
      } else {
        var defaultTime = {
          fromPrev: null,
          fromNext: null,
          fromAny: null
        };
        form[subForm].time = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultTime, time);
      }

      Object.keys(elementMods).forEach(function (elementName) {
        var diagramElement = Object(_EquationFunctions__WEBPACK_IMPORTED_MODULE_9__["getDiagramElement"])(_this5, elementName);

        if (diagramElement) {
          var color;
          var elementOptions;

          if (Array.isArray(elementMods[elementName])) {
            var _elementMods$elementN = _slicedToArray(elementMods[elementName], 2);

            color = _elementMods$elementN[0];
            elementOptions = _elementMods$elementN[1];
          } else {
            var _elementMods$elementN2 = elementMods[elementName];
            color = _elementMods$elementN2.color;
            elementOptions = _elementMods$elementN2.elementOptions;
          }

          form[subForm].elementMods[elementName] = {
            element: diagramElement,
            color: color,
            elementOptions: elementOptions
          };
        }
      });
      optionsToUse.alignment.fixTo = this.checkFixTo(optionsToUse.alignment.fixTo);
      form[subForm].content = content;
      form[subForm].arrange(optionsToUse.scale, optionsToUse.alignment.alignH, optionsToUse.alignment.alignV, optionsToUse.alignment.fixTo); // const { addToSeries } = optionsToUse;
      // console.log(addToSeries)
      // if (addToSeries != null && addToSeries !== '' && typeof addToSeries === 'string') {
      //   if (this.eqn.formSeries[addToSeries] == null) {
      //     this.eqn.formSeries[addToSeries] = [];
      //   }
      //   this.eqn.formSeries[addToSeries].push(form);
      // }
      // make the first form added also equal to the base form as always
      // need a base form for some functions

      if (this.eqn.forms[name].base === undefined) {
        var baseOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, optionsToUse);
        baseOptions.subForm = 'base';
        this.addForm(name, content, baseOptions);
      }

      if (this.eqn.currentForm === '') {
        this.eqn.currentForm = name;
      }

      if (this.eqn.currentSubForm === '') {
        this.eqn.currentSubForm = 'base';
      }
    }
  }, {
    key: "setFormSeries",
    value: function setFormSeries(series) {
      this.eqn.formSeries = series.slice();
    }
  }, {
    key: "getCurrentForm",
    value: function getCurrentForm() {
      if (this.eqn.forms[this.eqn.currentForm] == null) {
        return null;
      }

      if (this.eqn.forms[this.eqn.currentForm][this.eqn.currentSubForm] == null) {
        return null;
      }

      return this.eqn.forms[this.eqn.currentForm][this.eqn.currentSubForm];
    }
  }, {
    key: "render",
    value: function render() {
      var form = this.getCurrentForm();

      if (form != null) {
        form.showHide();
        this.show();
        form.setPositions(); // this.updateDescription();
      }
    }
  }, {
    key: "setCurrentForm",
    value: function setCurrentForm(formOrName) {
      var subForm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'base';

      if (typeof formOrName === 'string') {
        this.eqn.currentForm = '';
        this.eqn.currentSubForm = '';

        if (formOrName in this.eqn.forms) {
          this.eqn.currentForm = formOrName;

          if (subForm in this.eqn.forms[formOrName]) {
            this.eqn.currentSubForm = subForm;
          }
        }
      } else {
        this.eqn.currentForm = formOrName.name;
        this.eqn.currentSubForm = formOrName.subForm;
      }
    }
  }, {
    key: "showForm",
    value: function showForm(formOrName) {
      var subForm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.show();
      var form = formOrName;

      if (typeof formOrName === 'string') {
        form = this.getForm(formOrName, subForm);
      }

      if (form) {
        this.setCurrentForm(form);
        this.render();
      }
    }
  }, {
    key: "getForm",
    value: function getForm(formOrName, subForm) {
      var _this6 = this;

      if (formOrName instanceof _EquationForm__WEBPACK_IMPORTED_MODULE_6__["default"]) {
        return formOrName;
      }

      if (formOrName in this.eqn.forms) {
        var formTypeToUse = subForm;

        if (formTypeToUse == null) {
          var possibleFormTypes // $FlowFixMe
          = this.eqn.subFormPriority.filter(function (fType) {
            return fType in _this6.eqn.forms[formOrName];
          });

          if (possibleFormTypes.length) {
            // eslint-disable-next-line prefer-destructuring
            formTypeToUse = possibleFormTypes[0];
          }
        }

        if (formTypeToUse != null) {
          return this.eqn.forms[formOrName][formTypeToUse];
        }
      }

      return null;
    }
  }, {
    key: "goToForm",
    value: function goToForm() {
      var _this7 = this;

      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var fromWhere = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'fromAny';
      var animate = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      var callback = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

      if (this.eqn.isAnimating) {
        // this.stop(true, true);
        this.stop(true, true); // this.animations.cancel('complete');
        // this.animations.cancel('complete');

        this.eqn.isAnimating = false;
        var currentForm = this.getCurrentForm();

        if (currentForm != null) {
          this.showForm(currentForm);
        }

        return;
      } // this.animations.cancel();
      // this.animations.cancel();
      // this.stop();


      this.stop();
      this.eqn.isAnimating = false; // By default go to the next form in a series

      var nextIndex = 0;

      if (name == null) {
        var index = 0;

        var _currentForm = this.getCurrentForm();

        if (_currentForm != null) {
          index = this.eqn.formSeries.indexOf(_currentForm.name);

          if (index < 0) {
            index = 0;
          }
        }

        nextIndex = index + 1;

        if (nextIndex === this.eqn.formSeries.length) {
          nextIndex = 0;
        }
      } else if (typeof name === 'number') {
        nextIndex = name;
      } else {
        nextIndex = this.eqn.formSeries.indexOf(name);

        if (nextIndex < 0) {
          nextIndex = 0;
        }
      }

      var nextForm = this.eqn.forms[this.eqn.formSeries[nextIndex]];
      var nextSubForm = null;
      var subFormToUse = null;
      var possibleSubForms = this.eqn.subFormPriority.filter(function (sf) {
        return sf in nextForm;
      });

      if (possibleSubForms.length) {
        // eslint-disable-next-line prefer-destructuring
        subFormToUse = possibleSubForms[0];
      }

      if (subFormToUse != null) {
        // $FlowFixMe
        nextSubForm = nextForm[subFormToUse];

        if (time === 0) {
          this.showForm(nextSubForm);

          if (callback != null) {
            callback();
          }
        } else {
          this.eqn.isAnimating = true;

          var end = function end() {
            _this7.eqn.isAnimating = false;

            if (callback != null) {
              callback();
            }
          };

          if (animate) {
            var timeToUse = time; // $FlowFixMe - this is going to be ok

            if (nextSubForm.time != null && nextSubForm.time[fromWhere] != null) {
              timeToUse = nextSubForm.time[fromWhere];
            } // console.log('******************* animate')


            nextSubForm.animatePositionsTo(delay, 0.4, timeToUse, 0.4, end);
          } else {
            // console.log('******************* hideshow')
            nextSubForm.allHideShow(delay, 0.5, 0.2, 0.5, end);
          }

          this.setCurrentForm(nextSubForm);
        } // this.updateDescription();

      }
    }
  }, {
    key: "getFormIndex",
    value: function getFormIndex(formToGet) {
      var form = this.getForm(formToGet);
      var index = -1;

      if (form != null) {
        index = this.eqn.formSeries.indexOf(form.name);
      }

      return index;
    }
  }, {
    key: "prevForm",
    value: function prevForm() {
      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var currentForm = this.getCurrentForm();

      if (currentForm == null) {
        return;
      }

      var index = this.getFormIndex(currentForm);

      if (index > -1) {
        index -= 1;

        if (index < 0) {
          index = this.eqn.formSeries.length - 1;
        }

        this.goToForm(index, time, delay, 'fromNext');
      }
    }
  }, {
    key: "nextForm",
    value: function nextForm() {
      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var animate = true;
      var currentForm = this.getCurrentForm();

      if (currentForm == null) {
        return;
      }

      var index = this.getFormIndex(currentForm);

      if (index > -1) {
        index += 1;

        if (index > this.eqn.formSeries.length - 1) {
          index = 0;
          animate = false;
        }

        this.goToForm(index, time, delay, 'fromPrev', animate);
      }
    }
  }, {
    key: "replayCurrentForm",
    value: function replayCurrentForm(time) {
      if (this.eqn.isAnimating) {
        this.stop(true, true);
        this.stop(true, true); // this.animations.cancel('complete');
        // this.animations.cancel('complete');

        this.eqn.isAnimating = false;
        var currentForm = this.getCurrentForm();

        if (currentForm != null) {
          this.showForm(currentForm);
        }

        return;
      } // this.animations.cancel();
      // this.animations.cancel();


      this.stop();
      this.stop();
      this.eqn.isAnimating = false;
      this.prevForm(0);
      this.nextForm(time, 0.5);
    }
  }, {
    key: "animateToForm",
    value: function animateToForm(name) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      // this.stopAnimatingColor(true, true);
      // this.stopAnimatingColor(true, true);
      this.stop();
      this.stop(); // this.animations.cancel();
      // this.animations.cancel();

      var form = this.getForm(name);

      if (form != null) {
        form.animatePositionsTo(delay, 0.4, time, 0.4, callback);
      }

      this.setCurrentForm(name);
    }
  }, {
    key: "changeDescription",
    value: function changeDescription(formOrName) {
      var description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var modifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var subForm = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'base';
      var form = this.getForm(formOrName, subForm);

      if (form != null) {
        form.description = "".concat(description);
        form.modifiers = modifiers;
      }
    }
  }, {
    key: "getDescription",
    value: function getDescription(formOrName) {
      var subForm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'base';
      var form = this.getForm(formOrName, subForm);

      if (form != null && form.description != null) {
        return _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_7__["applyModifiers"](form.description, form.modifiers);
      }

      return '';
    } // updateDescription(
    //   formOrName: EquationForm | string | null = null,
    //   subForm: string = 'base',
    // ) {
    //   const element = this.eqn.descriptionElement;
    //   if (element == null) {
    //     return;
    //   }
    //   if (element.isShown === false) {
    //     return;
    //   }
    //   let form = null;
    //   if (formOrName == null) {
    //     form = this.getCurrentForm();
    //   } else if (typeof formOrName === 'string') {
    //     form = this.getForm(formOrName, subForm);
    //   } else {
    //     form = formOrName;
    //   }
    //   if (form == null) {
    //     return;
    //   }
    //   if (form.description == null) {
    //     return;
    //   }
    //   const { drawingObject } = element;
    //   if (drawingObject instanceof HTMLObject) {
    //     drawingObject.change(
    //       html.applyModifiers(form.description, form.modifiers),
    //       element.lastDrawTransform.m(),
    //     );
    //     html.setOnClicks(form.modifiers);
    //   }
    // }

  }]);

  return EquationNew;
}(_Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementCollection"]);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/EquationForm.js":
/*!*****************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/EquationForm.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EquationForm; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _Elements_Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Elements/Element */ "./src/js/diagram/DiagramElements/Equation/Elements/Element.js");
/* harmony import */ var _EquationFunctions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EquationFunctions */ "./src/js/diagram/DiagramElements/Equation/EquationFunctions.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

 // import { roundNum } from '../../../tools/math';






var EquationForm =
/*#__PURE__*/
function (_Elements) {
  _inherits(EquationForm, _Elements);

  // deprecate
  function EquationForm(elements, collectionMethods) {
    var _this;

    _classCallCheck(this, EquationForm);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(EquationForm).call(this, []));
    _this.elements = elements;
    _this.collectionMethods = collectionMethods;
    _this.description = null;
    _this.modifiers = {};
    _this.elementMods = {};
    _this.time = null;
    _this.subForm = '';
    return _this;
  }

  _createClass(EquationForm, [{
    key: "getNamedElements",
    value: function getNamedElements() {
      var namedElements = {};
      this.collectionMethods.getAllElements().forEach(function (element) {
        namedElements[element.name] = element;
      });
      return namedElements;
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.elements;
      var collectionMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.collectionMethods;
      var equationCopy = new EquationForm(elements, collectionMethods);
      var namedElements = {};
      collectionMethods.getAllElements().forEach(function (element) {
        namedElements[element.name] = element;
      });
      var newContent = [];
      this.content.forEach(function (contentElement) {
        newContent.push(contentElement._dup(namedElements));
      });
      equationCopy.content = newContent;
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, equationCopy, ['content', 'collectionMethods', 'form', 'elements']);
      return equationCopy;
    }
  }, {
    key: "createEq",
    value: function createEq(content) {
      var _this2 = this;

      var elements = [];
      content.forEach(function (c) {
        if (typeof c === 'string') {
          if (c.startsWith('space')) {
            var spaceNum = parseFloat(c.replace(/space[_]*/, '')) || 0.03;
            elements.push(new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["BlankElement"](spaceNum)));
          } else {
            var diagramElement = Object(_EquationFunctions__WEBPACK_IMPORTED_MODULE_4__["getDiagramElement"])(_this2.elements, c);

            if (diagramElement) {
              elements.push(new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](diagramElement));
            }
          }
        } else {
          elements.push(c._dup());
        }

        _this2.content = elements;
      }); // this.content = content;
    } // An Equation collection is a flat collection of DiagramElements.
    //
    // The form determines how elements are positioned relative to each other.
    //
    // A form of an equation takes the form's elements (a subset of the
    // collection) and applies a translation and scale transformation. This
    // aligns all the elements of a form relative to each other to render
    // the desired form.
    //
    // Arranging a form of an equation goes through each element in the form
    // and positions and scales it in the equation's vertex space.
    // It also saves the locaiton and scale information in the form's element
    // property.
    //
    // The elements are positioned relative to 0,0 in vertex space based on the
    // fixTo, alignH and alignV parameters.
    //
    // fixTo can only be a point in the equation's vertex space, or a
    // DiagramElement in the equation.
    //
    // If fixTo is an element in the equation:
    //    - the fixTo element is positioned at 0, 0, and all other elements
    //      repositioned relative to that.
    //    - The equation collection setPosition (or translation transform) can
    //      then be used to position the equation in the diagram (or relative
    //      collection space)
    //    - if alignH is:
    //        - 'middle': the fixTo element is centered in x around (0, 0)
    //        - 'right': the fixTo element right most point is at x = 0
    //        - 'left': default - the fixTo element x position at 0
    //    - if alignV is:
    //        - 'center': the fixTo element is centered in y around (0, 0)
    //        - 'bottom': the fixTo element bottom most point is at y = 0
    //        - 'top': the fixTo element top most point is at y = 0
    //        - 'baseline': default - the fixTo element y position at 0
    //
    // If fixTo is a Point, the equation is positioned at that point in the
    // equation's vertex space.
    //  - alignH:
    //    - 'left': The equation's left most element's left most point is at
    //              Point.x
    //    - 'right': The equation's right most element's right most point is at
    //              Point.x
    //    - 'center': The equation is centered horizontally around Point.x
    //  - alignV:
    //    - 'baseline': The equation's baseline is at Point.y
    //    - 'top': The equation's top most element's top most point is at Point.y
    //    - 'bottom': The equation's top most element's top most point is at
    //                Point.y
    //    - 'middle': The equation is centered vertically around Point.y
    //

  }, {
    key: "arrange",
    value: function arrange() {
      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var alignH = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'left';
      var alignV = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'baseline';
      var fixTo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var elementsInCollection = this.collectionMethods.getAllElements();
      var elementsCurrentlyShowing = elementsInCollection.filter(function (e) {
        return e.isShown;
      });
      this.collectionMethods.hideAll();
      this.collectionMethods.show();

      _get(_getPrototypeOf(EquationForm.prototype), "calcSize", this).call(this, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), scale);

      var fixPoint = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

      if (fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementPrimative"] || fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"]) {
        var t = fixTo.transform.t();

        if (t != null) {
          fixPoint = t._dup();
        }
      } else {
        fixPoint = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-fixTo.x, -fixTo.y);
      }

      var w = this.width;
      var h = this.height;
      var a = this.ascent;
      var d = this.descent;

      var p = this.location._dup();

      if (fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementPrimative"] || fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"]) {
        var _t = fixTo.transform.t();

        var s = fixTo.transform.s();

        if (_t != null && s != null) {
          var rect = fixTo.getVertexSpaceBoundingRect();
          w = rect.width * s.x;
          h = rect.height * s.y;
          a = rect.top * s.y - _t.y;
          d = _t.y - rect.bottom * s.y;
          p = _t._dup();
        }
      }

      if (alignH === 'right') {
        fixPoint.x += w;
      } else if (alignH === 'center') {
        fixPoint.x += w / 2;
      }

      if (alignV === 'top') {
        fixPoint.y += p.y + a;
      } else if (alignV === 'bottom') {
        fixPoint.y += p.y - d;
      } else if (alignV === 'middle') {
        fixPoint.y += p.y - d + h / 2;
      }

      var delta = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0).sub(fixPoint);

      if (delta.x !== 0 || delta.y !== 0) {
        this.offsetLocation(delta);
        this.setPositions();
      }

      this.collectionMethods.showOnly(elementsCurrentlyShowing);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "dissolveElements",
    value: function dissolveElements(elements) {
      var dissolve = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'in';
      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.01;
      var time = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

      if (elements.length === 0) {
        if (callback) {
          callback(false);
          return;
        }
      }

      var count = elements.length;
      var completed = 0;

      var onFinish = function onFinish(cancelled) {
        completed += 1;

        if (completed === count) {
          if (callback) {
            callback(cancelled);
          }
        }
      };

      elements.forEach(function (e) {
        e.animations.addTo('Equation Color').color({
          dissolve: dissolve,
          onFinish: onFinish,
          duration: time,
          delay: delay
        }).start();
      });
    }
  }, {
    key: "getElementsToShowAndHide",
    value: function getElementsToShowAndHide() {
      var allElements = this.collectionMethods.getAllElements();
      var elementsShown = allElements.filter(function (e) {
        return e.isShown;
      });
      var elementsShownTarget = this.getAllElements();
      var elementsToHide = elementsShown.filter(function (e) {
        return elementsShownTarget.indexOf(e) === -1;
      });
      var elementsToShow = elementsShownTarget.filter(function (e) {
        return elementsShown.indexOf(e) === -1;
      });
      return {
        show: elementsToShow,
        hide: elementsToHide
      };
    }
  }, {
    key: "render",
    value: function render() {
      this.hideShow();
      this.setPositions();
    }
  }, {
    key: "showHide",
    value: function showHide() {
      var showTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var hideTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      this.collectionMethods.stop();
      this.collectionMethods.show();

      var _this$getElementsToSh = this.getElementsToShowAndHide(),
          show = _this$getElementsToSh.show,
          hide = _this$getElementsToSh.hide;

      if (showTime === 0) {
        show.forEach(function (e) {
          e.showAll();
        });
      } else {
        this.dissolveElements(show, 'in', 0.01, showTime, null);
      }

      if (hideTime === 0) {
        hide.forEach(function (e) {
          return e.hide();
        });
      } else {
        this.dissolveElements(hide, 'out', showTime, hideTime, callback);
      }
    }
  }, {
    key: "hideShow",
    value: function hideShow() {
      var showTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var hideTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      this.collectionMethods.stop();
      this.collectionMethods.show();

      var _this$getElementsToSh2 = this.getElementsToShowAndHide(),
          show = _this$getElementsToSh2.show,
          hide = _this$getElementsToSh2.hide;

      if (hideTime === 0) {
        hide.forEach(function (e) {
          return e.hide();
        });
      } else {
        this.dissolveElements(hide, 'out', 0.01, hideTime, null);
      }

      if (showTime === 0) {
        show.forEach(function (e) {
          e.showAll();
        });

        if (callback != null) {
          callback();
        }
      } else {
        this.dissolveElements(show, 'in', hideTime, showTime, callback);
      }
    }
  }, {
    key: "allHideShow",
    value: function allHideShow() {
      var _this3 = this;

      var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var hideTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
      var blankTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
      var showTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;
      var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      this.collectionMethods.stop();
      var allElements = this.collectionMethods.getAllElements();
      var elementsShown = allElements.filter(function (e) {
        return e.isShown;
      });
      var elementsToShow = this.getAllElements();
      var elementsToDelayShowing = elementsToShow.filter(function (e) {
        return !e.isShown;
      });
      var elementsToShowAfterDissolve = elementsToShow.filter(function (e) {
        return e.isShown;
      });
      var cumTime = delay;

      if (elementsToShow.length === 0 && elementsShown.length === 0) {
        if (callback != null) {
          callback(false);
          return;
        }
      }

      var dissolveOutCallback = function dissolveOutCallback() {
        _this3.setPositions();
      };

      if (elementsToShow.length === 0) {
        dissolveOutCallback = function dissolveOutCallback(cancelled) {
          _this3.setPositions();

          if (callback != null) {
            callback(cancelled);
          }
        };
      }

      if (elementsShown.length > 0) {
        this.dissolveElements(elementsShown, 'out', delay, hideTime, dissolveOutCallback);
        cumTime += hideTime;
      } else {
        this.setPositions();
      }

      var count = elementsToShow.length;
      var completed = 0;

      var onFinish = function onFinish(cancelled) {
        completed += 1;

        if (completed === count - 1) {
          if (callback) {
            callback(cancelled);
          }
        }
      };

      elementsToDelayShowing.forEach(function (e) {
        e.animations.addTo('Equation Color').dissolveIn({
          duration: showTime,
          onFinish: onFinish,
          delay: cumTime + blankTime
        }).start();
      });
      elementsToShowAfterDissolve.forEach(function (e) {
        e.animations.addTo('Equation Color').dissolveIn({
          duration: showTime,
          onFinish: onFinish,
          delay: blankTime
        }).start();
      });
    }
  }, {
    key: "animatePositionsTo",
    value: function animatePositionsTo(delay, dissolveOutTime, moveTime, dissolveInTime) {
      var _this4 = this;

      var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var allElements = this.collectionMethods.getAllElements();
      this.collectionMethods.stop();
      var elementsShown = allElements.filter(function (e) {
        return e.isShown;
      });
      var elementsShownTarget = this.getAllElements();
      var elementsToHide = elementsShown.filter(function (e) {
        return elementsShownTarget.indexOf(e) === -1;
      });
      var elementsToShow = elementsShownTarget.filter(function (e) {
        return elementsShown.indexOf(e) === -1;
      });
      var currentTransforms = this.collectionMethods.getElementTransforms();
      this.setPositions();
      var animateToTransforms = this.collectionMethods.getElementTransforms();
      var elementsToMove = [];
      var toMoveStartTransforms = [];
      var toMoveStopTransforms = [];
      Object.keys(animateToTransforms).forEach(function (key) {
        var currentT = currentTransforms[key];
        var nextT = animateToTransforms[key];

        if (!currentT.isEqualTo(nextT)) {
          elementsToMove.push(key);
          toMoveStartTransforms.push(currentT);
          toMoveStopTransforms.push(nextT);
        }
      }); // Find move time to use. If moveTime is null, then a velocity is used.

      var moveTimeToUse;

      if (moveTime === null) {
        moveTimeToUse = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMoveTime"])(toMoveStartTransforms, toMoveStopTransforms, 0, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0.35, 0.35), // 0.25 diagram space per s
        2 * Math.PI / 6, // 60º per second
        new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0.4, 0.4) // 100% per second
        );
      } else {
        moveTimeToUse = moveTime;
      }

      this.collectionMethods.setElementTransforms(currentTransforms);
      var cumTime = delay;
      var moveCallback = null;
      var dissolveInCallback = null;
      var dissolveOutCallback = null;

      if (elementsToMove.length === 0 && elementsToShow.length === 0) {
        dissolveOutCallback = callback;
      } else if (elementsToShow.length === 0) {
        moveCallback = callback;
      } else {
        dissolveInCallback = callback;
      }

      if (elementsToHide.length > 0) {
        this.dissolveElements(elementsToHide, 'out', delay, dissolveOutTime, dissolveOutCallback);
        cumTime += dissolveOutTime;
      }

      Object.keys(this.elementMods).forEach(function (elementName) {
        var mods = _this4.elementMods[elementName];
        var element = mods.element,
            color = mods.color,
            style = mods.style,
            direction = mods.direction,
            mag = mods.mag;

        if (element != null) {
          if (color != null) {
            element.addTo('Equation Color') // .delay(cumTime)
            .color({
              target: color,
              duration: moveTimeToUse,
              delay: cumTime
            }).start(); // element.animateColorToWithDelay(color, cumTime, moveTimeToUse);
          }

          if (style != null) {
            element.animate.transform.translation.style = style;
          }

          if (direction != null) {
            element.animate.transform.translation.options.direction = direction;
          }

          if (mag != null) {
            element.animate.transform.translation.options.magnitude = mag;
          }
        }
      });
      var t = this.collectionMethods.animateToTransforms(animateToTransforms, moveTimeToUse, cumTime, 0, moveCallback);

      if (t > 0) {
        cumTime = t;
      }

      if (elementsToShow.length > 0) {
        this.dissolveElements(elementsToShow, 'in', cumTime, dissolveInTime, dissolveInCallback);
        cumTime += dissolveInTime + 0.001;
      }

      return cumTime;
    }
  }]);

  return EquationForm;
}(_Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Elements"]);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/EquationFunctions.js":
/*!**********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/EquationFunctions.js ***!
  \**********************************************************************/
/*! exports provided: getDiagramElement, EquationFunctions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDiagramElement", function() { return getDiagramElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquationFunctions", function() { return EquationFunctions; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _Elements_Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Elements/Element */ "./src/js/diagram/DiagramElements/Equation/Elements/Element.js");
/* harmony import */ var _Elements_Fraction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Elements/Fraction */ "./src/js/diagram/DiagramElements/Equation/Elements/Fraction.js");
/* harmony import */ var _Elements_Strike__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Elements/Strike */ "./src/js/diagram/DiagramElements/Equation/Elements/Strike.js");
/* harmony import */ var _Elements_SuperSub__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Elements/SuperSub */ "./src/js/diagram/DiagramElements/Equation/Elements/SuperSub.js");
/* harmony import */ var _Elements_Brackets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Elements/Brackets */ "./src/js/diagram/DiagramElements/Equation/Elements/Brackets.js");
/* harmony import */ var _EquationForm__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./EquationForm */ "./src/js/diagram/DiagramElements/Equation/EquationForm.js");
/* harmony import */ var _Elements_Annotation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Elements/Annotation */ "./src/js/diagram/DiagramElements/Equation/Elements/Annotation.js");
/* harmony import */ var _Elements_Padding__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Elements/Padding */ "./src/js/diagram/DiagramElements/Equation/Elements/Padding.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


// import { joinObjects } from '../../../tools/tools';



 // import DiagramPrimatives from '../../DiagramPrimatives/DiagramPrimatives';






function getDiagramElement(elementsObject, name) {
  if (typeof name !== 'string') {
    return name;
  }

  if (elementsObject instanceof _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementCollection"]) {
    if (elementsObject && "_".concat(name) in elementsObject) {
      // $FlowFixMe
      return elementsObject["_".concat(name)];
    }

    return null;
  }

  if (elementsObject && name in elementsObject) {
    return elementsObject[name];
  }

  return null;
} // export type TypeParsablePoint = [number, number] | Point | { x: number, y: number};
// // point can be defined as:
// //    - Point instance
// //    - [1, 1]
// //    - { x: 1, y: 1 }
// export const parsePoint = (point: TypeParsablePoint) => {
//   if (point instanceof Point) {
//     return point;
//   }
//   if (Array.isArray(point)) {
//     if (point.length === 2) {
//       return new Point(point[0], point[1]);
//     }
//     return point;
//   }
//   if (typeof (point) === 'object') {
//     const keys = Object.keys(point);
//     if (keys.indexOf('x') > -1 && keys.indexOf('y') > -1) {
//       return new Point(point.x, point.y);
//     }
//   }
//   return point;
// };

/* eslint-disable no-use-before-define */

// There are lots of FlowFixMes in this file. This is not perfect, but
// haven't been able to come up with a quick work around. The problem statement
// is each function can accept as arguements either a full object definition
// or the definition split over parameters.
// The problem is then the first arguement can be so many types, some of which
// are subsets of the other, then when its parameters are extracted, their type
// is all confused.
var EquationFunctions =
/*#__PURE__*/
function () {
  // eslint-disable-next-line no-use-before-define
  // [methodName: string]: (TypeEquationPhrase) => {};
  // eslint-disable-next-line no-use-before-define
  function EquationFunctions(elements) {
    _classCallCheck(this, EquationFunctions);

    this.elements = elements;
    this.phrases = {};
    this.fullLineHeight = null;
  } // eslint-disable-next-line class-methods-use-this


  _createClass(EquationFunctions, [{
    key: "stringToElement",
    value: function stringToElement(content) {
      if (content.startsWith('space')) {
        var spaceNum = parseFloat(content.replace(/space[_]*/, '')) || 0.03;
        return new _Elements_Element__WEBPACK_IMPORTED_MODULE_2__["Element"](new _Elements_Element__WEBPACK_IMPORTED_MODULE_2__["BlankElement"](spaceNum));
      }

      var diagramElement = getDiagramElement(this.elements, content);

      if (diagramElement) {
        return new _Elements_Element__WEBPACK_IMPORTED_MODULE_2__["Element"](diagramElement);
      }

      if (content in this.phrases) {
        return this.parseContent(this.phrases[content]);
      }

      return null;
    }
  }, {
    key: "parseContent",
    value: function parseContent(content) {
      var _this = this;

      if (content == null) {
        return null;
      }

      if (typeof content === 'number') {
        return null;
      }

      if (content instanceof _Elements_Element__WEBPACK_IMPORTED_MODULE_2__["Elements"]) {
        return content;
      }

      if (typeof content === 'string') {
        return this.stringToElement(content);
      }

      if (Array.isArray(content)) {
        var elementArray = [];
        content.forEach(function (c) {
          var result = _this.parseContent(c);

          if (Array.isArray(result)) {
            elementArray = [].concat(_toConsumableArray(elementArray), _toConsumableArray(result));
          } else {
            elementArray.push(result);
          }
        });
        return elementArray;
      } // Otherwise its an object


      var _Object$entries$ = _slicedToArray(Object.entries(content)[0], 2),
          method = _Object$entries$[0],
          params = _Object$entries$[1]; // if (this[method] != null) {
      // return this[method](params);
      // }
      // $FlowFixMe


      return this.eqnMethod(method, params);
    }
  }, {
    key: "contentToElement",
    value: function contentToElement(content) {
      // If input is alread an Elements object, then return it
      if (content instanceof _Elements_Element__WEBPACK_IMPORTED_MODULE_2__["Elements"]) {
        return content._dup();
      }

      if (content instanceof _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementCollection"] || content instanceof _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"]) {
        return new _Elements_Element__WEBPACK_IMPORTED_MODULE_2__["Elements"]([new _Elements_Element__WEBPACK_IMPORTED_MODULE_2__["Element"](content)]);
      }

      var elementArray = this.parseContent(content);

      if (!Array.isArray(elementArray)) {
        elementArray = [elementArray];
      }

      return new _Elements_Element__WEBPACK_IMPORTED_MODULE_2__["Elements"](elementArray);
    }
  }, {
    key: "eqnMethod",
    value: function eqnMethod(name, params) {
      // $FlowFixMe
      if (name === 'frac') {
        return this.frac(params);
      } // $FlowFixMe


      if (name === 'strike') {
        return this.strike(params);
      } // $FlowFixMe


      if (name === 'brac') {
        return this.brac(params);
      } // $FlowFixMe


      if (name === 'sub') {
        return this.sub(params);
      } // $FlowFixMe


      if (name === 'sup') {
        return this.sup(params);
      } // $FlowFixMe


      if (name === 'supSub') {
        return this.supSub(params);
      } // $FlowFixMe


      if (name === 'topBar') {
        return this.topBar(params);
      } // $FlowFixMe


      if (name === 'bottomBar') {
        return this.bottomBar(params);
      } // $FlowFixMe


      if (name === 'annotate') {
        return this.annotate(params);
      } // $FlowFixMe


      if (name === 'annotation') {
        return this.annotation(params);
      } // $FlowFixMe


      if (name === 'bottomComment') {
        return this.bottomComment(params);
      } // $FlowFixMe


      if (name === 'topComment') {
        return this.topComment(params);
      } // $FlowFixMe


      if (name === 'topStrike') {
        return this.topStrike(params);
      } // $FlowFixMe


      if (name === 'bottomStrike') {
        return this.bottomStrike(params);
      } // $FlowFixMe


      if (name === 'pad') {
        return this.pad(params);
      }

      return null;
    }
  }, {
    key: "frac",
    value: function frac(optionsOrNum) {
      var den = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var sym = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var fractionScale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var numerator;
      var denominator;
      var symbol;
      var scale; // This is imperfect type checking, as the assumption is if den, sym
      // and fractionScale is null, then they weren't defined by the caller
      // and therefore the caller is passing in a TypeFracObject or TypeFracArray
      // All the flow errors go away if TypeEquationPhrase is removed from
      // optionsOrNum (and then also remove the first if statement below)

      if (!(den == null && sym == null && fractionScale == null)) {
        numerator = optionsOrNum;
        denominator = den;
        symbol = sym;
        scale = fractionScale;
      } else if (Array.isArray(optionsOrNum)) {
        // $FlowFixMe
        var _optionsOrNum = _slicedToArray(optionsOrNum, 4);

        numerator = _optionsOrNum[0];
        denominator = _optionsOrNum[1];
        symbol = _optionsOrNum[2];
        scale = _optionsOrNum[3];
      } else {
        numerator = optionsOrNum.numerator;
        denominator = optionsOrNum.denominator;
        symbol = optionsOrNum.symbol;
        scale = optionsOrNum.scale;
      }

      var f = new _Elements_Fraction__WEBPACK_IMPORTED_MODULE_3__["default"]( // $FlowFixMe
      this.contentToElement(numerator), // $FlowFixMe
      this.contentToElement(denominator), // $FlowFixMe
      getDiagramElement(this.elements, symbol));

      if (scale != null) {
        // $FlowFixMe
        f.scaleModifier = scale;
      }

      return f;
    }
  }, {
    key: "supSub",
    value: function supSub(optionsOrContent) {
      var sup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var sub = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var scriptScale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var supBias = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var subBias = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var content;
      var superscript = null;
      var subscript = null;
      var scale = null;
      var subscriptBias = null;
      var superscriptBias = null;

      if (!(sup == null && sub == null && scriptScale == null)) {
        content = optionsOrContent;
        superscript = sup;
        subscript = sub;
        scale = scriptScale;
        subscriptBias = subBias;
        superscriptBias = supBias;
      } else if (Array.isArray(optionsOrContent)) {
        // $FlowFixMe
        var _optionsOrContent = _slicedToArray(optionsOrContent, 6);

        content = _optionsOrContent[0];
        superscript = _optionsOrContent[1];
        subscript = _optionsOrContent[2];
        scale = _optionsOrContent[3];
        superscriptBias = _optionsOrContent[4];
        subscriptBias = _optionsOrContent[5];
      } else {
        content = optionsOrContent.content;
        superscript = optionsOrContent.superscript;
        subscript = optionsOrContent.subscript;
        scale = optionsOrContent.scale;
        superscriptBias = optionsOrContent.superscriptBias;
        subscriptBias = optionsOrContent.subscriptBias;
      }

      subscriptBias = subscriptBias == null ? null : Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["parsePoint"])( // $FlowFixMe
      subscriptBias, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
      superscriptBias = superscriptBias == null ? null : Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["parsePoint"])( // $FlowFixMe
      superscriptBias, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
      return new _Elements_SuperSub__WEBPACK_IMPORTED_MODULE_5__["default"]( // $FlowFixMe
      this.contentToElement(content), // $FlowFixMe
      this.contentToElement(superscript), // $FlowFixMe
      this.contentToElement(subscript), // $FlowFixMe
      scale, // $FlowFixMe
      superscriptBias, // $FlowFixMe
      subscriptBias);
    }
  }, {
    key: "sup",
    value: function sup(optionsOrContent) {
      var _sup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var scriptScale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var scriptBias = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var content;
      var superscript = null;
      var scale = null;
      var superscriptBias = null;

      if (!(_sup == null && scriptScale == null && scriptBias == null)) {
        content = optionsOrContent;
        superscript = _sup;
        scale = scriptScale;
        superscriptBias = scriptBias;
      } else if (Array.isArray(optionsOrContent)) {
        // $FlowFixMe
        var _optionsOrContent2 = _slicedToArray(optionsOrContent, 4);

        content = _optionsOrContent2[0];
        superscript = _optionsOrContent2[1];
        scale = _optionsOrContent2[2];
        superscriptBias = _optionsOrContent2[3];
      } else {
        content = optionsOrContent.content;
        superscript = optionsOrContent.superscript;
        scale = optionsOrContent.scale;
        superscriptBias = optionsOrContent.superscriptBias;
      }

      superscriptBias = superscriptBias == null ? null : Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["parsePoint"])( // $FlowFixMe
      superscriptBias, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
      return new _Elements_SuperSub__WEBPACK_IMPORTED_MODULE_5__["default"]( // $FlowFixMe
      this.contentToElement(content), // $FlowFixMe
      this.contentToElement(superscript), // $FlowFixMe
      null, // $FlowFixMe
      scale, // $FlowFixMe
      superscriptBias, // $FlowFixMe
      null);
    }
  }, {
    key: "sub",
    value: function sub(optionsOrContent) {
      var _sub = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var scriptScale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var scriptBias = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var content;
      var subscript = null;
      var scale = null;
      var subscriptBias = null;

      if (!(_sub == null && scriptScale == null && scriptBias == null)) {
        content = optionsOrContent;
        subscript = _sub;
        scale = scriptScale;
        subscriptBias = scriptBias;
      } else if (Array.isArray(optionsOrContent)) {
        // $FlowFixMe
        var _optionsOrContent3 = _slicedToArray(optionsOrContent, 4);

        content = _optionsOrContent3[0];
        subscript = _optionsOrContent3[1];
        scale = _optionsOrContent3[2];
        subscriptBias = _optionsOrContent3[3];
      } else {
        content = optionsOrContent.content;
        subscript = optionsOrContent.subscript;
        scale = optionsOrContent.scale;
        subscriptBias = optionsOrContent.subscriptBias;
      }

      subscriptBias = subscriptBias == null ? null : Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["parsePoint"])( // $FlowFixMe
      subscriptBias, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
      return new _Elements_SuperSub__WEBPACK_IMPORTED_MODULE_5__["default"]( // $FlowFixMe
      this.contentToElement(content), // $FlowFixMe
      null, // $FlowFixMe
      this.contentToElement(subscript), // $FlowFixMe
      scale, // $FlowFixMe
      null, // $FlowFixMe
      subscriptBias);
    }
  }, {
    key: "strike",
    value: function strike(optionsOrContent) // options: TypeStrikeObject | TypeStrikeArray) {
    {
      var sym = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var inSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var content;
      var symbol;
      var strikeInSize;

      if (!(sym == null && inSize == null)) {
        content = optionsOrContent;
        symbol = sym;
        strikeInSize = inSize;
      } else if (Array.isArray(optionsOrContent)) {
        // $FlowFixMe
        var _optionsOrContent4 = _slicedToArray(optionsOrContent, 3);

        content = _optionsOrContent4[0];
        symbol = _optionsOrContent4[1];
        strikeInSize = _optionsOrContent4[2];
      } else {
        content = optionsOrContent.content;
        symbol = optionsOrContent.symbol;
        strikeInSize = optionsOrContent.strikeInSize;
      }

      return new _Elements_Strike__WEBPACK_IMPORTED_MODULE_4__["default"]( // $FlowFixMe
      this.contentToElement(content), // $FlowFixMe
      getDiagramElement(this.elements, symbol), // $FlowFixMe
      strikeInSize);
    }
  }, {
    key: "annotate",
    value: function annotate(optionsOrContent) {
      var _this2 = this;

      var withAnnotationsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var includeAnnotationInSizeCalc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var content;
      var withAnnotations; // let withAnnotation;

      var includeAnnotationInSize;

      if (!(withAnnotationsArray == null && includeAnnotationInSizeCalc == null)) {
        content = optionsOrContent;
        withAnnotations = withAnnotationsArray;
        includeAnnotationInSize = includeAnnotationInSizeCalc;
      } else if (Array.isArray(optionsOrContent)) {
        var _optionsOrContent5 = _slicedToArray(optionsOrContent, 3);

        content = _optionsOrContent5[0];
        withAnnotations = _optionsOrContent5[1];
        includeAnnotationInSize = _optionsOrContent5[2];
      } else {
        content = optionsOrContent.content;
        withAnnotations = optionsOrContent.withAnnotations;
        includeAnnotationInSize = optionsOrContent.includeAnnotationInSize;
      }

      var annotations; // Case of single annotation in array form or array of annotations

      if (Array.isArray(withAnnotations)) {
        annotations = withAnnotations.map(function (annotation) {
          // annotation is an already instantiated AnnotationInformation
          if (annotation instanceof _Elements_Annotation__WEBPACK_IMPORTED_MODULE_8__["AnnotationInformation"]) {
            return annotation;
          }

          var parsedContent = _this2.parseContent(annotation); // case that annotation is a method object


          if (parsedContent instanceof _Elements_Annotation__WEBPACK_IMPORTED_MODULE_8__["AnnotationInformation"]) {
            return parsedContent;
          } // $FlowFixMe
          // Case of single annotation in array form


          if (Array.isArray(annotation)) {
            var annotationFromArray = _this2.annotation(annotation);

            if (annotationFromArray instanceof _Elements_Annotation__WEBPACK_IMPORTED_MODULE_8__["AnnotationInformation"]) {
              return annotationFromArray;
            }
          }

          return null;
        }); // Case of single annotation in array form

        if (annotations[0] === null) {
          // $FlowFixMe
          annotations = [this.annotation(withAnnotations)];
        } // Case of annotation as a Method Object, Method Array or
        // AnnotationInformation instantiation

      } else if (withAnnotations != null) {
        if (withAnnotations instanceof _Elements_Annotation__WEBPACK_IMPORTED_MODULE_8__["AnnotationInformation"]) {
          annotations = [withAnnotations];
        } else {
          var parsedContent = this.parseContent(withAnnotations); // Method Object

          if (parsedContent instanceof _Elements_Annotation__WEBPACK_IMPORTED_MODULE_8__["AnnotationInformation"]) {
            annotations = [parsedContent]; // Array form only
          } else {
            // $FlowFixMe
            annotations = [this.annotation(withAnnotations)];
          }
        }
      }

      var includeAnnotationInSizeToUse = true;

      if (includeAnnotationInSize != null) {
        includeAnnotationInSizeToUse = includeAnnotationInSize;
      }

      return new _Elements_Annotation__WEBPACK_IMPORTED_MODULE_8__["Annotation"]( // $FlowFixMe
      this.contentToElement(content), // $FlowFixMe
      annotations, // $FlowFixMe
      includeAnnotationInSizeToUse);
    }
  }, {
    key: "annotation",
    value: function annotation(optionsOrAnnotation) {
      var positionRelativeToContentH = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var positionRelativeToContentV = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var positionRelativeToAnnotationH = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var positionRelativeToAnnotationV = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var annotationScale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var annotation;
      var relativeToContentH;
      var relativeToContentV;
      var relativeToAnnotationH;
      var relativeToAnnotationV;
      var scale;

      if (!(positionRelativeToContentH == null && positionRelativeToContentV == null && positionRelativeToAnnotationH == null && positionRelativeToAnnotationV == null && annotationScale == null)) {
        annotation = optionsOrAnnotation;
        relativeToContentH = positionRelativeToContentH;
        relativeToContentV = positionRelativeToContentV;
        relativeToAnnotationH = positionRelativeToAnnotationH;
        relativeToAnnotationV = positionRelativeToAnnotationV;
        scale = annotationScale;
      } else if (Array.isArray(optionsOrAnnotation)) {
        var _optionsOrAnnotation = _slicedToArray(optionsOrAnnotation, 6);

        annotation = _optionsOrAnnotation[0];
        relativeToContentH = _optionsOrAnnotation[1];
        relativeToContentV = _optionsOrAnnotation[2];
        // $FlowFixMe
        relativeToAnnotationH = _optionsOrAnnotation[3];
        relativeToAnnotationV = _optionsOrAnnotation[4];
        scale = _optionsOrAnnotation[5];
      } else {
        var relativeToContent;
        var relativeToAnnotation;
        annotation = optionsOrAnnotation.annotation;
        relativeToContent = optionsOrAnnotation.relativeToContent;
        relativeToAnnotation = optionsOrAnnotation.relativeToAnnotation;
        scale = optionsOrAnnotation.scale;
        var _relativeToContent = relativeToContent;

        var _relativeToContent2 = _slicedToArray(_relativeToContent, 2);

        relativeToContentH = _relativeToContent2[0];
        relativeToContentV = _relativeToContent2[1];
        var _relativeToAnnotation = relativeToAnnotation;

        var _relativeToAnnotation2 = _slicedToArray(_relativeToAnnotation, 2);

        relativeToAnnotationH = _relativeToAnnotation2[0];
        relativeToAnnotationV = _relativeToAnnotation2[1];
      }

      var scaleToUse = 0.6;

      if (scale != null) {
        scaleToUse = scale;
      }

      return new _Elements_Annotation__WEBPACK_IMPORTED_MODULE_8__["AnnotationInformation"]( // $FlowFixMe
      this.contentToElement(annotation), // $FlowFixMe
      relativeToContentH, // $FlowFixMe
      relativeToContentV, // $FlowFixMe
      relativeToAnnotationH, // $FlowFixMe
      relativeToAnnotationV, // $FlowFixMe
      scaleToUse);
    }
  }, {
    key: "pad",
    value: function pad(optionsOrContent) {
      var topPad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var rightPad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var bottomPad = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var leftPad = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var content;
      var top;
      var right;
      var bottom;
      var left;

      if (!(topPad == null && rightPad == null && leftPad == null && bottomPad == null)) {
        content = optionsOrContent;
        top = topPad;
        left = leftPad;
        right = rightPad;
        bottom = bottomPad;
      } else if (Array.isArray(optionsOrContent)) {
        var _optionsOrContent6 = _slicedToArray(optionsOrContent, 5);

        // $FlowFixMe
        content = _optionsOrContent6[0];
        top = _optionsOrContent6[1];
        right = _optionsOrContent6[2];
        bottom = _optionsOrContent6[3];
        left = _optionsOrContent6[4];
      } else {
        content = optionsOrContent.content;
        top = optionsOrContent.top;
        right = optionsOrContent.right;
        bottom = optionsOrContent.bottom;
        left = optionsOrContent.left;
      }

      return new _Elements_Padding__WEBPACK_IMPORTED_MODULE_9__["default"]( // $FlowFixMe
      this.contentToElement(content), // $FlowFixMe
      top, // $FlowFixMe
      right, // $FlowFixMe
      bottom, // $FlowFixMe
      left);
    }
  }, {
    key: "brac",
    value: function brac(optionsOrContent) {
      var leftBracketString = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var rightBracketString = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var insideSpaceToContent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var outsideSpaceToContent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var useMinLineHeightForLine = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var bracketHeightScale = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
      var content;
      var left;
      var right;
      var insideSpace;
      var outsideSpace;
      var useMinLineHeight;
      var heightScale;

      if (!(leftBracketString == null && rightBracketString == null && insideSpaceToContent == null && outsideSpaceToContent == null && useMinLineHeightForLine == null)) {
        content = optionsOrContent;
        left = leftBracketString;
        right = rightBracketString;
        insideSpace = insideSpaceToContent;
        outsideSpace = outsideSpaceToContent;
        useMinLineHeight = useMinLineHeightForLine;
        heightScale = bracketHeightScale;
      } else if (Array.isArray(optionsOrContent)) {
        var _optionsOrContent7 = _slicedToArray(optionsOrContent, 7);

        // $FlowFixMe
        content = _optionsOrContent7[0];
        left = _optionsOrContent7[1];
        right = _optionsOrContent7[2];
        insideSpace = _optionsOrContent7[3];
        outsideSpace = _optionsOrContent7[4];
        // $FlowFixMe
        useMinLineHeight = _optionsOrContent7[5];
        heightScale = _optionsOrContent7[6];
      } else {
        content = optionsOrContent.content;
        left = optionsOrContent.left;
        right = optionsOrContent.right;
        insideSpace = optionsOrContent.insideSpace;
        outsideSpace = optionsOrContent.outsideSpace;
        useMinLineHeight = optionsOrContent.useMinLineHeight;
        heightScale = optionsOrContent.heightScale;
      }

      var leftBracket = null;

      if (left != null) {
        // $FlowFixMe
        leftBracket = getDiagramElement(this.elements, left);
      }

      var rightBracket = null;

      if (right != null) {
        // $FlowFixMe
        rightBracket = getDiagramElement(this.elements, right);
      }

      var insideSpaceToUse;

      if (insideSpace != null) {
        insideSpaceToUse = insideSpace;
      }

      var outsideSpaceToUse;

      if (outsideSpace != null) {
        outsideSpaceToUse = outsideSpace;
      }

      var minLineHeight = this.fullLineHeight;

      if (useMinLineHeight != null && useMinLineHeight === false) {
        minLineHeight = null;
      }

      var heightScaleToUse;

      if (heightScale != null) {
        heightScaleToUse = heightScale;
      }

      return new _Elements_Brackets__WEBPACK_IMPORTED_MODULE_6__["Brackets"]( // $FlowFixMe
      this.contentToElement(content), // $FlowFixMe
      leftBracket, // $FlowFixMe
      rightBracket, // $FlowFixMe
      insideSpaceToUse, // $FlowFixMe
      outsideSpaceToUse, minLineHeight, // $FlowFixMe
      heightScaleToUse);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "processBar",
    value: function processBar(optionsOrContent) {
      var sym = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var insideSpace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var content;
      var symbol;
      var space;

      if (!(sym == null && insideSpace == null)) {
        content = optionsOrContent;
        symbol = sym;
        space = insideSpace;
      } else if (Array.isArray(optionsOrContent)) {
        var _optionsOrContent8 = _slicedToArray(optionsOrContent, 3);

        content = _optionsOrContent8[0];
        symbol = _optionsOrContent8[1];
        space = _optionsOrContent8[2];
      } else {
        content = optionsOrContent.content;
        symbol = optionsOrContent.symbol;
        space = optionsOrContent.space;
      }

      var spaceToUse = 0.03;

      if (space != null) {
        spaceToUse = space;
      }

      return [content, symbol, spaceToUse];
    } // $FlowFixMe

  }, {
    key: "topBar",
    value: function topBar() {
      var _this$processBar = this.processBar.apply(this, arguments),
          _this$processBar2 = _slicedToArray(_this$processBar, 3),
          content = _this$processBar2[0],
          symbol = _this$processBar2[1],
          spaceToUse = _this$processBar2[2];

      return new _Elements_Brackets__WEBPACK_IMPORTED_MODULE_6__["Bar"]( // $FlowFixMe
      this.contentToElement(content), // $FlowFixMe
      getDiagramElement(this.elements, symbol), // $FlowFixMe
      spaceToUse, 0.03, 'top');
    } // $FlowFixMe

  }, {
    key: "bottomBar",
    value: function bottomBar() {
      var _this$processBar3 = this.processBar.apply(this, arguments),
          _this$processBar4 = _slicedToArray(_this$processBar3, 3),
          content = _this$processBar4[0],
          symbol = _this$processBar4[1],
          spaceToUse = _this$processBar4[2];

      return new _Elements_Brackets__WEBPACK_IMPORTED_MODULE_6__["Bar"]( // $FlowFixMe
      this.contentToElement(content), // $FlowFixMe
      getDiagramElement(this.elements, symbol), // $FlowFixMe
      spaceToUse, 0.03, 'bottom');
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "processComment",
    value: function processComment(optionsOrContent) {
      var commentString = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var sym = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var contSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var comSpace = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var comScale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var content;
      var comment;
      var symbol;
      var contentSpace;
      var commentSpace;
      var scale;

      if (!(commentString == null && sym == null && contSpace == null && comSpace == null && comScale == null)) {
        content = optionsOrContent;
        comment = commentString;
        symbol = sym;
        contentSpace = contSpace;
        commentSpace = comSpace;
        scale = comScale;
      } else if (Array.isArray(optionsOrContent)) {
        // $FlowFixMe
        var _optionsOrContent9 = _slicedToArray(optionsOrContent, 6);

        content = _optionsOrContent9[0];
        comment = _optionsOrContent9[1];
        symbol = _optionsOrContent9[2];
        contentSpace = _optionsOrContent9[3];
        commentSpace = _optionsOrContent9[4];
        scale = _optionsOrContent9[5];
      } else {
        content = optionsOrContent.content;
        comment = optionsOrContent.comment;
        symbol = optionsOrContent.symbol;
        contentSpace = optionsOrContent.contentSpace;
        commentSpace = optionsOrContent.commentSpace;
        scale = optionsOrContent.scale;
      }

      var contentSpaceToUse = 0.03;

      if (contentSpace != null) {
        contentSpaceToUse = contentSpace;
      }

      var commentSpaceToUse = 0.03;

      if (commentSpace != null) {
        commentSpaceToUse = commentSpace;
      }

      var scaleToUse = 0.6;

      if (scale != null) {
        scaleToUse = scale;
      }

      return [content, comment, symbol, contentSpaceToUse, commentSpaceToUse, scaleToUse];
    } // $FlowFixMe

  }, {
    key: "bottomComment",
    value: function bottomComment() {
      var _this$processComment = this.processComment.apply(this, arguments),
          _this$processComment2 = _slicedToArray(_this$processComment, 6),
          content = _this$processComment2[0],
          comment = _this$processComment2[1],
          symbol = _this$processComment2[2],
          contentSpaceToUse = _this$processComment2[3],
          commentSpaceToUse = _this$processComment2[4],
          scaleToUse = _this$processComment2[5];

      var contentToUse;

      if (symbol) {
        contentToUse = new _Elements_Brackets__WEBPACK_IMPORTED_MODULE_6__["Bar"]( // $FlowFixMe
        this.contentToElement(content), // $FlowFixMe
        getDiagramElement(this.elements, symbol), // $FlowFixMe
        contentSpaceToUse, // $FlowFixMe
        commentSpaceToUse, 'bottom');
      } else {
        contentToUse = this.pad( // $FlowFixMe
        content, 0, 0, contentSpaceToUse + commentSpaceToUse);
      }

      return this.annotate({
        // $FlowFixMe
        content: contentToUse,
        withAnnotations: [// $FlowFixMe
        this.annotation({
          annotation: comment,
          relativeToContent: ['center', 'bottom'],
          relativeToAnnotation: ['center', 'top'],
          scale: scaleToUse
        })]
      });
    } // $FlowFixMe

  }, {
    key: "topComment",
    value: function topComment() {
      var _this$processComment3 = this.processComment.apply(this, arguments),
          _this$processComment4 = _slicedToArray(_this$processComment3, 6),
          content = _this$processComment4[0],
          comment = _this$processComment4[1],
          symbol = _this$processComment4[2],
          contentSpaceToUse = _this$processComment4[3],
          commentSpaceToUse = _this$processComment4[4],
          scaleToUse = _this$processComment4[5];

      var contentToUse;

      if (symbol) {
        contentToUse = new _Elements_Brackets__WEBPACK_IMPORTED_MODULE_6__["Bar"]( // $FlowFixMe
        this.contentToElement(content), // $FlowFixMe
        getDiagramElement(this.elements, symbol), // $FlowFixMe
        contentSpaceToUse, // $FlowFixMe
        commentSpaceToUse, 'top');
      } else {
        contentToUse = this.pad( // $FlowFixMe
        content, contentSpaceToUse + commentSpaceToUse);
      }

      return this.annotate({
        // $FlowFixMe
        content: contentToUse,
        withAnnotations: [// $FlowFixMe
        this.annotation({
          annotation: comment,
          relativeToContent: ['center', 'top'],
          relativeToAnnotation: ['center', 'bottom'],
          scale: scaleToUse
        })]
      });
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "processStrike",
    value: function processStrike(optionsOrContent) {
      var commentString = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var sym = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var comSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var comScale = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var content;
      var comment;
      var symbol;
      var space;
      var scale;

      if (!(commentString == null && sym == null && comSpace == null && comScale == null)) {
        content = optionsOrContent;
        comment = commentString;
        symbol = sym;
        space = comSpace;
        scale = comScale;
      } else if (Array.isArray(optionsOrContent)) {
        // $FlowFixMe
        var _optionsOrContent10 = _slicedToArray(optionsOrContent, 5);

        content = _optionsOrContent10[0];
        comment = _optionsOrContent10[1];
        symbol = _optionsOrContent10[2];
        space = _optionsOrContent10[3];
        scale = _optionsOrContent10[4];
      } else {
        content = optionsOrContent.content;
        comment = optionsOrContent.comment;
        symbol = optionsOrContent.symbol;
        space = optionsOrContent.space;
        scale = optionsOrContent.scale;
      }

      var spaceToUse = 0.1;

      if (space != null) {
        spaceToUse = space;
      }

      var scaleToUse = 0.5;

      if (scale != null) {
        scaleToUse = scale;
      }

      return [content, comment, symbol, spaceToUse, scaleToUse];
    } // $FlowFixMe

  }, {
    key: "topStrike",
    value: function topStrike() {
      var _this$processStrike = this.processStrike.apply(this, arguments),
          _this$processStrike2 = _slicedToArray(_this$processStrike, 5),
          content = _this$processStrike2[0],
          comment = _this$processStrike2[1],
          symbol = _this$processStrike2[2],
          spaceToUse = _this$processStrike2[3],
          scaleToUse = _this$processStrike2[4];

      var contentToUse;

      if (symbol) {
        contentToUse = new _Elements_Strike__WEBPACK_IMPORTED_MODULE_4__["default"]( // $FlowFixMe
        this.contentToElement(content), // $FlowFixMe
        getDiagramElement(this.elements, symbol), // $FlowFixMe
        false, // $FlowFixMe
        spaceToUse);
      } else {
        contentToUse = content;
      }

      return this.annotate({
        // $FlowFixMe
        content: contentToUse,
        withAnnotations: [// $FlowFixMe
        this.annotation({
          annotation: comment,
          relativeToContent: ['center', 'top'],
          relativeToAnnotation: ['center', 'bottom'],
          scale: scaleToUse
        })]
      });
    } // $FlowFixMe

  }, {
    key: "bottomStrike",
    value: function bottomStrike() {
      var _this$processStrike3 = this.processStrike.apply(this, arguments),
          _this$processStrike4 = _slicedToArray(_this$processStrike3, 5),
          content = _this$processStrike4[0],
          comment = _this$processStrike4[1],
          symbol = _this$processStrike4[2],
          spaceToUse = _this$processStrike4[3],
          scaleToUse = _this$processStrike4[4];

      var contentToUse;

      if (symbol) {
        contentToUse = new _Elements_Strike__WEBPACK_IMPORTED_MODULE_4__["default"]( // $FlowFixMe
        this.contentToElement(content), // $FlowFixMe
        getDiagramElement(this.elements, symbol), // $FlowFixMe
        false, // $FlowFixMe
        spaceToUse);
      } else {
        contentToUse = content;
      }

      return this.annotate({
        // $FlowFixMe
        content: contentToUse,
        withAnnotations: [// $FlowFixMe
        this.annotation({
          annotation: comment,
          relativeToContent: ['center', 'bottom'],
          relativeToAnnotation: ['center', 'top'],
          scale: scaleToUse
        })]
      });
    }
  }]);

  return EquationFunctions;
}();

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/EquationSymbols.js":
/*!********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/EquationSymbols.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EquationSymbols; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _DiagramPrimatives_DiagramPrimatives__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../DiagramPrimatives/DiagramPrimatives */ "./src/js/diagram/DiagramPrimatives/DiagramPrimatives.js");
/* harmony import */ var _Symbols_Integral__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Symbols/Integral */ "./src/js/diagram/DiagramElements/Equation/Symbols/Integral.js");
/* harmony import */ var _Symbols_Bracket__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Symbols/Bracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/Bracket.js");
/* harmony import */ var _Symbols_RoundedSquareBracket__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Symbols/RoundedSquareBracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/RoundedSquareBracket.js");
/* harmony import */ var _Symbols_Bar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Symbols/Bar */ "./src/js/diagram/DiagramElements/Equation/Symbols/Bar.js");
/* harmony import */ var _Symbols_Brace__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Symbols/Brace */ "./src/js/diagram/DiagramElements/Equation/Symbols/Brace.js");
/* harmony import */ var _Symbols_SquareBracket__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Symbols/SquareBracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/SquareBracket.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




 // import SuperSub from './Elements/SuperSub';





 // import { Annotation, AnnotationInformation } from './Elements/Annotation';

var EquationSymbols =
/*#__PURE__*/
function () {
  function EquationSymbols(shapes, defaultColor) {
    _classCallCheck(this, EquationSymbols);

    this.shapes = shapes;
    this.defaultColor = defaultColor;
  }

  _createClass(EquationSymbols, [{
    key: "get",
    value: function get(name, options) {
      if (name === 'vinculum') {
        return this.vinculum(options);
      }

      if (name === 'strike') {
        return this.strike(options);
      }

      if (name === 'xStrike') {
        return this.xStrike(options);
      }

      if (name === 'integral') {
        return this.integral(options);
      }

      if (name === 'bracket') {
        return this.bracket(options);
      }

      if (name === 'squareBracket') {
        return this.squareBracket(options);
      }

      if (name === 'brace') {
        return this.brace(options);
      }

      if (name === 'bar') {
        return this.bar(options);
      }

      if (name === 'roundedSquareBracket') {
        return this.roundedSquareBracket(options);
      }

      return null;
    }
  }, {
    key: "vinculum",
    value: function vinculum() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var color = options.color;

      if (color == null) {
        color = this.defaultColor;
      }

      return this.shapes.horizontalLine(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), 1, 1, 0, color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('vinculum').scale(1, 1).translate(0, 0));
    }
  }, {
    key: "strike",
    value: function strike() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var color = options.color;

      if (color == null) {
        color = this.defaultColor;
      }

      return this.shapes.horizontalLine(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), 1, 1, 0, color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('strike').scale(1, 1).rotate(0).translate(0, 0));
    }
  }, {
    key: "xStrike",
    value: function xStrike() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var color = options.color;

      if (color == null) {
        color = this.defaultColor;
      }

      var cross = this.shapes.collection(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('xStrike').scale(1, 1).rotate(0).translate(0, 0));
      cross.color = color;
      var strike1 = this.shapes.horizontalLine(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), 1, 1, 0, color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('strikeLine').scale(1, 1).rotate(0).translate(0, 0));

      var strike2 = strike1._dup();

      cross.add('s1', strike1);
      cross.add('s2', strike2);
      return cross;
    }
  }, {
    key: "integral",
    value: function integral(options) {
      var defaultOptions = {
        color: this.defaultColor,
        numLines: 1
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Integral__WEBPACK_IMPORTED_MODULE_3__["default"](this.shapes.webgl, optionsToUse.color, optionsToUse.numLines, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('integral').scale(1, 1).translate(0, 0), this.shapes.limits);
    }
  }, {
    key: "bracket",
    value: function bracket(options) {
      var defaultOptions = {
        side: 'left',
        numLines: 1,
        color: this.defaultColor
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Bracket__WEBPACK_IMPORTED_MODULE_4__["default"](this.shapes.webgl, optionsToUse.color, optionsToUse.side, optionsToUse.numLines, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('bracket').scale(1, 1).translate(0, 0), this.shapes.limits);
    }
  }, {
    key: "bar",
    value: function bar(options) {
      var defaultOptions = {
        side: 'top',
        numLines: 1,
        color: this.defaultColor
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Bar__WEBPACK_IMPORTED_MODULE_6__["default"](this.shapes.webgl, optionsToUse.color, optionsToUse.side, optionsToUse.numLines, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('bar').scale(1, 1).translate(0, 0), this.shapes.limits);
    }
  }, {
    key: "squareBracket",
    value: function squareBracket(options) {
      var defaultOptions = {
        side: 'left',
        numLines: 1,
        color: this.defaultColor
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_SquareBracket__WEBPACK_IMPORTED_MODULE_8__["default"](this.shapes.webgl, optionsToUse.color, optionsToUse.side, optionsToUse.numLines, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('bar').scale(1, 1).translate(0, 0), this.shapes.limits);
    }
  }, {
    key: "brace",
    value: function brace(options) {
      var defaultOptions = {
        side: 'left',
        numLines: 1,
        color: this.defaultColor
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Brace__WEBPACK_IMPORTED_MODULE_7__["default"](this.shapes.webgl, optionsToUse.color, optionsToUse.side, optionsToUse.numLines, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('bar').scale(1, 1).translate(0, 0), this.shapes.limits);
    }
  }, {
    key: "roundedSquareBracket",
    value: function roundedSquareBracket(options) {
      var defaultOptions = {
        side: 'left',
        numLines: 1,
        color: this.defaultColor
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_RoundedSquareBracket__WEBPACK_IMPORTED_MODULE_5__["default"](this.shapes.webgl, optionsToUse.color, optionsToUse.side, optionsToUse.numLines, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('bar').scale(1, 1).translate(0, 0), this.shapes.limits);
    }
  }]);

  return EquationSymbols;
}();



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/GLEquation.js":
/*!***************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/GLEquation.js ***!
  \***************************************************************/
/*! exports provided: getDiagramElement, createEquationElements, contentToElement, Equation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDiagramElement", function() { return getDiagramElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEquationElements", function() { return createEquationElements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "contentToElement", function() { return contentToElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Equation", function() { return Equation; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _tools_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../tools/color */ "./src/js/tools/color.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../DrawingObjects/TextObject/TextObject */ "./src/js/diagram/DrawingObjects/TextObject/TextObject.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../DrawContext2D */ "./src/js/diagram/DrawContext2D.js");
/* harmony import */ var _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../tools/htmlGenerator */ "./src/js/tools/htmlGenerator.js");
/* harmony import */ var _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../DrawingObjects/HTMLObject/HTMLObject */ "./src/js/diagram/DrawingObjects/HTMLObject/HTMLObject.js");
/* harmony import */ var _Elements_Element__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Elements/Element */ "./src/js/diagram/DiagramElements/Equation/Elements/Element.js");
/* harmony import */ var _Elements_Fraction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Elements/Fraction */ "./src/js/diagram/DiagramElements/Equation/Elements/Fraction.js");
/* harmony import */ var _Elements_Strike__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Elements/Strike */ "./src/js/diagram/DiagramElements/Equation/Elements/Strike.js");
/* harmony import */ var _Elements_SuperSub__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Elements/SuperSub */ "./src/js/diagram/DiagramElements/Equation/Elements/SuperSub.js");
/* harmony import */ var _Elements_Brackets__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Elements/Brackets */ "./src/js/diagram/DiagramElements/Equation/Elements/Brackets.js");
/* harmony import */ var _Elements_Annotation__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Elements/Annotation */ "./src/js/diagram/DiagramElements/Equation/Elements/Annotation.js");
/* harmony import */ var _EquationForm__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./EquationForm */ "./src/js/diagram/DiagramElements/Equation/EquationForm.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

// Deprecate
 // import { roundNum } from '../../../tools/math';






 // import { TextObject } from './DrawingObjects/TextObject/TextObject';







 // // Equation is a class that takes a set of drawing objects (TextObjects,
// // DiagramElementPrimatives or DiagramElementCollections and HTML Objects
// // and arranges their size in a )


function getDiagramElement(collection, name) {
  if (typeof name === 'string') {
    if (collection && "_".concat(name) in collection) {
      // $FlowFixMe
      return collection["_".concat(name)];
    }

    return null;
  }

  return name;
}
function createEquationElements(elems, drawContext2D) {
  var colorOrFont = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var diagramLimits = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2);
  var firstTransform = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
  var existingCollection = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
  var color = [1, 1, 1, 1];

  if (Array.isArray(colorOrFont)) {
    color = colorOrFont.slice();
  }

  var font = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_4__["DiagramFont"]('Times New Roman', 'normal', 0.2, '200', 'left', 'alphabetic', color);
  var fontItalic = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_4__["DiagramFont"]('Times New Roman', 'italic', 0.2, '200', 'left', 'alphabetic', color);

  if (colorOrFont instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_4__["DiagramFont"]) {
    font = colorOrFont._dup();
    font.style = 'normal';
    fontItalic = colorOrFont._dup();
    fontItalic.style = 'italic';

    if (font.color != null) {
      color = Object(_tools_color__WEBPACK_IMPORTED_MODULE_2__["RGBToArray"])(font.color);
    }
  }

  var collection;

  if (existingCollection != null) {
    collection = existingCollection;
  } else {
    collection = new _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementCollection"](new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Equation Elements Collection').scale(1, 1).rotate(0).translate(0, 0), diagramLimits);
  }

  var makeElem = function makeElem(text, fontOrStyle) {
    var fontToUse = font;

    if (fontOrStyle instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_4__["DiagramFont"]) {
      fontToUse = fontOrStyle;
    } else if (fontOrStyle === 'italic') {
      fontToUse = fontItalic;
    } else if (fontOrStyle === 'normal') {
      fontToUse = font;
    } else if (text.match(/[A-Z,a-z]/)) {
      fontToUse = fontItalic;
    }

    var dT = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_4__["DiagramText"](new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), text, fontToUse);
    var to = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_4__["TextObject"](drawContext2D, [dT]);
    var p = new _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementPrimative"](to, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Equation Element').scale(1, 1).translate(0, 0), color, diagramLimits);
    return p;
  };

  Object.keys(elems).forEach(function (key) {
    if (typeof elems[key] === 'string') {
      if (!key.startsWith('space')) {
        collection.add(key, makeElem(elems[key], null));
      }
    } else if (elems[key] instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementPrimative"]) {
      collection.add(key, elems[key]);
    } else if (elems[key] instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementCollection"]) {
      collection.add(key, elems[key]);
    } else if (Array.isArray(elems[key])) {
      var _elems$key = _slicedToArray(elems[key], 7),
          text = _elems$key[0],
          col = _elems$key[1],
          isTouchable = _elems$key[2],
          onClick = _elems$key[3],
          direction = _elems$key[4],
          mag = _elems$key[5],
          fontOrStyle = _elems$key[6];

      var elem = makeElem(text, fontOrStyle);

      if (col) {
        elem.setColor(col);
      }

      if (isTouchable) {
        elem.isTouchable = isTouchable;
      }

      if (onClick) {
        elem.onClick = onClick;
      }

      if (direction) {
        elem.animate.transform.translation.style = 'curved';
        elem.animate.transform.translation.options.direction = direction;
      }

      if (mag) {
        elem.animate.transform.translation.style = 'curved';
        elem.animate.transform.translation.options.magnitude = mag;
      }

      collection.add(key, elem);
    } else {
      var _elems$key2 = elems[key],
          _text = _elems$key2.text,
          _isTouchable = _elems$key2.isTouchable,
          _onClick = _elems$key2.onClick,
          _direction = _elems$key2.direction,
          _mag = _elems$key2.mag,
          _fontOrStyle = _elems$key2.fontOrStyle,
          drawPriority = _elems$key2.drawPriority;

      var _col;

      if (elems[key].color) {
        _col = elems[key].color;
      }

      var _elem = makeElem(_text, _fontOrStyle);

      if (_col != null) {
        _elem.setColor(_col);
      }

      if (_isTouchable != null) {
        _elem.isTouchable = _isTouchable;
      }

      if (_onClick) {
        _elem.onClick = _onClick;
      }

      if (_direction != null) {
        _elem.animate.transform.translation.style = 'curved';
        _elem.animate.transform.translation.options.direction = _direction;
      }

      if (drawPriority != null) {
        _elem.drawPriority = drawPriority;
      }

      if (_mag != null) {
        _elem.animate.transform.translation.style = 'curved';
        _elem.animate.transform.translation.options.magnitude = _mag;
      }

      collection.add(key, _elem);
    }
  });
  collection.setFirstTransform(firstTransform);
  return collection;
}
function contentToElement(collection, content) {
  // If input is alread an Elements object, then return it
  if (content instanceof _Elements_Element__WEBPACK_IMPORTED_MODULE_8__["Elements"]) {
    // const namedElements = {};
    // collection.getAllElements().forEach((element) => {
    //   namedElements[element.name] = element;
    // });
    return content._dup();
  } // If it is not an Elements object, then create an Element(s) array
  // and create a new Elements Object


  var elementArray = []; // If the content is a string, then find the corresponding
  // DiagramElement associated with the string

  if (typeof content === 'string') {
    if (content.startsWith('space')) {
      var spaceNum = parseFloat(content.replace(/space[_]*/, '')) || 0.03;
      elementArray.push(new _Elements_Element__WEBPACK_IMPORTED_MODULE_8__["Element"](new _Elements_Element__WEBPACK_IMPORTED_MODULE_8__["BlankElement"](spaceNum)));
    } else {
      var diagramElement = getDiagramElement(collection, content);

      if (diagramElement) {
        elementArray.push(new _Elements_Element__WEBPACK_IMPORTED_MODULE_8__["Element"](diagramElement));
      }
    } // Otherwise, if the input content is an array, then process each element
    // and add it to the ElementArray

  } else if (Array.isArray(content)) {
    content.forEach(function (c) {
      if (typeof c === 'string') {
        if (c.startsWith('space')) {
          var _spaceNum = parseFloat(c.replace(/space[_]*/, '')) || 0.03;

          elementArray.push(new _Elements_Element__WEBPACK_IMPORTED_MODULE_8__["Element"](new _Elements_Element__WEBPACK_IMPORTED_MODULE_8__["BlankElement"](_spaceNum)));
        } else {
          var _diagramElement = getDiagramElement(collection, c);

          if (_diagramElement) {
            elementArray.push(new _Elements_Element__WEBPACK_IMPORTED_MODULE_8__["Element"](_diagramElement));
          }
        }
      } else if (c !== null) {
        elementArray.push(c);
      }
    }); // Otherwise, if the input is an Element or Elements object, so just add
    // it to the ElementsArray
  } else if (content !== null) {
    elementArray.push(content);
  }

  return new _Elements_Element__WEBPACK_IMPORTED_MODULE_8__["Elements"](elementArray);
} // export type TypeHAlign = 'left' | 'right' | 'center';
// export type TypeVAlign = 'top' | 'bottom' | 'middle' | 'baseline';
// export type TypeEquationForm = {
//   collection: DiagramElementCollection;
//   createEq: (Array<Elements | Element | string>) => void;
//   arrange: (
//     number, TypeHAlign | null, TypeVAlign | null,
//     DiagramElementPrimative | DiagramElementCollection | Point
//   ) => void;
//   dissolveElements: (
//     Array<DiagramElementPrimative | DiagramElementCollection>,
//     boolean, number, number, ?(?boolean)) => void;
//   getElementsToShowAndHide: () => void;
//   showHide: (number, number, ?(?mixed)) => void;
//   hideShow: (number, number, ?(?mixed)) => void;
//   // animateTo: (
//   //   number, number,
//   //   DiagramElementPrimative | DiagramElementCollection | Point,
//   //   ?(?mixed) => void,
//   //   'left' | 'center' | 'right', 'top' | 'bottom' | 'middle' | 'baseline',
//   // ) => void;
//   animatePositionsTo: (number, ?(?mixed) => void) => void;
//   description: string | null;
//   modifiers: Object;
//   type: string;
//   elementMods: Object;
//   time: number | null;
// } & Elements;
// export class EquationForm extends Elements {
//   collection: DiagramElementCollection;
//   name: string;
//   type: string;
//   description: string | null;
//   modifiers: Object;
//   elementMods: Object;
//   time: number | null;
//   constructor(collection: DiagramElementCollection) {
//     super([]);
//     this.collection = collection;
//     this.description = null;
//     this.modifiers = {};
//     this.elementMods = {};
//     this.time = null;
//   }
//   getNamedElements() {
//     const namedElements = {};
//     this.collection.getAllElements().forEach((element) => {
//       namedElements[element.name] = element;
//     });
//     return namedElements;
//   }
//   _dup(collection: DiagramElementCollection = this.collection) {
//     const equationCopy = new EquationForm(collection);
//     const namedElements = {};
//     collection.getAllElements().forEach((element) => {
//       namedElements[element.name] = element;
//     });
//     const newContent = [];
//     this.content.forEach((contentElement) => {
//       newContent.push(contentElement._dup(namedElements));
//     });
//     equationCopy.content = newContent;
//     duplicateFromTo(this, equationCopy, ['content', 'collection', 'form']);
//     return equationCopy;
//   }
//   createEq(content: Array<Elements | Element | string>) {
//     const elements = [];
//     content.forEach((c) => {
//       if (typeof c === 'string') {
//         if (c.startsWith('space')) {
//           const spaceNum = parseFloat(c.replace(/space[_]*/, '')) || 0.03;
//           elements.push(new Element(new BlankElement(spaceNum)));
//         } else {
//           const diagramElement = getDiagramElement(this.collection, c);
//           if (diagramElement) {
//             elements.push(new Element(diagramElement));
//           }
//         }
//       } else {
//         elements.push(c._dup());
//       }
//       this.content = elements;
//     });
//   }
//   // An Equation collection is a flat collection of DiagramElements.
//   //
//   // The form determines how elements are positioned relative to each other.
//   //
//   // A form of an equation takes the form's elements (a subset of the
//   // collection) and applies a translation and scale transformation. This
//   // aligns all the elements of a form relative to each other to render
//   // the desired form.
//   //
//   // Arranging a form of an equation goes through each element in the form
//   // and positions and scales it in the equation's vertex space.
//   // It also saves the locaiton and scale information in the form's element
//   // property.
//   //
//   // The elements are positioned relative to 0,0 in vertex space based on the
//   // fixTo, alignH and alignV parameters.
//   //
//   // fixTo can only be a point in the equation's vertex space, or a
//   // DiagramElement in the equation.
//   //
//   // If fixTo is an element in the equation:
//   //    - the fixTo element is positioned at 0, 0, and all other elements
//   //      repositioned relative to that.
//   //    - The equation collection setPosition (or translation transform) can
//   //      then be used to position the equation in the diagram (or relative
//   //      collection space)
//   //    - if alignH is:
//   //        - 'middle': the fixTo element is centered in x around (0, 0)
//   //        - 'right': the fixTo element right most point is at x = 0
//   //        - 'left': default - the fixTo element x position at 0
//   //    - if alignV is:
//   //        - 'center': the fixTo element is centered in y around (0, 0)
//   //        - 'bottom': the fixTo element bottom most point is at y = 0
//   //        - 'top': the fixTo element top most point is at y = 0
//   //        - 'baseline': default - the fixTo element y position at 0
//   //
//   // If fixTo is a Point, the equation is positioned at that point in the
//   // equation's vertex space.
//   //  - alignH:
//   //    - 'left': The equation's left most element's left most point is at
//   //              Point.x
//   //    - 'right': The equation's right most element's right most point is at
//   //              Point.x
//   //    - 'center': The equation is centered horizontally around Point.x
//   //  - alignV:
//   //    - 'baseline': The equation's baseline is at Point.y
//   //    - 'top': The equation's top most element's top most point is at Point.y
//   //    - 'bottom': The equation's top most element's top most point is at
//   //                Point.y
//   //    - 'middle': The equation is centered vertically around Point.y
//   //
//   arrange(
//     scale: number = 1,
//     alignH: TypeHAlign | null = 'left',
//     alignV: TypeVAlign | null = 'baseline',
//     fixTo: DiagramElementPrimative | DiagramElementCollection | Point = new Point(0, 0),
//   ) {
//     const elementsInCollection = this.collection.getAllElements();
//     const elementsCurrentlyShowing = elementsInCollection.filter(e => e.isShown);
//     this.collection.hideAll();
//     this.collection.show();
//     super.calcSize(new Point(0, 0), scale);
//     let fixPoint = new Point(0, 0);
//     if (fixTo instanceof DiagramElementPrimative
//         || fixTo instanceof DiagramElementCollection) {
//       const t = fixTo.transform.t();
//       if (t != null) {
//         fixPoint = t._dup();
//       }
//     } else {
//       fixPoint = new Point(-fixTo.x, -fixTo.y);
//     }
//     let w = this.width;
//     let h = this.height;
//     let a = this.ascent;
//     let d = this.descent;
//     let p = this.location._dup();
//     if (fixTo instanceof DiagramElementPrimative
//         || fixTo instanceof DiagramElementCollection) {
//       const t = fixTo.transform.t();
//       const s = fixTo.transform.s();
//       if (t != null && s != null) {
//         const rect = fixTo.getVertexSpaceBoundingRect();
//         w = rect.width * s.x;
//         h = rect.height * s.y;
//         a = rect.top * s.y - t.y;
//         d = t.y - rect.bottom * s.y;
//         p = t._dup();
//       }
//     }
//     if (alignH === 'right') {
//       fixPoint.x += w;
//     } else if (alignH === 'center') {
//       fixPoint.x += w / 2;
//     }
//     if (alignV === 'top') {
//       fixPoint.y += p.y + a;
//     } else if (alignV === 'bottom') {
//       fixPoint.y += p.y - d;
//     } else if (alignV === 'middle') {
//       fixPoint.y += p.y - d + h / 2;
//     }
//     const delta = new Point(0, 0).sub(fixPoint);
//     if (delta.x !== 0 || delta.y !== 0) {
//       this.offsetLocation(delta);
//       this.setPositions();
//     }
//     this.collection.showOnly(elementsCurrentlyShowing);
//   }
//   // eslint-disable-next-line class-methods-use-this
//   dissolveElements(
//     elements: Array<DiagramElementPrimative | DiagramElementCollection>,
//     disolve: 'in' | 'out' = 'in',
//     delay: number = 0.01,
//     time: number = 1,
//     callback: ?(boolean) => void = null,
//   ) {
//     if (elements.length === 0) {
//       if (callback) {
//         callback(false);
//         return;
//       }
//     }
//     const count = elements.length;
//     let completed = 0;
//     const end = (cancelled: boolean) => {
//       completed += 1;
//       if (completed === count) {
//         if (callback) {
//           callback(cancelled);
//         }
//       }
//     };
//     elements.forEach((e) => {
//       e.disolveWithDelay(delay, time, disolve, end);
//     });
//   }
//   getElementsToShowAndHide() {
//     const allElements = this.collection.getAllElements();
//     const elementsShown = allElements.filter(e => e.isShown);
//     const elementsShownTarget = this.getAllElements();
//     const elementsToHide =
//       elementsShown.filter(e => elementsShownTarget.indexOf(e) === -1);
//     const elementsToShow =
//       elementsShownTarget.filter(e => elementsShown.indexOf(e) === -1);
//     return {
//       show: elementsToShow,
//       hide: elementsToHide,
//     };
//   }
//   render() {
//     this.hideShow();
//     this.setPositions();
//   }
//   showHide(
//     showTime: number = 0,
//     hideTime: number = 0,
//     callback: ?(?mixed) => void = null,
//   ) {
//     this.collection.stop();
//     this.collection.show();
//     const { show, hide } = this.getElementsToShowAndHide();
//     if (showTime === 0) {
//       show.forEach((e) => {
//         e.showAll();
//       });
//     } else {
//       this.dissolveElements(show, 'in', 0.01, showTime, null);
//     }
//     if (hideTime === 0) {
//       hide.forEach(e => e.hide());
//     } else {
//       this.dissolveElements(hide, 'out', showTime, hideTime, callback);
//     }
//   }
//   hideShow(
//     showTime: number = 0,
//     hideTime: number = 0,
//     callback: ?(?mixed) => void = null,
//   ) {
//     this.collection.stop();
//     this.collection.show();
//     const { show, hide } = this.getElementsToShowAndHide();
//     if (hideTime === 0) {
//       hide.forEach(e => e.hide());
//     } else {
//       this.dissolveElements(hide, 'out', 0.01, hideTime, null);
//     }
//     if (showTime === 0) {
//       show.forEach((e) => {
//         e.showAll();
//       });
//       if (callback != null) {
//         callback();
//       }
//     } else {
//       this.dissolveElements(show, 'in', hideTime, showTime, callback);
//     }
//   }
//   allHideShow(
//     delay: number = 0,
//     hideTime: number = 0.5,
//     blankTime: number = 0.5,
//     showTime: number = 0.5,
//     callback: ?(boolean) => void = null,
//   ) {
//     this.collection.stop();
//     const allElements = this.collection.getAllElements();
//     const elementsShown = allElements.filter(e => e.isShown);
//     const elementsToShow = this.getAllElements();
//     const elementsToDelayShowing = elementsToShow.filter(e => !e.isShown);
//     const elementsToShowAfterDisolve = elementsToShow.filter(e => e.isShown);
//     let cumTime = delay;
//     if (elementsToShow.length === 0 && elementsShown.length === 0) {
//       if (callback != null) {
//         callback(false);
//         return;
//       }
//     }
//     // disolve out
//     // set positions
//     // disolve in
//     let disolveOutCallback = () => {
//       this.setPositions();
//     };
//     if (elementsToShow.length === 0) {
//       disolveOutCallback = (cancelled: boolean) => {
//         this.setPositions();
//         if (callback != null) {
//           callback(cancelled);
//         }
//       };
//     }
//     if (elementsShown.length > 0) {
//       this.dissolveElements(
//         elementsShown, 'out', delay, hideTime, disolveOutCallback,
//       );
//       cumTime += hideTime;
//     } else {
//       this.setPositions();
//     }
//     const count = elementsToShow.length;
//     let completed = 0;
//     const end = (cancelled: boolean) => {
//       completed += 1;
//       if (completed === count - 1) {
//         if (callback) {
//           callback(cancelled);
//         }
//       }
//     };
//     elementsToDelayShowing.forEach((e) => {
//       e.disolveWithDelay(cumTime + blankTime, showTime, 'in', end);
//     });
//     elementsToShowAfterDisolve.forEach((e) => {
//       e.disolveWithDelay(blankTime, showTime, 'in', end);
//     });
//   }
//   animatePositionsTo(
//     delay: number,
//     disolveOutTime: number,
//     moveTime: number | null,
//     disolveInTime: number,
//     callback: ?(?mixed) => void = null,
//   ) {
//     const allElements = this.collection.getAllElements();
//     this.collection.stop();
//     const elementsShown = allElements.filter(e => e.isShown);
//     const elementsShownTarget = this.getAllElements();
//     const elementsToHide =
//       elementsShown.filter(e => elementsShownTarget.indexOf(e) === -1);
//     const elementsToShow =
//       elementsShownTarget.filter(e => elementsShown.indexOf(e) === -1);
//     const currentTransforms = this.collection.getElementTransforms();
//     this.setPositions();
//     const animateToTransforms = this.collection.getElementTransforms();
//     const elementsToMove = [];
//     const toMoveStartTransforms = [];
//     const toMoveStopTransforms = [];
//     Object.keys(animateToTransforms).forEach((key) => {
//       const currentT = currentTransforms[key];
//       const nextT = animateToTransforms[key];
//       if (!currentT.isEqualTo(nextT)) {
//         elementsToMove.push(key);
//         toMoveStartTransforms.push(currentT);
//         toMoveStopTransforms.push(nextT);
//       }
//     });
//     // Find move time to use. If moveTime is null, then a velocity is used.
//     let moveTimeToUse;
//     if (moveTime === null) {
//       moveTimeToUse = getMoveTime(
//         toMoveStartTransforms, toMoveStopTransforms, 0,
//         new Point(0.35, 0.35),      // 0.25 diagram space per s
//         2 * Math.PI / 6,            // 60º per second
//         new Point(0.4, 0.4),            // 100% per second
//       );
//     } else {
//       moveTimeToUse = moveTime;
//     }
//     this.collection.setElementTransforms(currentTransforms);
//     let cumTime = delay;
//     let moveCallback = null;
//     let disolveInCallback = null;
//     let disolveOutCallback = null;
//     if (elementsToMove.length === 0 && elementsToShow.length === 0) {
//       disolveOutCallback = callback;
//     } else if (elementsToShow.length === 0) {
//       moveCallback = callback;
//     } else {
//       disolveInCallback = callback;
//     }
//     if (elementsToHide.length > 0) {
//       this.dissolveElements(elementsToHide, 'out', delay, disolveOutTime, disolveOutCallback);
//       cumTime += disolveOutTime;
//     }
//     Object.keys(this.elementMods).forEach((elementName) => {
//       const mods = this.elementMods[elementName];
//       const {
//         element, color, style, direction, mag,
//       } = mods;
//       if (element != null) {
//         if (color != null) {
//           element.animateColorToWithDelay(color, cumTime, moveTimeToUse);
//         }
//         if (style != null) {
//           element.animate.transform.translation.style = style;
//         }
//         if (direction != null) {
//           element.animate.transform.translation.options.direction = direction;
//         }
//         if (mag != null) {
//           element.animate.transform.translation.options.magnitude = mag;
//         }
//       }
//     });
//     const t = this.collection.animateToTransforms(
//       animateToTransforms,
//       moveTimeToUse,
//       cumTime,
//       0,
//       moveCallback,
//     );
//     if (t > 0) {
//       cumTime = t;
//     }
//     if (elementsToShow.length > 0) {
//       this.dissolveElements(elementsToShow, 'in', cumTime, disolveInTime, disolveInCallback);
//       cumTime += disolveInTime + 0.001;
//     }
//     return cumTime;
//   }
// }

// class EquationFunctions {
//   // eslint-disable-next-line no-use-before-define
//   collection: EquationNew;
//   // eslint-disable-next-line no-use-before-define
//   constructor(collection: EquationNew) {
//     this.collection = collection;
//   }
//   frac(options: {
//       numerator: TypeEquationInput,
//       denominator: TypeEquationInput,
//       vinculum: string | DiagramElementPrimative | DiagramElementCollection,
//     }
//     | [
//         TypeEquationInput,
//         TypeEquationInput,
//         string | DiagramElementPrimative | DiagramElementCollection
//       ]) {
//     let numerator;
//     let denominator;
//     let vinculum;
//     if (Array.isArray(options)) {
//       [numerator, denominator, vinculum] = options;
//     } else {
//       ({ numerator, denominator, vinculum } = options);
//     }
//     return new Fraction(
//       contentToElement(this.collection, numerator),
//       contentToElement(this.collection, denominator),
//       getDiagramElement(this.collection, vinculum),
//     );
//   }
// }
// // An Equation is a collection of elements that can be arranged into different
// // forms.
// // Equation allows setting of forms, and navigating through form series
// // Eqn manages different forms of the
// export class EquationNew extends DiagramElementCollection {
//   eqn: {
//     forms: { [formName: string]: {
//       base: EquationForm;                   // There is always a base form
//       [subFormName: string]: EquationForm;  // Sub forms may differ in units
//       name: string;                         // Name of form
//     } };
//     currentForm: string;
//     currentSubForm: string;
//     getCurrentForm: () => ?EquationForm;
//     subFormPriority: Array<string>,
//     //
//     formSeries: { [seriesName: String]: Array<EquationForm> };
//     currentFormSeries: string;
//     getCurrentFormSeries: () => ?Array<EquationForm>;
//     //
//     defaultFormAlignment: {
//       fixTo: DiagramElementPrimative | DiagramElementCollection | Point;
//       hAlign: TypeHAlign;
//       vAlign: TypeVAlign;
//       scale: number,
//     };
//     //
//     showForm: (EquationForm | string, ?string) => {};
//     //
//   };
//   // isTouchDevice: boolean;
//   // animateNextFrame: void => void;
//   shapes: Object;
//   constructor(
//     shapes: Object,
//     // equations: Object,
//     // equation: Object,
//     // isTouchDevice: boolean,
//     // animateNextFrame: void => void,
//     options: TypeEquationOptions = {},
//   ) {
//     const defaultOptions = {
//       color: [0.5, 0.5, 0.5, 1],
//       position: new Point(0, 0),
//       defaultFormAlignment: {
//         fixTo: new Point(0, 0),
//         hAlign: 'left',
//         vAlign: 'baseline',
//         scale: 0.7,
//       },
//     };
//     const optionsToUse = joinObjects({}, defaultOptions, options);
//     super(new Transform('Equation')
//       .scale(1, 1)
//       .rotate(0)
//       .translate(0, 0), shapes.limits);
//     this.shapes = shapes;
//     this.color = optionsToUse.color;
//     this.setPosition(optionsToUse.position);
//     // this.isTouchDevice = isTouchDevice;
//     // this.animateNextFrame = animateNextFrame;
//     // Set default values
//     this.eqn = {
//       forms: {},
//       currentForm: '',
//       currentSubForm: '',
//       subFormPriority: ['base'],
//       formSeries: {},
//       currentFormSeries: '',
//       defaultFormAlignment: optionsToUse.defaultFormAlignment,
//       functions: new EquationFunctions(this),
//     };
//     if (optionsToUse.elements != null) {
//       this.addElements(optionsToUse.elements, this.color);
//     }
//   }
//   addElements(
//     elems: Object,
//     colorOrFont: Array<number> | DiagramFont = [],
//     // descriptionElement: DiagramElementPrimative | null = null,
//     // descriptionPosition: Point = new Point(0, 0),
//   ) {
//     this.addEquationElements(elems, colorOrFont);
//     // this.addDescriptionElement(descriptionElement, descriptionPosition);
//   }
//   addEquationElements(
//     elems: Object,
//     colorOrFont: Array<number> | DiagramFont = [],
//   ) {
//     let color = [1, 1, 1, 1];
//     if (Array.isArray(colorOrFont)) {
//       color = colorOrFont.slice();
//     }
//     let font = new DiagramFont(
//       'Times New Roman',
//       'normal',
//       0.2, '200', 'left', 'alphabetic', color,
//     );
//     let fontItalic = new DiagramFont(
//       'Times New Roman',
//       'italic',
//       0.2, '200', 'left', 'alphabetic', color,
//     );
//     if (colorOrFont instanceof DiagramFont) {
//       font = colorOrFont._dup();
//       font.style = 'normal';
//       fontItalic = colorOrFont._dup();
//       fontItalic.style = 'italic';
//       if (font.color != null) {
//         color = RGBToArray(font.color);
//       }
//     }
//     const makeElem = (text: string, fontOrStyle: DiagramFont | string | null) => {
//       let fontToUse: DiagramFont = font;
//       if (fontOrStyle instanceof DiagramFont) {
//         fontToUse = fontOrStyle;
//       } else if (fontOrStyle === 'italic') {
//         fontToUse = fontItalic;
//       } else if (fontOrStyle === 'normal') {
//         fontToUse = font;
//       } else if (text.match(/[A-Z,a-z]/)) {
//         fontToUse = fontItalic;
//       }
//       const p = this.shapes.txt(
//         text,
//         { location: new Point(0, 0), font: fontToUse },
//       );
//       return p;
//     };
//     Object.keys(elems).forEach((key) => {
//       if (typeof elems[key] === 'string') {
//         if (!key.startsWith('space')) {
//           this.add(key, makeElem(elems[key], null));
//         }
//       } else if (elems[key] instanceof DiagramElementPrimative) {
//         this.add(key, elems[key]);
//       } else if (elems[key] instanceof DiagramElementCollection) {
//         this.add(key, elems[key]);
//       } else {
//         const {
//           text, fontOrStyle, col, elementOptions,
//         } = elems[key];
//         const elem = makeElem(text, fontOrStyle);
//         if (elementOptions != null) {
//           elem.setProperties(elementOptions);
//         }
//         if (col != null) {
//           elem.setColor(col);
//         }
//         this.add(key, elem);
//       }
//     });
//     this.setFirstTransform(this.transform);
//   }
//   addForm(
//     name: string,
//     content: Array<Elements | Element | string>,
//     options: {
//       subForm?: string,
//       addToSeries?: string,
//       elementMods?: Object,
//       time?: number | null | { fromPrev?: number, fromNext?: number },
//       description?: string,
//       modifiers?: Object,
//     } = {},
//   ) {
//     if (!(name in this.eqn.forms)) {
//       this.eqn.forms[name] = {};
//     }
//     const defaultOptions = {
//       subForm: 'base',
//       addToSeries: '',
//       elementMods: {},
//       animationTime: null,          // use velocities instead of time
//       description: '',
//       modifiers: {},
//     };
//     let optionsToUse = defaultOptions;
//     if (options) {
//       optionsToUse = Object.assign({}, defaultOptions, options);
//     }
//     const {
//       subForm, description, modifiers,
//       animationTime, elementMods, addToSeries,
//     } = optionsToUse;
//     const time = animationTime;
//     this.eqn.forms[name].name = name;
//     const form = this.eqn.forms[name];
//     form[subForm] = new EquationForm(this);
//     // form[subForm].name = subForm;
//     form[subForm].description = description;
//     form[subForm].modifiers = modifiers;
//     form[subForm].name = name;
//     form[subForm].subForm = subForm;
//     form[subForm].elementMods = {};
//     if (typeof time === 'number') {
//       form[name].time = {
//         fromPrev: time, fromNext: time, fromAny: time,
//       };
//     } else {
//       form[subForm].time = time;
//     }
//     Object.keys(elementMods).forEach((elementName) => {
//       const diagramElement = getDiagramElement(this, elementName);
//       if (diagramElement) {
//         let color;
//         let elementOptions;
//         if (Array.isArray(elementMods[elementName])) {
//           [color, elementOptions] = elementMods[elementName];
//         } else {
//           ({
//             color, elementOptions,
//           } = elementMods[elementName]);
//         }
//         form[subForm].elementMods[elementName] = {
//           element: diagramElement,
//           color,
//           elementOptions,
//         };
//       }
//     });
//     // const form = this.form[name][formType];
//     form[subForm].createEq(content);
//     // form[subForm].subForm = formType;
//     form[subForm].arrange(
//       this.eqn.defaultFormAlignment.scale,
//       this.eqn.defaultFormAlignment.hAlign,
//       this.eqn.defaultFormAlignment.vAlign,
//       this.eqn.defaultFormAlignment.fixTo,
//     );
//     // if (addToSeries != null && addToSeries !== '') {
//     //   if (this.eqn.formSeries[addToSeries] == null) {
//     //     this.eqn.formSeries[addToSeries] = [];
//     //   }
//     //   this.eqn.formSeries[addToSeries].push(this.eqn.forms[name]);
//     // }
//     // make the first form added also equal to the base form as always
//     // need a base form for some functions
//     if (this.eqn.forms[name].base === undefined) {
//       const baseOptions = Object.assign({}, options);
//       baseOptions.subForm = 'base';
//       this.addForm(name, content, baseOptions);
//     }
//     if (this.eqn.currentForm === '') {
//       this.eqn.currentForm = name;
//     }
//     if (this.eqn.currentSubForm === '') {
//       this.eqn.currentSubForm = 'base';
//     }
//   }
//   getCurrentForm() {
//     console.log(this.eqn.currentForm, this.eqn.currentSubForm, this.eqn.forms)
//     if (this.eqn.forms[this.eqn.currentForm] == null) {
//       return null;
//     }
//     if (this.eqn.forms[this.eqn.currentForm][this.eqn.currentSubForm] == null) {
//       return null;
//     }
//     return this.eqn.forms[this.eqn.currentForm][this.eqn.currentSubForm];
//   }
//   render() {
//     const form = this.getCurrentForm();
//     if (form != null) {
//       form.showHide();
//       this.show();
//       form.setPositions();
//       // this.updateDescription();
//     }
//   }
//   setCurrentForm(
//     formOrName: EquationForm | string,
//     subForm: string = 'base',
//   ) {
//     if (typeof formOrName === 'string') {
//       this.eqn.currentForm = '';
//       this.eqn.currentSubForm = '';
//       if (formOrName in this.eqn.forms) {
//         this.eqn.currentForm = formOrName;
//         if (subForm in this.eqn.forms[formOrName]) {
//           this.eqn.currentSubForm = subForm;
//         }
//       }
//     } else {
//       this.eqn.currentForm = formOrName.name;
//       this.eqn.currentSubForm = formOrName.subForm;
//     }
//   }
//   showForm(
//     formOrName: EquationForm | string,
//     subForm: ?string = null,
//   ) {
//     this.show();
//     let form = formOrName;
//     if (typeof formOrName === 'string') {
//       form = this.getForm(formOrName, subForm);
//     }
//     if (form) {
//       this.setCurrentForm(form);
//       this.render();
//     }
//   }
//   getForm(
//     formOrName: string | EquationForm,
//     subForm: ?string,
//   ): null | EquationForm {
//     if (formOrName instanceof EquationForm) {
//       return formOrName;
//     }
//     // console.log(formType, this.form[formOrName])
//     if (formOrName in this.eqn.forms) {
//       let formTypeToUse = subForm;
//       if (formTypeToUse == null) {
//         const possibleFormTypes
//           = this.eqn.subFormPriority.filter(fType => fType in this.eqn.forms[formOrName]);
//         if (possibleFormTypes.length) {
//           // eslint-disable-next-line prefer-destructuring
//           formTypeToUse = possibleFormTypes[0];
//         }
//       }
//       if (formTypeToUse != null) {
//         return this.eqn.forms[formOrName][formTypeToUse];
//       }
//     }
//     return null;
//   }
// }
// An Equation is tied to a collection of elements.
//
// The Equation class manages equation forms that
// speicify how to lay out the collection of elements.
//
// The Equation class also has a helper that can create a colleciton
// of DiagramElements for an equation
//
// EqnCollection extends DiagramElementCollection
//    eqns: { equations that manage this collection }
//    eqnName: direct access to equation with a particular name
var Equation =
/*#__PURE__*/
function () {
  // currentForm: ?EquationForm;
  // currentFormName: string;
  // currentFormType: string;
  function Equation(drawContext2D) {
    var diagramLimits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2);
    var firstTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Equation').scale(1, 1).rotate(0).translate(0, 0);

    _classCallCheck(this, Equation);

    this.drawContext2D = drawContext2D;
    this.diagramLimits = diagramLimits;
    this.firstTransform = firstTransform;
    this.form = {};
    this.formAlignment = {
      vAlign: 'baseline',
      hAlign: 'left',
      fixTo: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      scale: 1
    };
    this.currentForm = '';
    this.currentFormType = '';
    this.formTypeOrder = ['base'];
    this.descriptionPosition = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    this.isAnimating = false;
  }

  _createClass(Equation, [{
    key: "_dup",
    value: function _dup() {
      var _this = this;

      var equationCopy = new Equation(this.drawContext2D, this.diagramLimits._dup(), this.firstTransform._dup());
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, equationCopy, ['collection', 'form', 'drawContext2D', 'formAlignment']);

      var newCollection = this.collection._dup();

      equationCopy.collection = newCollection;
      var newForm = {};
      Object.keys(this.form).forEach(function (name) {
        if (!(name in newForm)) {
          newForm[name] = {};
        }

        Object.keys(_this.form[name]).forEach(function (formType) {
          if (formType !== 'name') {
            newForm[name][formType] = _this.form[name][formType]._dup(newCollection.elements, {
              getAllElements: newCollection.getAllElements.bind(newCollection),
              hideAll: newCollection.hideAll.bind(newCollection),
              show: newCollection.show.bind(newCollection),
              showOnly: newCollection.showOnly.bind(newCollection),
              stop: newCollection.stop.bind(newCollection),
              getElementTransforms: newCollection.getElementTransforms.bind(newCollection),
              setElementTransforms: newCollection.setElementTransforms.bind(newCollection),
              animateToTransforms: newCollection.animateToTransforms.bind(newCollection)
            });
          } else {
            newForm[name][formType] = _this.form[name][formType];
          }
        });
      });
      equationCopy.form = newForm;
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this.formAlignment, equationCopy.formAlignment, ['fixTo']);
      var fixTo = this.formAlignment.fixTo;

      if (fixTo instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        equationCopy.formAlignment.fixTo = this.formAlignment.fixTo._dup();
      } else {
        Object.keys(newCollection.elements).forEach(function (key) {
          if (newCollection.elements[key].name === fixTo.name) {
            equationCopy.formAlignment.fixTo = newCollection.elements[key];
          }
        });
      }

      return equationCopy;
    }
  }, {
    key: "createElements",
    value: function createElements(elems) {
      var colorOrFont = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var descriptionElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var descriptionPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var existingCollection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      this.collection = createEquationElements(elems, this.drawContext2D, colorOrFont, this.diagramLimits, this.firstTransform, existingCollection);
      this.addDescriptionElement(descriptionElement, descriptionPosition);
    }
  }, {
    key: "addDescriptionElement",
    value: function addDescriptionElement() {
      var descriptionElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var descriptionPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.descriptionElement = descriptionElement;
      this.descriptionPosition = descriptionPosition;

      if (this.descriptionElement) {
        this.descriptionElement.setPosition(this.collection.getDiagramPosition().add(descriptionPosition));
      }
    }
  }, {
    key: "setPosition",
    value: function setPosition(position) {
      this.collection.setPosition(position);

      if (this.descriptionElement) {
        this.descriptionElement.setPosition(position.add(this.descriptionPosition));
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      this.collection.stop();
    }
  }, {
    key: "setElem",
    value: function setElem(element) {
      var elementColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var isTouchable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      var mag = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
      var elem = element;

      if (typeof elem === 'string') {
        elem = getDiagramElement(this.collection, element);
      }

      if (elem instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementCollection"] || elem instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementPrimative"]) {
        if (elementColor != null) {
          elem.setColor(elementColor);
        }

        elem.isTouchable = isTouchable;

        if (isTouchable) {
          this.collection.hasTouchableElements = true;
        }

        elem.animate.transform.translation.style = 'curved';
        elem.animate.transform.translation.options.direction = direction;
        elem.animate.transform.translation.options.magnitude = mag;
      }
    }
  }, {
    key: "addForm",
    value: function addForm(name, content) {
      var _this2 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!(name in this.form)) {
        this.form[name] = {};
      }

      var defaultOptions = {
        formType: 'base',
        addToSeries: true,
        elementMods: {},
        animationTime: null,
        // use velocities instead of time
        description: '',
        modifiers: {}
      };
      var optionsToUse = defaultOptions;

      if (options) {
        optionsToUse = Object.assign({}, defaultOptions, options);
      }

      var _optionsToUse = optionsToUse,
          formType = _optionsToUse.formType,
          description = _optionsToUse.description,
          modifiers = _optionsToUse.modifiers,
          animationTime = _optionsToUse.animationTime,
          elementMods = _optionsToUse.elementMods,
          addToSeries = _optionsToUse.addToSeries;
      var time = animationTime;
      this.form[name][formType] = new _EquationForm__WEBPACK_IMPORTED_MODULE_14__["default"](this.collection.elements, {
        getAllElements: this.collection.getAllElements.bind(this.collection),
        hideAll: this.collection.hideAll.bind(this.collection),
        show: this.collection.show.bind(this.collection),
        showOnly: this.collection.showOnly.bind(this.collection),
        stop: this.collection.stop.bind(this.collection),
        getElementTransforms: this.collection.getElementTransforms.bind(this.collection),
        setElementTransforms: this.collection.setElementTransforms.bind(this.collection),
        animateToTransforms: this.collection.animateToTransforms.bind(this.collection)
      });
      this.form[name].name = name;
      this.form[name][formType].name = name;
      this.form[name][formType].description = description;
      this.form[name][formType].modifiers = modifiers;
      this.form[name][formType].type = formType;
      this.form[name][formType].elementMods = {};

      if (typeof time === 'number') {
        this.form[name][formType].time = {
          fromPrev: time,
          fromNext: time,
          fromAny: time
        };
      } else {
        this.form[name][formType].time = time;
      }

      Object.keys(elementMods).forEach(function (elementName) {
        var diagramElement = getDiagramElement(_this2.collection, elementName);

        if (diagramElement) {
          var color;
          var style;
          var direction;
          var mag;

          if (Array.isArray(elementMods[elementName])) {
            var _elementMods$elementN = _slicedToArray(elementMods[elementName], 4);

            color = _elementMods$elementN[0];
            style = _elementMods$elementN[1];
            direction = _elementMods$elementN[2];
            mag = _elementMods$elementN[3];
          } else {
            var _elementMods$elementN2 = elementMods[elementName];
            color = _elementMods$elementN2.color;
            style = _elementMods$elementN2.style;
            direction = _elementMods$elementN2.direction;
            mag = _elementMods$elementN2.mag;
          }

          _this2.form[name][formType].elementMods[elementName] = {
            element: diagramElement,
            color: color,
            style: style,
            direction: direction,
            mag: mag
          };
        }
      });
      var form = this.form[name][formType];
      form.createEq(content);
      form.type = formType;
      form.arrange(this.formAlignment.scale, this.formAlignment.hAlign, this.formAlignment.vAlign, this.formAlignment.fixTo);

      if (addToSeries) {
        if (this.formSeries == null) {
          this.formSeries = [];
        }

        this.formSeries.push(this.form[name]);
      } // make the first form added also equal to the base form as always
      // need a base form for some functions


      if (this.form[name].base === undefined) {
        var baseOptions = Object.assign({}, options);
        baseOptions.formType = 'base';
        this.addForm(name, content, baseOptions);
      }
    }
  }, {
    key: "getCurrentForm",
    value: function getCurrentForm() {
      if (this.form[this.currentForm] == null) {
        return null;
      }

      if (this.form[this.currentForm][this.currentFormType] == null) {
        return null;
      }

      return this.form[this.currentForm][this.currentFormType];
    }
  }, {
    key: "reArrangeCurrentForm",
    value: function reArrangeCurrentForm() {
      var form = this.getCurrentForm();

      if (form == null) {
        return;
      }

      form.arrange(this.formAlignment.scale, this.formAlignment.hAlign, this.formAlignment.vAlign, this.formAlignment.fixTo);
    }
  }, {
    key: "scaleForm",
    value: function scaleForm(name, scale) {
      var formType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'base';

      // console.log(name, this.form, formType, this.form[name][formType])
      if (name in this.form) {
        if (formType in this.form[name]) {
          this.form[name][formType].arrange(scale, this.formAlignment.hAlign, this.formAlignment.vAlign, this.formAlignment.fixTo);
        }
      }
    }
  }, {
    key: "scale",
    value: function scale(_scale) {
      var _this3 = this;

      Object.keys(this.form).forEach(function (name) {
        Object.keys(_this3.form[name]).forEach(function (formType) {
          if (formType !== 'name') {
            _this3.scaleForm(name, _scale, formType);
          }
        });
      });
    }
  }, {
    key: "setFormSeries",
    value: function setFormSeries(series) {
      var _this4 = this;

      this.formSeries = [];
      series.forEach(function (form) {
        if (typeof form === 'string') {
          _this4.formSeries.push(_this4.form[form]);
        } else {
          _this4.formSeries.push(form);
        }
      });
    }
  }, {
    key: "getFormIndex",
    value: function getFormIndex(formToGet) {
      var form = this.getForm(formToGet);
      var index = -1;

      if (form != null) {
        index = this.formSeries.indexOf(this.form[form.name]);
      }

      return index;
    }
  }, {
    key: "prevForm",
    value: function prevForm() {
      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var currentForm = this.getCurrentForm();

      if (currentForm == null) {
        return;
      }

      var index = this.getFormIndex(currentForm);

      if (index > -1) {
        index -= 1;

        if (index < 0) {
          index = this.formSeries.length - 1;
        }

        this.goToForm(index, time, delay, 'fromNext');
      }
    }
  }, {
    key: "nextForm",
    value: function nextForm() {
      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var animate = true;
      var currentForm = this.getCurrentForm();

      if (currentForm == null) {
        return;
      }

      var index = this.getFormIndex(currentForm);

      if (index > -1) {
        index += 1;

        if (index > this.formSeries.length - 1) {
          index = 0;
          animate = false;
        }

        this.goToForm(index, time, delay, 'fromPrev', animate);
      }
    }
  }, {
    key: "replayCurrentForm",
    value: function replayCurrentForm(time) {
      if (this.isAnimating) {
        this.collection.stop(true, true);
        this.collection.stop(true, true);
        this.isAnimating = false;
        var currentForm = this.getCurrentForm();

        if (currentForm != null) {
          this.showForm(currentForm);
        }

        return;
      }

      this.collection.stop();
      this.collection.stop();
      this.isAnimating = false;
      this.prevForm(0);
      this.nextForm(time, 0.5);
    }
  }, {
    key: "animateToForm",
    value: function animateToForm(name) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      this.collection.stopAnimatingColor(true, true);
      this.collection.stopAnimatingColor(true, true);
      this.collection.stop();
      this.collection.stop();
      var form = this.getForm(name);

      if (form != null) {
        form.animatePositionsTo(delay, 0.4, time, 0.4, callback);
      }

      this.setCurrentForm(name); // if (this.isAnimating) {
      //   this.collection.stop(true, true);
      //   this.collection.stop(true, true);
      //   this.isAnimating = false;
      //   const currentForm = this.getCurrentForm();
      //   if (currentForm != null) {
      //     this.showForm(currentForm);
      //   }
      //   // return;
      // }
      // this.collection.stop();
      // this.collection.stop();
      // this.isAnimating = false;
    }
  }, {
    key: "goToForm",
    value: function goToForm() {
      var _this5 = this;

      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var fromWhere = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'fromAny';
      var animate = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      var callback = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

      if (this.isAnimating) {
        this.collection.stop(true, true);
        this.collection.stop(true, true);
        this.isAnimating = false;
        var currentForm = this.getCurrentForm();

        if (currentForm != null) {
          this.showForm(currentForm);
        }

        return;
      }

      this.collection.stop();
      this.collection.stop();
      this.isAnimating = false; // By default go to the next form in a series

      var nextIndex = 0;

      if (name == null) {
        var index = 0;

        var _currentForm = this.getCurrentForm();

        if (_currentForm != null) {
          index = this.formSeries.indexOf(this.form[_currentForm.name]);

          if (index < 0) {
            index = 0;
          }
        }

        nextIndex = index + 1;

        if (nextIndex === this.formSeries.length) {
          nextIndex = 0;
        }
      } else if (typeof name === 'number') {
        nextIndex = name;
      } else {
        this.formSeries.forEach(function (form, index) {
          if (form.name === name) {
            nextIndex = index;
          }
        });
      }

      var form = null;
      var formTypeToUse = null;
      var possibleFormTypes = this.formTypeOrder.filter(function (fType) {
        return fType in _this5.formSeries[nextIndex];
      });

      if (possibleFormTypes.length) {
        // eslint-disable-next-line prefer-destructuring
        formTypeToUse = possibleFormTypes[0];
      }

      if (formTypeToUse != null) {
        // $FlowFixMe
        form = this.formSeries[nextIndex][formTypeToUse];

        if (time === 0) {
          this.showForm(form);

          if (callback != null) {
            callback();
          }
        } else {
          this.isAnimating = true;

          var end = function end() {
            _this5.isAnimating = false;

            if (callback != null) {
              callback();
            }
          };

          if (animate) {
            var timeToUse = null;

            if (form.time != null && form.time[fromWhere] != null) {
              timeToUse = form.time[fromWhere];
            }

            form.animatePositionsTo(delay, 0.4, timeToUse, 0.4, end);
          } else {
            form.allHideShow(delay, 0.5, 0.2, 0.5, end);
          }

          this.setCurrentForm(form);
        }

        this.updateDescription();
      }
    }
  }, {
    key: "changeDescription",
    value: function changeDescription(formOrName) {
      var description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var modifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var formType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'base';
      var form = this.getForm(formOrName, formType);

      if (form != null) {
        form.description = "".concat(description);
        form.modifiers = modifiers;
      }
    }
  }, {
    key: "updateDescription",
    value: function updateDescription() {
      var formOrName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var formType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'base';
      var element = this.descriptionElement;

      if (element == null) {
        return;
      }

      if (element.isShown === false) {
        return;
      }

      var form = null;

      if (formOrName == null) {
        form = this.getCurrentForm();
      } else if (typeof formOrName === 'string') {
        form = this.getForm(formOrName, formType);
      } else {
        form = formOrName;
      }

      if (form == null) {
        return;
      }

      if (form.description == null) {
        return;
      }

      var drawingObject = element.drawingObject;

      if (drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_7__["default"]) {
        drawingObject.change(_tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_6__["applyModifiers"](form.description, form.modifiers), element.lastDrawTransform.m());
        _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_6__["setOnClicks"](form.modifiers);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var form = this.getCurrentForm();

      if (form != null) {
        form.showHide();
        this.collection.show();
        form.setPositions();
        this.updateDescription();
      }
    }
  }, {
    key: "setCurrentForm",
    value: function setCurrentForm(formOrName) {
      var formType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'base';

      if (typeof formOrName === 'string') {
        this.currentForm = '';
        this.currentFormType = '';

        if (formOrName in this.form) {
          this.currentForm = formOrName;

          if (formType in this.form[formOrName]) {
            this.currentFormType = formType;
          }
        }
      } else {
        this.currentForm = formOrName.name;
        this.currentFormType = formOrName.type;
      }
    }
  }, {
    key: "setUnits",
    value: function setUnits(units) {
      if (units === 'deg') {
        this.formTypeOrder = ['deg', 'base'];
      }

      if (units === 'rad') {
        this.formTypeOrder = ['rad', 'base'];
      }

      if (this.collection.isShown) {
        this.showForm(this.currentForm);
      }
    }
  }, {
    key: "showForm",
    value: function showForm(formOrName) {
      var formType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.collection.show();
      var form = formOrName;

      if (typeof formOrName === 'string') {
        form = this.getForm(formOrName, formType);
      }

      if (form) {
        this.setCurrentForm(form);
        this.render();
      }
    }
  }, {
    key: "getForm",
    value: function getForm(formOrName, formType) {
      var _this6 = this;

      if (formOrName instanceof _EquationForm__WEBPACK_IMPORTED_MODULE_14__["default"]) {
        return formOrName;
      } // console.log(formType, this.form[formOrName])


      if (formOrName in this.form) {
        var formTypeToUse = formType;

        if (formTypeToUse == null) {
          var possibleFormTypes = this.formTypeOrder.filter(function (fType) {
            return fType in _this6.form[formOrName];
          });

          if (possibleFormTypes.length) {
            // eslint-disable-next-line prefer-destructuring
            formTypeToUse = possibleFormTypes[0];
          }
        }

        if (formTypeToUse != null) {
          return this.form[formOrName][formTypeToUse];
        }
      }

      return null;
    }
  }, {
    key: "phrase",
    value: function phrase(content) {
      return new _Elements_Element__WEBPACK_IMPORTED_MODULE_8__["Elements"]([contentToElement(this.collection, content)]);
    }
  }, {
    key: "frac",
    value: function frac(numerator, denominator, vinculum) {
      return new _Elements_Fraction__WEBPACK_IMPORTED_MODULE_9__["default"](contentToElement(this.collection, numerator), contentToElement(this.collection, denominator), getDiagramElement(this.collection, vinculum));
    }
  }, {
    key: "strike",
    value: function strike(content, _strike) {
      var strikeInSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      return new _Elements_Strike__WEBPACK_IMPORTED_MODULE_10__["default"](contentToElement(this.collection, content), getDiagramElement(this.collection, _strike), strikeInSize);
    }
  }, {
    key: "annotation",
    value: function annotation(content, annotationArray) {
      var annotationInSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      return new _Elements_Annotation__WEBPACK_IMPORTED_MODULE_13__["Annotation"](contentToElement(this.collection, content), annotationArray, annotationInSize);
    }
  }, {
    key: "ann",
    value: function ann(content) {
      var xPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'right';
      var yPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'top';
      var xAlign = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'left';
      var yAlign = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'bottom';
      var annotationScale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.5;
      return new _Elements_Annotation__WEBPACK_IMPORTED_MODULE_13__["AnnotationInformation"](contentToElement(this.collection, content), xPosition, yPosition, xAlign, yAlign, annotationScale);
    }
  }, {
    key: "sfrac",
    value: function sfrac(numerator, denominator, vinculum) {
      var scaleModifier = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var f = this.frac(numerator, denominator, vinculum);
      f.scaleModifier = scaleModifier;
      return f;
    }
  }, {
    key: "sub",
    value: function sub(content, subscript) {
      return new _Elements_SuperSub__WEBPACK_IMPORTED_MODULE_11__["default"](contentToElement(this.collection, content), null, contentToElement(this.collection, subscript));
    }
  }, {
    key: "sup",
    value: function sup(content, superscript) {
      return new _Elements_SuperSub__WEBPACK_IMPORTED_MODULE_11__["default"](contentToElement(this.collection, content), contentToElement(this.collection, superscript), null);
    }
  }, {
    key: "supsub",
    value: function supsub(content, superscript, subscript) {
      return new _Elements_SuperSub__WEBPACK_IMPORTED_MODULE_11__["default"](contentToElement(this.collection, content), contentToElement(this.collection, superscript), contentToElement(this.collection, subscript));
    }
  }, {
    key: "brac",
    value: function brac(content, leftBracket, rightBracket) {
      var space = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.03;
      return new _Elements_Brackets__WEBPACK_IMPORTED_MODULE_12__["Brackets"](contentToElement(this.collection, content), getDiagramElement(this.collection, leftBracket), getDiagramElement(this.collection, rightBracket), space);
    }
  }, {
    key: "topBar",
    value: function topBar(content, bar) {
      var space = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.03;
      var outsideSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.03;
      return new _Elements_Brackets__WEBPACK_IMPORTED_MODULE_12__["Bar"](contentToElement(this.collection, content), getDiagramElement(this.collection, bar), space, outsideSpace, 'top');
    }
  }, {
    key: "bottomBar",
    value: function bottomBar(content, bar) {
      var space = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.03;
      var outsideSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.03;
      return new _Elements_Brackets__WEBPACK_IMPORTED_MODULE_12__["Bar"](contentToElement(this.collection, content), getDiagramElement(this.collection, bar), space, outsideSpace, 'bottom');
    }
  }, {
    key: "topComment",
    value: function topComment(content, comment, bar) {
      var space = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.03;
      var outsideSpace = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.03;
      return this.annotation(this.topBar(content, bar, space, outsideSpace), [this.ann(comment, 'center', 'top', 'center', 'bottom')]);
    }
  }, {
    key: "bottomComment",
    value: function bottomComment(content, comment, bar) {
      var space = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.0;
      var outsideSpace = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.03;
      return this.annotation(this.bottomBar(content, bar, space, outsideSpace), [this.ann(comment, 'center', 'bottom', 'center', 'top')]);
    }
  }]);

  return Equation;
}();

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/HTMLEquation.js":
/*!*****************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/HTMLEquation.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HTMLEquation; });
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function makeDiv(id, classes, text) {
  var indent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var indentStr = ' '.repeat(indent);
  var idStr = id ? " id=\"".concat(id, "\"") : '';
  var classString = classes ? " ".concat(classes.join(' ')) : '';
  var out = "".concat(indentStr, "<div").concat(idStr, " class=\"equation_element").concat(classString, "\">\n");
  out += "".concat(text, "\n");
  out += "".concat(indentStr, "</div>");
  return out;
} // Most fundamental Equation Element properties includes element size and
// location, as well as html id and classes.


var HTMLElementProperties =
/*#__PURE__*/
function () {
  function HTMLElementProperties() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var classes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    _classCallCheck(this, HTMLElementProperties);

    this.id = id;

    if (Array.isArray(classes)) {
      this.classes = classes;
    } else if (classes.length > 0) {
      this.classes = classes.split(' ');
    } else {
      this.classes = [];
    }
  }

  _createClass(HTMLElementProperties, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      return makeDiv(this.id, this.classes, text, indent);
    }
  }]);

  return HTMLElementProperties;
}();

var HTMLElement =
/*#__PURE__*/
function (_HTMLElementPropertie) {
  _inherits(HTMLElement, _HTMLElementPropertie);

  function HTMLElement(text) {
    var _this;

    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    _classCallCheck(this, HTMLElement);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HTMLElement).call(this, id, classes));

    _this.classes.push('equation_text');

    _this.text = text;
    return _this;
  }

  _createClass(HTMLElement, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return _get(_getPrototypeOf(HTMLElement.prototype), "render", this).call(this, indent, "".concat(' '.repeat(indent + 2)).concat(this.text));
    }
  }]);

  return HTMLElement;
}(HTMLElementProperties);

var HTMLElements =
/*#__PURE__*/
function (_HTMLElementPropertie2) {
  _inherits(HTMLElements, _HTMLElementPropertie2);

  function HTMLElements(content) {
    var _this2;

    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    _classCallCheck(this, HTMLElements);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(HTMLElements).call(this, id, classes));
    var filteredContent = [];
    content.forEach(function (c) {
      if (c !== null) {
        filteredContent.push(c);
      }
    });
    _this2.content = filteredContent;
    return _this2;
  }

  _createClass(HTMLElements, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return _get(_getPrototypeOf(HTMLElements.prototype), "render", this).call(this, indent, this.content.map(function (c) {
        return c.render(indent + 2);
      }).join('\n'));
    }
  }]);

  return HTMLElements;
}(HTMLElementProperties);

var Fraction =
/*#__PURE__*/
function (_HTMLElementPropertie3) {
  _inherits(Fraction, _HTMLElementPropertie3);

  function Fraction(numerator, denominator) {
    var _this3;

    var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

    _classCallCheck(this, Fraction);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Fraction).call(this, id, classes));

    _this3.classes.push('fraction');

    _this3.numerator = numerator;
    _this3.denominator = denominator;
    return _this3;
  }

  _createClass(Fraction, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var s = ' '.repeat(indent + 2);
      var out = '';
      out += "".concat(s, "<div class=\"numerator\">\n");
      out += this.numerator.render(indent + 4);
      out += "\n".concat(s, "</div>\n");
      out += "".concat(s, "<div class=\"fraction_line\"> </div>\n");
      out += "".concat(s, "<div class=\"denominator\">\n");
      out += this.denominator.render(indent + 4);
      out += "\n".concat(s, "</div>");
      return _get(_getPrototypeOf(Fraction.prototype), "render", this).call(this, indent, out);
    }
  }]);

  return Fraction;
}(HTMLElementProperties);

var SuperSub =
/*#__PURE__*/
function (_HTMLElementPropertie4) {
  _inherits(SuperSub, _HTMLElementPropertie4);

  function SuperSub(content, superscript, subscript) {
    var _this4;

    var id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
    var classes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';

    _classCallCheck(this, SuperSub);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(SuperSub).call(this, id, classes));

    _this4.classes.push('supersub');

    _this4.superscript = superscript;
    _this4.subscript = subscript;
    _this4.content = content;
    return _this4;
  }

  _createClass(SuperSub, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var s = ' '.repeat(indent + 2);
      var out = '';
      out += "".concat(s, "<div class=\"supsub_content element\">\n");
      out += this.content.render(indent + 2);
      out += "\n".concat(s, "</div>\n");
      out += "".concat(s, "<div class=\"super_sub element\">\n");
      out += "".concat(s, "<div class=\"super_sub_super superscript_text element\">\n");

      if (this.superscript !== null) {
        out += this.superscript.render(indent + 4);
      }

      out += "\n".concat(s, "</div>\n");
      out += "".concat(s, "<div class=\"super_sub_sub subscript_text element\">\n");

      if (this.subscript !== null) {
        out += this.subscript.render(indent + 4);
      }

      out += "\n".concat(s, "</div>");
      out += "\n".concat(s, "</div>\n");
      return _get(_getPrototypeOf(SuperSub.prototype), "render", this).call(this, indent, out);
    }
  }]);

  return SuperSub;
}(HTMLElementProperties);

var Subscript =
/*#__PURE__*/
function (_SuperSub) {
  _inherits(Subscript, _SuperSub);

  function Subscript(content, // eslint-disable-line no-use-before-define
  subscript) {
    var _this5;

    var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

    _classCallCheck(this, Subscript);

    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(Subscript).call(this, content, null, subscript, id, classes));

    var index = _this5.classes.indexOf('supersub');

    if (index > -1) {
      _this5.classes.splice(index, 1);
    }

    _this5.classes.push('subscript');

    return _this5;
  }

  return Subscript;
}(SuperSub);

var Superscript =
/*#__PURE__*/
function (_SuperSub2) {
  _inherits(Superscript, _SuperSub2);

  function Superscript(content, // eslint-disable-line no-use-before-define
  superscript) {
    var _this6;

    var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

    _classCallCheck(this, Superscript);

    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(Superscript).call(this, content, superscript, null, id, classes));

    var index = _this6.classes.indexOf('supersub');

    if (index > -1) {
      _this6.classes.splice(index, 1);
    }

    _this6.classes.push('superscript');

    return _this6;
  }

  return Superscript;
}(SuperSub);

var Root =
/*#__PURE__*/
function (_HTMLElementPropertie5) {
  _inherits(Root, _HTMLElementPropertie5);

  function Root(content) {
    var _this7;

    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    _classCallCheck(this, Root);

    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(Root).call(this, id, classes));
    _this7.content = content;
    return _this7;
  }

  _createClass(Root, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var s = ' '.repeat(indent + 2);
      var out = '';
      out += "".concat(s, "<div class=\"square_root element\">\n");
      out += "".concat(s, "  <div class=\"equation_element radical element\">\n");
      out += "".concat(s, "    &radic;\n");
      out += "".concat(s, "  </div>\n");
      out += this.content.render(indent + 4);
      out += "\n".concat(s, "</div>");
      return _get(_getPrototypeOf(Root.prototype), "render", this).call(this, indent, out);
    }
  }]);

  return Root;
}(HTMLElementProperties); // function contentToE(content: string | HTMLElements): HTMLElements {
//   let c;
//   if (typeof content === 'string') {
//     c = new HTMLElements(content);
//   } else {
//     c = content;
//   }
//   return c;
// }


function contentToElement(content) {
  if (content instanceof HTMLElements) {
    return content;
  }

  if (content instanceof HTMLElement || content instanceof HTMLElementProperties) {
    return new HTMLElements([content]);
  }

  if (typeof content === 'string') {
    return new HTMLElements([new HTMLElement(content)]);
  } // Otherwise must be array


  var elementArray = [];
  content.forEach(function (c) {
    if (typeof c === 'string') {
      elementArray.push(new HTMLElement(c));
    } else {
      elementArray.push(c);
    }
  });
  return new HTMLElements(elementArray);
}

var HTMLEquation =
/*#__PURE__*/
function (_HTMLElements) {
  _inherits(HTMLEquation, _HTMLElements);

  function HTMLEquation() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var classes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    _classCallCheck(this, HTMLEquation);

    return _possibleConstructorReturn(this, _getPrototypeOf(HTMLEquation).call(this, [], id, classes));
  }

  _createClass(HTMLEquation, [{
    key: "createEq",
    value: function createEq(content) {
      var _this8 = this;

      var elements = [];
      content.forEach(function (c) {
        if (typeof c === 'string') {
          elements.push(new HTMLElement(c));
        } else {
          elements.push(c);
        }

        _this8.content = elements;
      });
    }
  }, {
    key: "htmlElement",
    value: function htmlElement() {
      var element = document.createElement('div');
      element.setAttribute('id', this.id);
      element.innerHTML = this.render();
      this.classes.forEach(function (c) {
        if (c) {
          element.classList.add(c);
        }
      });
      return element;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "el",
    value: function el(content) {
      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      return new HTMLElement(content, id, classes);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "supsub",
    value: function supsub(content, superscript, subscript) {
      var id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      var classes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
      return new SuperSub(contentToElement(content), contentToElement(superscript), contentToElement(subscript), id, classes);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "sub",
    value: function sub(content, subscript) {
      var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      return new Subscript(contentToElement(content), contentToElement(subscript), id, classes);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "sup",
    value: function sup(content, superscript) {
      var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      return new Superscript(contentToElement(content), contentToElement(superscript), id, classes);
    } // e(
    //   content: string | Array<HTMLElementProperties>,
    //   id: string = '',
    //   classes: string | Array<string> = [],
    // ) {
    //   return new HTMLElements(content, id, classes);
    // }
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "frac",
    value: function frac(numerator, denominator) {
      var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      return new Fraction(contentToElement(numerator), contentToElement(denominator), id, classes);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "sqrt",
    value: function sqrt(content) {
      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      return new Root(contentToElement(content), id, classes);
    }
  }]);

  return HTMLEquation;
}(HTMLElements);



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/Bar.js":
/*!****************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/Bar.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Bracket; });
/* harmony import */ var _VertexBar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VertexBar */ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexBar.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");




function Bracket(webgl, color, side, numLines, transformOrLocation, diagramLimits) {
  var vertices = new _VertexBar__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, side, numLines);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"](vertices, transform, color, diagramLimits);
}

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/Brace.js":
/*!******************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/Brace.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Brace; });
/* harmony import */ var _VertexBrace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VertexBrace */ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexBrace.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");




function Brace(webgl, color, side, numLines, transformOrLocation, diagramLimits) {
  var vertices = new _VertexBrace__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, side, numLines);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"](vertices, transform, color, diagramLimits);
}

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/Bracket.js":
/*!********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/Bracket.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Bracket; });
/* harmony import */ var _VertexBracket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VertexBracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexBracket.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
 // import VertexPolygonFilled from '../../DrawingObjects/VertexObject/VertexPolygon';




function Bracket(webgl, color, side, numLines, transformOrLocation, diagramLimits) {
  // const serifSides = 30;
  // const serifRadius = 0.05;
  var vertices = new _VertexBracket__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, side, numLines); // const serif = new VertexPolygonFilled(
  //   webgl,
  //   serifSides,
  //   serifRadius,
  //   0,
  //   new Point(0, 0),
  //   serifSides,
  // );

  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"](vertices, transform, color, diagramLimits);
}

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/Integral.js":
/*!*********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/Integral.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Integral; });
/* harmony import */ var _VertexIntegral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VertexIntegral */ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexIntegral.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
 // import VertexPolygonFilled from '../../DrawingObjects/VertexObject/VertexPolygon';




function Integral(webgl, color, numLines, transformOrLocation, diagramLimits) {
  // const serifSides = 30;
  // const serifRadius = 0.05;
  var vertices = new _VertexIntegral__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, numLines, true); // const serif = new VertexPolygonFilled(
  //   webgl,
  //   serifSides,
  //   serifRadius,
  //   0,
  //   new Point(0, 0),
  //   serifSides,
  // );

  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"](vertices, transform, color, diagramLimits);
}

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/RoundedSquareBracket.js":
/*!*********************************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/RoundedSquareBracket.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RoundedSquareBracket; });
/* harmony import */ var _VertexRoundedSquareBracket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VertexRoundedSquareBracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexRoundedSquareBracket.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");




function RoundedSquareBracket(webgl, color, side, numLines, transformOrLocation, diagramLimits) {
  var vertices = new _VertexRoundedSquareBracket__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, side, numLines);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"](vertices, transform, color, diagramLimits);
}

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/SquareBracket.js":
/*!**************************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/SquareBracket.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SquareBracket; });
/* harmony import */ var _VertexSquareBracket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VertexSquareBracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexSquareBracket.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");




function SquareBracket(webgl, color, side, numLines, transformOrLocation, diagramLimits) {
  var vertices = new _VertexSquareBracket__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, side, numLines);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"](vertices, transform, color, diagramLimits);
}

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexBar.js":
/*!**********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/VertexBar.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _VertexBracket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VertexBracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexBracket.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var VertexBar =
/*#__PURE__*/
function (_VertexBracket) {
  _inherits(VertexBar, _VertexBracket);

  function VertexBar() {
    _classCallCheck(this, VertexBar);

    return _possibleConstructorReturn(this, _getPrototypeOf(VertexBar).apply(this, arguments));
  }

  _createClass(VertexBar, [{
    key: "getPoints",
    value: function getPoints() {
      var w = 1 / 15;

      if (this.numLines > 1) {
        w /= this.numLines;
      }

      var leftPoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, this.mainHeight)];
      var rightPoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](w, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](w, this.mainHeight)];
      var maxX = w;
      return {
        leftPoints: leftPoints,
        rightPoints: rightPoints,
        maxX: maxX
      };
    }
  }]);

  return VertexBar;
}(_VertexBracket__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexBar);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexBrace.js":
/*!************************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/VertexBrace.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _VertexBracket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VertexBracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexBracket.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var VertexBrace =
/*#__PURE__*/
function (_VertexBracket) {
  _inherits(VertexBrace, _VertexBracket);

  function VertexBrace() {
    _classCallCheck(this, VertexBrace);

    return _possibleConstructorReturn(this, _getPrototypeOf(VertexBrace).apply(this, arguments));
  }

  _createClass(VertexBrace, [{
    key: "getPoints",
    value: function getPoints() {
      var w = 1 / 20;

      if (this.numLines > 1) {
        w /= this.numLines;
      }

      var r1 = w * 3;
      var r2 = r1 * 1.3;
      var p1 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](r1, 0);
      var p2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](w + r2 + w / 4, 0);
      var r1Angle = Math.PI / 2 * 0.8;
      var h = r1 * Math.sin(r1Angle);
      var r2Angle = Math.asin(h / r2);
      var segments = 5;
      var r1AngleStep = r1Angle / segments;
      var r2AngleStep = r2Angle / segments;
      var cornerR1Points = [];
      var cornerR2Points = [];

      for (var i = 0; i <= segments; i += 1) {
        cornerR1Points.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(r1, Math.PI - i * r1AngleStep).add(p1));
        cornerR2Points.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(r2, Math.PI - i * r2AngleStep).add(p2));
      }

      var width = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(r2, Math.PI - r2Angle).add(p2).x;
      var height = h;
      var top = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(width - w, this.mainHeight - height);
      var bottom = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, -1).translate(width - w, height);
      var middleBottom = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(-1, 1).translate(width, this.mainHeight / 2 - height * 1);
      var middleTop = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(-1, -1).translate(width, this.mainHeight / 2 + height * 1);
      var leftPoints = [].concat(_toConsumableArray(cornerR1Points.map(function (p) {
        return p.transformBy(bottom.m());
      }).reverse()), _toConsumableArray(cornerR2Points.map(function (p) {
        return p.transformBy(middleBottom.m());
      })), _toConsumableArray(cornerR2Points.map(function (p) {
        return p.transformBy(middleTop.m());
      }).reverse()), _toConsumableArray(cornerR1Points.map(function (p) {
        return p.transformBy(top.m());
      })));
      var rightPoints = [].concat(_toConsumableArray(cornerR2Points.map(function (p) {
        return p.transformBy(bottom.m());
      }).reverse()), _toConsumableArray(cornerR1Points.map(function (p) {
        return p.transformBy(middleBottom.m());
      })), _toConsumableArray(cornerR1Points.map(function (p) {
        return p.transformBy(middleTop.m());
      }).reverse()), _toConsumableArray(cornerR2Points.map(function (p) {
        return p.transformBy(top.m());
      })));
      return {
        leftPoints: leftPoints,
        rightPoints: rightPoints,
        maxX: width * 2 - w
      };
    }
  }]);

  return VertexBrace;
}(_VertexBracket__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexBrace);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexBracket.js":
/*!**************************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/VertexBracket.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../DrawingObjects/VertexObject/VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertexBracket =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexBracket, _VertexObject);

  _createClass(VertexBracket, [{
    key: "getPoints",
    value: function getPoints() {
      var w = 1 / this.numLines / 16;
      var r1 = w * 16 * this.numLines;
      var r2 = r1 * (1.4 - 0.4 * (1 - 1 / this.numLines)); // let r1 = 1;
      // let r2 = 1.5;
      // let w = 1 / 16;
      // if (this.numLines === 2) {
      //   r1 = 1.5;
      //   r2 = 2;
      //   w = 1 / 25;
      // }

      var mainHeight = this.mainHeight;
      var p1 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](r1, mainHeight / 2);
      var p2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](r2 + w, mainHeight / 2);
      var r1Angle = Math.asin(mainHeight / 2 / r1);
      var r2Angle = Math.asin(mainHeight / 2 / r2);
      var numSegments = 10 * this.numLines;
      var r1AngleStep = r1Angle * 2 / numSegments;
      var r2AngleStep = r2Angle * 2 / numSegments;
      var r1Points = [];
      var r2Points = [];

      for (var i = 0; i <= numSegments; i += 1) {
        r1Points.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(r1, Math.PI - r1Angle + i * r1AngleStep).add(p1));
        r2Points.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(r2, Math.PI - r2Angle + i * r2AngleStep).add(p2));
      }

      var maxX = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(r2, Math.PI - r2Angle).add(p2).x;
      return {
        leftPoints: r1Points,
        rightPoints: r2Points,
        maxX: maxX
      };
    }
  }]);

  function VertexBracket(webgl, side) {
    var _this;

    var numLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    _classCallCheck(this, VertexBracket);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexBracket).call(this, webgl));
    _this.glPrimative = _this.gl.TRIANGLE_STRIP;
    _this.numLines = numLines;
    _this.mainHeight = 1;

    var _this$getPoints = _this.getPoints(),
        leftPoints = _this$getPoints.leftPoints,
        rightPoints = _this$getPoints.rightPoints,
        maxX = _this$getPoints.maxX;

    var points1 = [];
    var points2 = [];
    var t; // const maxX = polarToRect(r2, Math.PI - r2Angle).add(p2).x;

    if (side === 'right') {
      t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(-1, 1).translate(maxX, 0);
    } else if (side === 'top') {
      t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(0, -_this.mainHeight / 2).rotate(-Math.PI / 2).translate(_this.mainHeight / 2, maxX);
    } else if (side === 'bottom') {
      t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(0, -_this.mainHeight / 2).rotate(Math.PI / 2).translate(_this.mainHeight / 2, -maxX);
    } else {
      t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
    }

    points1 = leftPoints.map(function (p) {
      return p.transformBy(t.m());
    });
    points2 = rightPoints.map(function (p) {
      return p.transformBy(t.m());
    });
    _this.points = [];
    points1.forEach(function (r1p, index) {
      var r2p = points2[index];

      _this.points.push(r1p.x);

      _this.points.push(r1p.y);

      _this.points.push(r2p.x);

      _this.points.push(r2p.y);
    });
    _this.border[0] = [];
    points1.forEach(function (p) {
      _this.border[0].push(p);
    });

    for (var i = points2.length - 1; i >= 0; i -= 1) {
      _this.border[0].push(points2[i]);
    }

    _this.setupBuffer();

    return _this;
  }

  return VertexBracket;
}(_DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexBracket);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexIntegral.js":
/*!***************************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/VertexIntegral.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../DrawingObjects/VertexObject/VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





function range(start, stop, step) {
  var out = [];

  for (var i = start; i <= stop + step * 0.5; i += step) {
    out.push(i);
  }

  return out;
}

var VertexIntegral =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexIntegral, _VertexObject);

  function VertexIntegral(webgl) {
    var _this;

    var lineHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var serif = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    _classCallCheck(this, VertexIntegral);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexIntegral).call(this, webgl));
    _this.glPrimative = _this.gl.TRIANGLE_STRIP; // let mul = 0.5;
    // if (lineHeight === 1) {
    //   mul = 1;
    // }

    var mul = 0.3;

    if (lineHeight < 5) {
      mul = 1 - Math.log(lineHeight) / 2;
    }

    var k = 20;
    var L = 1;
    var sigma = 0.07;
    var a = 0.003 * mul;
    var bias = 0.01 * mul;
    var xArray = range(-0.18, 0.18, 0.01);
    var yArray = xArray.map(function (x) {
      return L / (1 + Math.exp(-k * x));
    });
    var normDist = xArray.map(function (x) {
      return a / Math.sqrt(2 * Math.PI * Math.pow(sigma, 2)) * Math.exp(-Math.pow(x, 2) / (2 * Math.pow(sigma, 2)));
    });
    var xLeft = xArray.map(function (x, index) {
      return x - normDist[index] - bias;
    });
    var xRight = xArray.map(function (x, index) {
      return x + normDist[index] + bias;
    });
    var serifRadius = 0.03 * mul;
    var serifPoints = 30; // calculate upper serif properites

    var num = xLeft.length;
    var upperSerifPoint = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](xLeft[num - 1], yArray[num - 1]);
    var gradient = k * yArray[num - 1] * (L - yArray[num - 1]);
    var theta = Math.atan(gradient);
    var alpha = Math.PI / 2 - theta;
    var center = upperSerifPoint.add(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](serifRadius * Math.cos(alpha), -serifRadius * Math.sin(alpha)));
    var dAngle = Math.PI * 2 / (serifPoints - 1);
    var startAngle = Math.PI / 2 + theta; // calculate lower serif properties

    var lowerSerifCenter = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-center.x, L - center.y);
    var lowerSerifStartAngle = -alpha; // lower serif

    if (serif) {
      _this.border.push([]);

      _this.border.push([]);

      for (var i = 0; i < serifPoints; i += 1) {
        _this.points.push(lowerSerifCenter.x);

        _this.points.push(lowerSerifCenter.y);

        var angle = lowerSerifStartAngle + dAngle * i;
        var perimeterPoint = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](lowerSerifCenter.x + serifRadius * Math.cos(angle), lowerSerifCenter.y + serifRadius * Math.sin(angle));

        _this.points.push(perimeterPoint.x);

        _this.points.push(perimeterPoint.y);

        _this.border[1].push(perimeterPoint);
      }
    }

    var borderLeft = [];
    var borderRight = [];
    yArray.map(function (y, index) {
      var pLeft = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](xLeft[index], y);
      var pRight = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](xRight[index], y);

      _this.points.push(pRight.x);

      _this.points.push(pRight.y);

      _this.points.push(pLeft.x);

      _this.points.push(pLeft.y);

      borderLeft.push(pLeft._dup());
      borderRight.push(pRight._dup());
      return undefined;
    }); // upper serif

    if (serif) {
      for (var _i = 0; _i < serifPoints; _i += 1) {
        _this.points.push(center.x);

        _this.points.push(center.y);

        var _angle = startAngle + dAngle * _i;

        var _perimeterPoint = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](center.x + serifRadius * Math.cos(_angle), center.y + serifRadius * Math.sin(_angle));

        _this.points.push(_perimeterPoint.x);

        _this.points.push(_perimeterPoint.y);

        _this.border[2].push(_perimeterPoint);
      }
    }

    _this.border[0] = borderLeft.concat(borderRight.reverse());

    _this.border[0].push(_this.border[0][0]._dup()); // normalize all points to have bottom left corner at 0,0
    // and height to be 1.


    var bounds = _this.getGLBoundingRect(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().matrix());

    var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(-bounds.left, -bounds.bottom).scale(1 / bounds.height, 1 / bounds.height);

    for (var _i2 = 0; _i2 < _this.border.length; _i2 += 1) {
      var border = _this.border[_i2];

      for (var j = 0; j < border.length; j += 1) {
        _this.border[_i2][j] = _this.border[_i2][j].transformBy(t.matrix());
      }
    }

    for (var _i3 = 0; _i3 < _this.points.length; _i3 += 2) {
      var p = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](_this.points[_i3], _this.points[_i3 + 1]);
      var newP = p.transformBy(t.matrix());
      _this.points[_i3] = newP.x;
      _this.points[_i3 + 1] = newP.y;
    } // this.points[0] = new Point(0, 0);
    // this.points[1] = new Point(0, 0.5);
    // this.points[2] = new Point(0.5, 0.5);


    _this.setupBuffer();

    return _this;
  }

  return VertexIntegral;
}(_DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexIntegral);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexRoundedSquareBracket.js":
/*!***************************************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/VertexRoundedSquareBracket.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _VertexBracket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VertexBracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexBracket.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var VertexRoundedSquareBracket =
/*#__PURE__*/
function (_VertexBracket) {
  _inherits(VertexRoundedSquareBracket, _VertexBracket);

  function VertexRoundedSquareBracket() {
    _classCallCheck(this, VertexRoundedSquareBracket);

    return _possibleConstructorReturn(this, _getPrototypeOf(VertexRoundedSquareBracket).apply(this, arguments));
  }

  _createClass(VertexRoundedSquareBracket, [{
    key: "getPoints",
    value: function getPoints() {
      var w = 1 / 20;

      if (this.numLines > 1) {
        w /= this.numLines;
      }

      var r1 = w * 3;
      var r2 = r1 * 1.3;
      var p1 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](r1, 0);
      var p2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](w + r2 + w / 4, 0);
      var r1Angle = Math.PI / 2 * 0.8;
      var h = r1 * Math.sin(r1Angle);
      var r2Angle = Math.asin(h / r2);
      var segments = 5;
      var r1AngleStep = r1Angle / segments;
      var r2AngleStep = r2Angle / segments;
      var cornerR1Points = [];
      var cornerR2Points = [];

      for (var i = 0; i <= segments; i += 1) {
        cornerR1Points.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(r1, Math.PI - i * r1AngleStep).add(p1));
        cornerR2Points.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(r2, Math.PI - i * r2AngleStep).add(p2));
      }

      var width = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(r2, Math.PI - r2Angle).add(p2).x;
      var height = h;
      var top = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(0, this.mainHeight - height);
      var bottom = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, -1).translate(0, height);
      var leftPoints = [].concat(_toConsumableArray(cornerR1Points.map(function (p) {
        return p.transformBy(bottom.m());
      }).reverse()), _toConsumableArray(cornerR1Points.map(function (p) {
        return p.transformBy(top.m());
      })));
      var rightPoints = [].concat(_toConsumableArray(cornerR2Points.map(function (p) {
        return p.transformBy(bottom.m());
      }).reverse()), _toConsumableArray(cornerR2Points.map(function (p) {
        return p.transformBy(top.m());
      })));
      return {
        leftPoints: leftPoints,
        rightPoints: rightPoints,
        maxX: width
      };
    }
  }]);

  return VertexRoundedSquareBracket;
}(_VertexBracket__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexRoundedSquareBracket);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexSquareBracket.js":
/*!********************************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Equation/Symbols/VertexSquareBracket.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _VertexBracket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VertexBracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/VertexBracket.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var VertexSquareBracket =
/*#__PURE__*/
function (_VertexBracket) {
  _inherits(VertexSquareBracket, _VertexBracket);

  function VertexSquareBracket() {
    _classCallCheck(this, VertexSquareBracket);

    return _possibleConstructorReturn(this, _getPrototypeOf(VertexSquareBracket).apply(this, arguments));
  }

  _createClass(VertexSquareBracket, [{
    key: "getPoints",
    value: function getPoints() {
      var w = 1 / 30;

      if (this.numLines > 1) {
        w /= this.numLines;
      }

      var tail = w * 4;
      var leftPoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tail, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, this.mainHeight), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tail, this.mainHeight)];
      var rightPoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tail, w), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](w, w), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](w, this.mainHeight - w), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tail, this.mainHeight - w)];
      var maxX = tail;
      return {
        leftPoints: leftPoints,
        rightPoints: rightPoints,
        maxX: maxX
      };
    }
  }]);

  return VertexSquareBracket;
}(_VertexBracket__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexSquareBracket);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Fan.js":
/*!***********************************************!*\
  !*** ./src/js/diagram/DiagramElements/Fan.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawingObjects_VertexObject_VertexFan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexFan */ "./src/js/diagram/DrawingObjects/VertexObject/VertexFan.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");





function Fan(webgl, points, color, transformOrLocation, diagramLimits) {
  var vertexLine = new _DrawingObjects_VertexObject_VertexFan__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, points);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"](vertexLine, transform, color, diagramLimits);
}

/* harmony default export */ __webpack_exports__["default"] = (Fan);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/HorizontalLine.js":
/*!**********************************************************!*\
  !*** ./src/js/diagram/DiagramElements/HorizontalLine.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawingObjects_VertexObject_VertexHorizontalLine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexHorizontalLine */ "./src/js/diagram/DrawingObjects/VertexObject/VertexHorizontalLine.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");





function HorizontalLine(webgl, start, length, width, rotation, color, transformOrLocation, diagramLimits) {
  var vertexLine = new _DrawingObjects_VertexObject_VertexHorizontalLine__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, start, length, width, rotation);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"](vertexLine, transform, color, diagramLimits);
}

/* harmony default export */ __webpack_exports__["default"] = (HorizontalLine);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Lines.js":
/*!*************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Lines.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawingObjects_VertexObject_VertexLines__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexLines */ "./src/js/diagram/DrawingObjects/VertexObject/VertexLines.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");





function Lines(webgl, linePairs, numLinesThick, color, transformOrLocation, diagramLimits) {
  var vertexLine = new _DrawingObjects_VertexObject_VertexLines__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, linePairs, numLinesThick);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"](vertexLine, transform, color, diagramLimits);
}

/* harmony default export */ __webpack_exports__["default"] = (Lines);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Plot/Axis.js":
/*!*****************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Plot/Axis.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObjects_VAxis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VertexObjects/VAxis */ "./src/js/diagram/DiagramElements/Plot/VertexObjects/VAxis.js");
/* harmony import */ var _VertexObjects_VTickMarks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VertexObjects/VTickMarks */ "./src/js/diagram/DiagramElements/Plot/VertexObjects/VTickMarks.js");
/* harmony import */ var _AxisProperties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AxisProperties */ "./src/js/diagram/DiagramElements/Plot/AxisProperties.js");
/* harmony import */ var _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../DrawingObjects/TextObject/TextObject */ "./src/js/diagram/DrawingObjects/TextObject/TextObject.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../DrawContext2D */ "./src/js/diagram/DrawContext2D.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






 // import TextObject from '../../textObjects/TextObject';




var Axis =
/*#__PURE__*/
function (_DiagramElementCollec) {
  _inherits(Axis, _DiagramElementCollec);

  function Axis(webgl, drawContext2D) {
    var _this;

    var axisProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _AxisProperties__WEBPACK_IMPORTED_MODULE_5__["AxisProperties"]();
    var transform = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]();
    var diagramLimits = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Rect"](-1, 1, 2, 2);

    _classCallCheck(this, Axis);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Axis).call(this, transform, diagramLimits));
    _this.props = axisProperties;
    _this.webgl = webgl;
    _this.diagramLimits = diagramLimits;
    _this.drawContext2D = drawContext2D;

    _this.build();

    return _this;
  }

  _createClass(Axis, [{
    key: "rebuild",
    value: function rebuild() {
      this.drawOrder = [];
      this.build();
    }
  }, {
    key: "build",
    value: function build() {
      var _this$props = this.props,
          minorTicks = _this$props.minorTicks,
          majorTicks = _this$props.majorTicks,
          minorGrid = _this$props.minorGrid,
          majorGrid = _this$props.majorGrid;

      if (majorTicks.mode === 'auto') {
        this.props.generateAutoMajorTicks();
      }

      if (minorTicks.mode === 'auto') {
        this.props.generateAutoMinorTicks();
      }

      var xRatio = 2 / this.diagramLimits.width; // const xRatio = 1;
      // const yRatio = 2 / diagramLimits.height;

      var cMajorTicksStart = this.props.valueToClip(majorTicks.start);
      var cMinorTicksStart = this.props.valueToClip(minorTicks.start);
      var majorTicksNum = this.props.getMajorNum();
      var minorTicksNum = this.props.getMinorNum(); // Grid

      this.addTicksOrGrid('minorGrid', this.webgl, minorGrid, minorTicksNum, minorTicks.step, cMinorTicksStart, xRatio, this.diagramLimits);
      this.addTicksOrGrid('majorGrid', this.webgl, majorGrid, majorTicksNum, majorTicks.step, cMajorTicksStart, xRatio, this.diagramLimits); // Ticks

      this.addTicksOrGrid('minorTicks', this.webgl, minorTicks, minorTicksNum, minorTicks.step, cMinorTicksStart, xRatio, this.diagramLimits);
      this.addTicksOrGrid('majorTicks', this.webgl, majorTicks, majorTicksNum, majorTicks.step, cMajorTicksStart, xRatio, this.diagramLimits); // Axis Line

      var axis = new _VertexObjects_VAxis__WEBPACK_IMPORTED_MODULE_3__["default"](this.webgl, this.props);
      this.add('line', new _Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElementPrimative"](axis, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"](), this.props.color, this.diagramLimits));
      var font = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["DiagramFont"](this.props.titleFontFamily, 'normal', this.props.titleFontSize, this.props.titleFontWeight, 'center', 'middle', this.props.titleFontColor);
      var titleText = [new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["DiagramText"](new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0).transformBy(new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]().rotate(this.props.rotation).matrix()), this.props.title, font)];
      var title = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["TextObject"](this.drawContext2D, titleText);
      this.add('title', new _Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElementPrimative"](title, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]().rotate(this.props.rotation).translate(this.props.titleOffset.x, this.props.titleOffset.y), [0.5, 0.5, 0.5, 1], this.diagramLimits)); // Labels

      this.addTickLabels('major', this.drawContext2D, majorTicks, this.props.generateMajorLabels.bind(this.props), this.diagramLimits, this.props.majorTicks.labelOffset);
      this.addTickLabels('minor', this.drawContext2D, minorTicks, this.props.generateMinorLabels.bind(this.props), this.diagramLimits, this.props.minorTicks.labelOffset);
    }
  }, {
    key: "toClip",
    value: function toClip(value) {
      return this.props.toClip(value);
    }
  }, {
    key: "valueToClip",
    value: function valueToClip(value) {
      return this.props.valueToClip(value);
    }
  }, {
    key: "addTicksOrGrid",
    value: function addTicksOrGrid(name, webgl, ticksOrGrid, num, step, clipStart, xRatio, diagramLimits) {
      if (ticksOrGrid.mode !== 'off') {
        var ticks = new _VertexObjects_VTickMarks__WEBPACK_IMPORTED_MODULE_4__["default"](webgl, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"]( // clipStart - ticksOrGrid.width / 2 * xRatio,
        clipStart, this.props.start.y), this.props.rotation, num, this.toClip(step), ticksOrGrid.length, ticksOrGrid.width, ticksOrGrid.offset);
        this.add(name, new _Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElementPrimative"](ticks, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]().scale(1, 1).rotate(0).translate(0, 0), ticksOrGrid.color, diagramLimits)); // if (name === 'majorTicks') {
        //   console.log(ticks)
        // }
      }
    }
  }, {
    key: "addTickLabels",
    value: function addTickLabels(name, drawContext2D, ticks, labelGenerator, diagramLimits, offset) {
      if (ticks.labelMode === 'auto') {
        labelGenerator();
      }

      var font = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["DiagramFont"](ticks.fontFamily, 'normal', ticks.fontSize, ticks.fontWeight, ticks.labelsHAlign, ticks.labelsVAlign, ticks.fontColor);

      if (this.props.rotation > Math.PI / 2 * 0.95) {
        font.alignV = 'middle';
        font.alignH = 'right';
      }

      var dText = [];

      for (var i = 0; i < ticks.labels.length; i += 1) {
        dText.push(new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["DiagramText"](new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](this.valueToClip(ticks.start + i * ticks.step), 0).transformBy(new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]().rotate(this.props.rotation).matrix()), ticks.labels[i], font));
      }

      var axisLabels = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["TextObject"](drawContext2D, dText);
      this.add("label_".concat(name), new _Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElementPrimative"](axisLabels, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]().scale(1, 1).rotate(0).translate(offset.x, offset.y), [0.5, 0.5, 0.5, 1], diagramLimits)); // const label = new TextObject(
      //   drawContext2D,
      //   ticks.labels[i],
      //   new Point(
      //     this.valueToClip(ticks.start + i * ticks.step),
      //     0,
      //   ).transformBy(new Transform().rotate(this.props.rotation).matrix()),
      //   [ticks.labelsHAlign, ticks.labelsVAlign],
      //   ticks.labelOffset,
      // );
      // label.fontSize = ticks.fontSize;
      // label.fontFamily = ticks.fontFamily;
      // label.fontWeight = ticks.fontWeight;
      // this.add(`label_${name}_${i}`, new DiagramElementPrimative(
      //   label,
      //   new Transform().scale(1, 1).rotate(0).translate(0, 0),
      //   [0.5, 0.5, 0.5, 1],
      //   diagramLimits,
      // ));
    }
  }]);

  return Axis;
}(_Element__WEBPACK_IMPORTED_MODULE_0__["DiagramElementCollection"]);

/* harmony default export */ __webpack_exports__["default"] = (Axis);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Plot/AxisProperties.js":
/*!***************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Plot/AxisProperties.js ***!
  \***************************************************************/
/*! exports provided: AxisProperties, GridProperties, TickProperties */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisProperties", function() { return AxisProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridProperties", function() { return GridProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TickProperties", function() { return TickProperties; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/math */ "./src/js/tools/math.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



var defaultColor = [0.7, 0.7, 0.7, 1];

var GridProperties = // Clip Space
// General
function GridProperties() {
  _classCallCheck(this, GridProperties);

  this.length = 1;
  this.width = 0.01;
  this.color = defaultColor;
  this.mode = 'on';
  this.offset = 0;
};

var TickProperties =
/*#__PURE__*/
function (_GridProperties) {
  _inherits(TickProperties, _GridProperties);

  // Axis Space
  // Clip Space;
  // General
  function TickProperties() {
    var _this;

    _classCallCheck(this, TickProperties);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TickProperties).call(this));
    _this.start = 0;
    _this.step = 0.1;
    _this.length = 0.05;
    _this.width = 0.01;
    _this.offset = 0;
    _this.labelOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    _this.color = defaultColor;
    _this.labels = [];
    _this.labelMode = 'auto';
    _this.labelsHAlign = 'center';
    _this.labelsVAlign = 'middle';
    _this.mode = 'on';
    _this.fontFamily = 'Helvetica Neue';
    _this.fontWeight = '400';
    _this.fontSize = 0.1;
    _this.fontColor = defaultColor;
    return _this;
  }

  return TickProperties;
}(GridProperties);

var AxisProperties =
/*#__PURE__*/
function () {
  function AxisProperties() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var rotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, AxisProperties);

    this.name = name; // Clip Space

    this.start = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    this.length = 1;
    this.width = 0.01;
    this.rotation = rotation;
    this.color = [0.5, 0.5, 0.5, 1];
    this.title = '';
    this.titleOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.length / 2, -0.1);
    this.titleRotation = 0;
    this.limits = {
      min: 0,
      max: 1
    };
    this.logarithmic = false;
    this.majorTicks = new TickProperties();
    this.minorTicks = new TickProperties();
    this.minorTicks.labelMode = 'off';
    this.majorGrid = new GridProperties();
    this.minorGrid = new GridProperties();
    this.titleFontFamily = 'Helvetica Neue';
    this.titleFontWeight = '400';
    this.titleFontSize = 0.13;
    this.titleFontColor = defaultColor;
  }

  _createClass(AxisProperties, [{
    key: "getNum",
    value: function getNum(start, step) {
      return Math.floor((this.limits.max - start) / step) + 1;
    }
  }, {
    key: "getMajorNum",
    value: function getMajorNum() {
      return this.getNum(this.majorTicks.start, this.majorTicks.step);
    }
  }, {
    key: "getMinorNum",
    value: function getMinorNum() {
      return this.getNum(this.minorTicks.start, this.minorTicks.step);
    }
  }, {
    key: "generateAuto",
    value: function generateAuto() {
      var approximateNum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      // const approximateNum = 10;
      var range = this.limits.max - this.limits.min;
      var step = range / approximateNum;
      var orderOfMagnitude = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(Math.floor(Math.log10(step)), 0);
      step = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(step, -orderOfMagnitude);
      var start = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(this.limits.min, -orderOfMagnitude);

      if (start < this.limits.min) {
        start += Math.pow(10, orderOfMagnitude);
      }

      if (this.getNum(start, step) > 11) {
        step *= 2;
      }

      return {
        start: start,
        step: step
      };
    }
  }, {
    key: "generateAutoMajorTicks",
    value: function generateAutoMajorTicks() {
      var approximateNum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

      var _this$generateAuto = this.generateAuto(approximateNum),
          start = _this$generateAuto.start,
          step = _this$generateAuto.step;

      this.majorTicks.start = start;
      this.majorTicks.step = step;
    }
  }, {
    key: "generateAutoMinorTicks",
    value: function generateAutoMinorTicks() {
      var approximateNum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;

      var _this$generateAuto2 = this.generateAuto(approximateNum),
          start = _this$generateAuto2.start,
          step = _this$generateAuto2.step;

      this.minorTicks.start = start;
      this.minorTicks.step = step;
    }
  }, {
    key: "toClip",
    value: function toClip(value) {
      var ratio = this.length / (this.limits.max - this.limits.min);
      return value * ratio;
    }
  }, {
    key: "valueToClip",
    value: function valueToClip(value) {
      return this.toClip(value - this.limits.min) + this.start.x;
    }
  }, {
    key: "getMajorLabels",
    value: function getMajorLabels() {
      var labels = [];

      for (var i = 0, j = this.getMajorNum(); i < j; i += 1) {
        var value = this.majorTicks.start + i * this.majorTicks.step;
        labels.push(value.toString());
      }

      return labels;
    }
  }, {
    key: "generateMajorLabels",
    value: function generateMajorLabels() {
      this.majorTicks.labels = this.getMajorLabels();
    }
  }, {
    key: "getMinorLabels",
    value: function getMinorLabels() {
      var labels = [];

      for (var i = 0, j = this.getMinorNum(); i < j; i += 1) {
        var value = this.minorTicks.start + i * this.minorTicks.step;
        labels.push(value.toString());
      }

      return labels;
    }
  }, {
    key: "generateMinorLabels",
    value: function generateMinorLabels() {
      this.minorTicks.labels = this.getMinorLabels();
    }
  }]);

  return AxisProperties;
}();



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Plot/VertexObjects/VAxis.js":
/*!********************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Plot/VertexObjects/VAxis.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawingObjects_VertexObject_Triangles_TRIHoriztonalLine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../DrawingObjects/VertexObject/Triangles/TRIHoriztonalLine */ "./src/js/diagram/DrawingObjects/VertexObject/Triangles/TRIHoriztonalLine.js");
/* harmony import */ var _AxisProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AxisProperties */ "./src/js/diagram/DiagramElements/Plot/AxisProperties.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../DrawingObjects/VertexObject/VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }







var VAxis =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VAxis, _VertexObject);

  function VAxis(webgl) {
    var _this;

    var axisProperties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _AxisProperties__WEBPACK_IMPORTED_MODULE_1__["AxisProperties"]();

    _classCallCheck(this, VAxis);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VAxis).call(this, webgl));
    var a = axisProperties;
    var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]().rotate(a.rotation).translate(a.start.x, a.start.y).matrix();

    if (a.width > 0) {
      var result = Object(_DrawingObjects_VertexObject_Triangles_TRIHoriztonalLine__WEBPACK_IMPORTED_MODULE_0__["default"])(new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](0, 0), a.length, a.width, 0);
      var points = result.points,
          border = result.border;
      _this.points = points;
      _this.border = [border];
    }

    _this.transform(t);

    _this.setupBuffer();

    return _this;
  }

  return VAxis;
}(_DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_4__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VAxis);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Plot/VertexObjects/VTickMarks.js":
/*!*************************************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Plot/VertexObjects/VTickMarks.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawingObjects_VertexObject_Triangles_TRIParallelLines__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../DrawingObjects/VertexObject/Triangles/TRIParallelLines */ "./src/js/diagram/DrawingObjects/VertexObject/Triangles/TRIParallelLines.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../DrawingObjects/VertexObject/VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






var VTickMarks =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VTickMarks, _VertexObject);

  function VTickMarks(webgl, start, rotation, num, spacing, length, width, offset) {
    var _this;

    _classCallCheck(this, VTickMarks);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VTickMarks).call(this, webgl));
    var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]().rotate(rotation).translate(0, 0).matrix();
    var result = Object(_DrawingObjects_VertexObject_Triangles_TRIParallelLines__WEBPACK_IMPORTED_MODULE_0__["default"])(num, spacing, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](start.x, start.y + offset), length, width, false, false);
    var points = result.points,
        border = result.border;
    _this.points = points;
    _this.border = border;

    _this.transform(t);

    _this.setupBuffer();

    return _this;
  }

  return VTickMarks;
}(_DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VTickMarks);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/PolyLine.js":
/*!****************************************************!*\
  !*** ./src/js/diagram/DiagramElements/PolyLine.js ***!
  \****************************************************/
/*! exports provided: PolyLine, PolyLineCorners */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyLine", function() { return PolyLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyLineCorners", function() { return PolyLineCorners; });
/* harmony import */ var _DrawingObjects_VertexObject_VertexPolyLine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexPolyLine */ "./src/js/diagram/DrawingObjects/VertexObject/VertexPolyLine.js");
/* harmony import */ var _DrawingObjects_VertexObject_VertexPolyLineCorners__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexPolyLineCorners */ "./src/js/diagram/DrawingObjects/VertexObject/VertexPolyLineCorners.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");






function PolyLine(webgl, points, close, lineWidth, color, borderToPoint, transformOrLocation, diagramLimits) {
  var vertexLine = new _DrawingObjects_VertexObject_VertexPolyLine__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, points, close, lineWidth, borderToPoint);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_3__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_3__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementPrimative"](vertexLine, transform, color, diagramLimits);
}

function PolyLineCorners(webgl, points, close, cornerLength, lineWidth, color, transformOrLocation, diagramLimits) {
  var vertexLineCorners = new _DrawingObjects_VertexObject_VertexPolyLineCorners__WEBPACK_IMPORTED_MODULE_1__["default"](webgl, points, close, cornerLength, lineWidth);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_3__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_3__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementPrimative"](vertexLineCorners, transform, color, diagramLimits);
}



/***/ }),

/***/ "./src/js/diagram/DiagramElements/Polygon.js":
/*!***************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Polygon.js ***!
  \***************************************************/
/*! exports provided: Polygon, PolygonFilled, PolygonLine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polygon", function() { return Polygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolygonFilled", function() { return PolygonFilled; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolygonLine", function() { return PolygonLine; });
/* harmony import */ var _DrawingObjects_VertexObject_VertexPolygon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexPolygon */ "./src/js/diagram/DrawingObjects/VertexObject/VertexPolygon.js");
/* harmony import */ var _DrawingObjects_VertexObject_VertexPolygonFilled__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexPolygonFilled */ "./src/js/diagram/DrawingObjects/VertexObject/VertexPolygonFilled.js");
/* harmony import */ var _DrawingObjects_VertexObject_VertexPolygonLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexPolygonLine */ "./src/js/diagram/DrawingObjects/VertexObject/VertexPolygonLine.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");







function Polygon(webgl, numSides, radius, lineWidth, rotation, direction, numSidesToDraw, color, transformOrLocation, diagramLimits) {
  var vertexLine = new _DrawingObjects_VertexObject_VertexPolygon__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, numSides, radius, lineWidth, rotation, new _tools_g2__WEBPACK_IMPORTED_MODULE_4__["Point"](0, 0), numSidesToDraw, direction);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_4__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_4__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementPrimative"](vertexLine, transform, color, diagramLimits);
}

function PolygonFilled(webgl, numSides, radius, rotation, numSidesToDraw, color, transformOrLocation, diagramLimits) {
  var textureLocation = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : '';
  var textureCoords = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : new _tools_g2__WEBPACK_IMPORTED_MODULE_4__["Rect"](0, 0, 1, 1);
  var onLoad = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;
  var vertexLineCorners = new _DrawingObjects_VertexObject_VertexPolygonFilled__WEBPACK_IMPORTED_MODULE_1__["default"](webgl, numSides, radius, rotation, new _tools_g2__WEBPACK_IMPORTED_MODULE_4__["Point"](0, 0), numSidesToDraw, textureLocation, textureCoords);

  if (textureLocation) {
    vertexLineCorners.onLoad = onLoad;
  }

  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_4__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_4__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementPrimative"](vertexLineCorners, transform, color, diagramLimits);
}

function PolygonLine(webgl, numSides, radius, rotation, direction, numSidesToDraw, numLines, color, transformOrLocation, diagramLimits) {
  var vertexLine = new _DrawingObjects_VertexObject_VertexPolygonLine__WEBPACK_IMPORTED_MODULE_2__["default"](webgl, numSides, radius, rotation, new _tools_g2__WEBPACK_IMPORTED_MODULE_4__["Point"](0, 0), numSidesToDraw, direction, numLines);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_4__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_4__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementPrimative"](vertexLine, transform, color, diagramLimits);
}



/***/ }),

/***/ "./src/js/diagram/DiagramElements/RadialLines.js":
/*!*******************************************************!*\
  !*** ./src/js/diagram/DiagramElements/RadialLines.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawingObjects_VertexObject_VertexRadialLines__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexRadialLines */ "./src/js/diagram/DrawingObjects/VertexObject/VertexRadialLines.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");





function RadialLines(webgl) {
  var innerRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var outerRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.05;
  var dAngle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Math.PI / 4;
  var color = arguments.length > 5 ? arguments[5] : undefined;
  var transformOrLocation = arguments.length > 6 ? arguments[6] : undefined;
  var diagramLimits = arguments.length > 7 ? arguments[7] : undefined;
  var vertexLine = new _DrawingObjects_VertexObject_VertexRadialLines__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, innerRadius, outerRadius, width, dAngle, Math.PI * 2);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"](vertexLine, transform, color, diagramLimits);
}

/* harmony default export */ __webpack_exports__["default"] = (RadialLines);

/***/ }),

/***/ "./src/js/diagram/DiagramElements/RectangleFilled.js":
/*!***********************************************************!*\
  !*** ./src/js/diagram/DiagramElements/RectangleFilled.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RectangleFilled; });
/* harmony import */ var _DrawingObjects_VertexObject_VertexRectangleFilled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexRectangleFilled */ "./src/js/diagram/DrawingObjects/VertexObject/VertexRectangleFilled.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");




function RectangleFilled(webgl, topLeft, width, height, cornerRadius, cornerSides, color, transformOrLocation, diagramLimits) {
  var vertexRectangle = new _DrawingObjects_VertexObject_VertexRectangleFilled__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, topLeft, width, height, cornerRadius, cornerSides);
  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"](vertexRectangle, transform, color, diagramLimits);
}

/***/ }),

/***/ "./src/js/diagram/DiagramElements/Text.js":
/*!************************************************!*\
  !*** ./src/js/diagram/DiagramElements/Text.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawingObjects_VertexObject_VertexText__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexText */ "./src/js/diagram/DrawingObjects/VertexObject/VertexText.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
// import VertexPolygon from '../DrawingObjects/VertexObject/VertexPolygon';
 // import VertexPolygonLine from '../DrawingObjects/VertexObject/VertexPolygonLine';






function Text(webgl, diagramLimits, optionsIn) {
  var defaultOptions = {
    position: new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](0, 0),
    color: [1, 0, 0, 1]
  };
  var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, optionsIn);

  if (options.transform == null) {
    options.transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]('Text').translate(0, 0);
  }

  if (options.position != null) {
    options.transform.updateTranslation(options.position);
  }

  var vertexText = new _DrawingObjects_VertexObject_VertexText__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, options); // let transform = new Transform();
  // if (transformOrLocation instanceof Point) {
  //   transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  // } else {
  //   transform = transformOrLocation._dup();
  // }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"](vertexText, options.transform, options.color, diagramLimits);
}

/* harmony default export */ __webpack_exports__["default"] = (Text);

/***/ }),

/***/ "./src/js/diagram/DiagramEquation/DiagramEquation.js":
/*!***********************************************************!*\
  !*** ./src/js/diagram/DiagramEquation/DiagramEquation.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DiagramEquation; });
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../DrawContext2D */ "./src/js/diagram/DrawContext2D.js");
/* harmony import */ var _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../DrawingObjects/TextObject/TextObject */ "./src/js/diagram/DrawingObjects/TextObject/TextObject.js");
/* harmony import */ var _DiagramElements_Equation_Symbols_Integral__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../DiagramElements/Equation/Symbols/Integral */ "./src/js/diagram/DiagramElements/Equation/Symbols/Integral.js");
/* harmony import */ var _DiagramElements_Equation_Symbols_Bracket__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../DiagramElements/Equation/Symbols/Bracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/Bracket.js");
/* harmony import */ var _DiagramElements_Equation_Symbols_Bar__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../DiagramElements/Equation/Symbols/Bar */ "./src/js/diagram/DiagramElements/Equation/Symbols/Bar.js");
/* harmony import */ var _DiagramElements_Equation_Symbols_SquareBracket__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../DiagramElements/Equation/Symbols/SquareBracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/SquareBracket.js");
/* harmony import */ var _DiagramElements_Equation_Symbols_Brace__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../DiagramElements/Equation/Symbols/Brace */ "./src/js/diagram/DiagramElements/Equation/Symbols/Brace.js");
/* harmony import */ var _DiagramElements_Equation_Symbols_RoundedSquareBracket__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../DiagramElements/Equation/Symbols/RoundedSquareBracket */ "./src/js/diagram/DiagramElements/Equation/Symbols/RoundedSquareBracket.js");
/* harmony import */ var _DiagramElements_Equation_EquationForm__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../DiagramElements/Equation/EquationForm */ "./src/js/diagram/DiagramElements/Equation/EquationForm.js");
/* harmony import */ var _DiagramElements_Equation_GLEquation__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../DiagramElements/Equation/GLEquation */ "./src/js/diagram/DiagramElements/Equation/GLEquation.js");
/* harmony import */ var _DiagramElements_Equation_Equation__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../DiagramElements/Equation/Equation */ "./src/js/diagram/DiagramElements/Equation/Equation.js");
/* harmony import */ var _DiagramElements_Equation_HTMLEquation__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../DiagramElements/Equation/HTMLEquation */ "./src/js/diagram/DiagramElements/Equation/HTMLEquation.js");
/* harmony import */ var _DiagramObjects_EqnNavigator__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../DiagramObjects/EqnNavigator */ "./src/js/diagram/DiagramObjects/EqnNavigator.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



















var DiagramEquation =
/*#__PURE__*/
function () {
  function DiagramEquation(shapes, animateNextFrame) {
    _classCallCheck(this, DiagramEquation);

    this.webgl = shapes.webgl;
    this.draw2D = shapes.draw2D;
    this.limits = shapes.limits;
    this.shapes = shapes;
    this.animateNextFrame = animateNextFrame;
  } // deprecate


  _createClass(DiagramEquation, [{
    key: "elements",
    value: function elements(elems) {
      var colorOrFont = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var firstTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]('elements');
      return Object(_DiagramElements_Equation_GLEquation__WEBPACK_IMPORTED_MODULE_13__["createEquationElements"])(elems, this.draw2D, colorOrFont, this.limits, firstTransform);
    } // deprecate

  }, {
    key: "vinculum",
    value: function vinculum() {
      var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [1, 1, 1, 1];
      return this.shapes.horizontalLine(new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), 1, 1, 0, color, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]('vinculum').scale(1, 1).translate(0, 0));
    } // deprecate

  }, {
    key: "strike",
    value: function strike() {
      var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [1, 1, 1, 1];
      return this.shapes.horizontalLine(new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), 1, 1, 0, color, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]('strike').scale(1, 1).rotate(0).translate(0, 0));
    } // deprecate

  }, {
    key: "xStrike",
    value: function xStrike() {
      var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [1, 1, 1, 1];
      var cross = this.shapes.collection(new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]('strike').scale(1, 1).rotate(0).translate(0, 0));
      cross.color = color;
      var strike1 = this.shapes.horizontalLine(new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), 1, 1, 0, color, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]('strike').scale(1, 1).rotate(0).translate(0, 0));

      var strike2 = strike1._dup();

      cross.add('s1', strike1);
      cross.add('s2', strike2);
      return cross;
    } // deprecate

  }, {
    key: "integral",
    value: function integral() {
      var numLines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1, 1, 1, 1];
      return new _DiagramElements_Equation_Symbols_Integral__WEBPACK_IMPORTED_MODULE_6__["default"](this.webgl, color, numLines, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]('integral').scale(1, 1).translate(0, 0), this.limits);
    } // deprecate

  }, {
    key: "bracket",
    value: function bracket(side) {
      var numLines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 1, 1, 1];
      return new _DiagramElements_Equation_Symbols_Bracket__WEBPACK_IMPORTED_MODULE_7__["default"](this.webgl, color, side, numLines, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]('bracket').scale(1, 1).translate(0, 0), this.limits);
    } // deprecate

  }, {
    key: "bar",
    value: function bar(side) {
      var numLines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 1, 1, 1];
      return new _DiagramElements_Equation_Symbols_Bar__WEBPACK_IMPORTED_MODULE_8__["default"](this.webgl, color, side, numLines, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]('bar').scale(1, 1).translate(0, 0), this.limits);
    } // deprecate

  }, {
    key: "squareBracket",
    value: function squareBracket(side) {
      var numLines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 1, 1, 1];
      return new _DiagramElements_Equation_Symbols_SquareBracket__WEBPACK_IMPORTED_MODULE_9__["default"](this.webgl, color, side, numLines, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]('bar').scale(1, 1).translate(0, 0), this.limits);
    } // deprecate

  }, {
    key: "brace",
    value: function brace(side) {
      var numLines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 1, 1, 1];
      return new _DiagramElements_Equation_Symbols_Brace__WEBPACK_IMPORTED_MODULE_10__["default"](this.webgl, color, side, numLines, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]('bar').scale(1, 1).translate(0, 0), this.limits);
    } // deprecate

  }, {
    key: "roundedSquareBracket",
    value: function roundedSquareBracket(side) {
      var numLines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 1, 1, 1];
      return new _DiagramElements_Equation_Symbols_RoundedSquareBracket__WEBPACK_IMPORTED_MODULE_11__["default"](this.webgl, color, side, numLines, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]('bar').scale(1, 1).translate(0, 0), this.limits);
    } // deprecate
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "make",
    value: function make(equationCollection) {
      return new _DiagramElements_Equation_EquationForm__WEBPACK_IMPORTED_MODULE_12__["default"](equationCollection.elements, {
        getAllElements: equationCollection.getAllElements.bind(equationCollection),
        hideAll: equationCollection.hideAll.bind(equationCollection),
        show: equationCollection.show.bind(equationCollection),
        showOnly: equationCollection.showOnly.bind(equationCollection),
        stop: equationCollection.stop.bind(equationCollection),
        getElementTransforms: equationCollection.getElementTransforms.bind(equationCollection),
        setElementTransforms: equationCollection.setElementTransforms.bind(equationCollection),
        animateToTransforms: equationCollection.animateToTransforms.bind(equationCollection)
      });
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "makeHTML",
    value: function makeHTML() {
      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var classes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      return new _DiagramElements_Equation_HTMLEquation__WEBPACK_IMPORTED_MODULE_15__["default"](id, classes);
    }
  }, {
    key: "makeEqn",
    value: function makeEqn() {
      // Deprecate
      return new _DiagramElements_Equation_GLEquation__WEBPACK_IMPORTED_MODULE_13__["Equation"](this.draw2D, this.limits);
    }
  }, {
    key: "makeDescription",
    value: function makeDescription(id) {
      // Deprecate
      return this.shapes.htmlElement(document.createElement('div'), id, 'lesson__equation_description', new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), 'middle', 'left');
    } // eslint-disable-next-line class-methods-use-this
    // makeEqnFromOptions(...options: Array<{
    //   color?: Array<number>,
    //   position?: Point,
    //   currentForm?: string,
    //   addToCollection?: DiagramElementCollection;
    //   name?: string,
    //   elements: {
    //     [elementName: string]: string | {
    //       text: string,
    //       color?: Array<number>,
    //       isTouchable?: boolean,
    //       onClick?: () => void | null,
    //       direction?: '' | 'up' | 'left' | 'down' | 'right',
    //       mag?: number,
    //       drawPriority?: number,      // higher numbers are above lower numbers
    //       fontOrStyle?: DiagramFont | null,
    //       diagramElement: string | null,
    //       side?: 'up' | 'left' | 'down' | 'right',
    //       numLines?: number,
    //       diagramObj?: string,
    //     };
    //   };
    //   formAlignment?: {
    //     fixTo?: Point | string,
    //     scale?: number,
    //     alignH?: TypeHAlign | null,
    //     alignV?: TypeVAlign | null,
    //   },
    //   forms?: {
    //     // $FlowFixMe
    //     [formName: string]: TypeEquationArray | {
    //       content: TypeEquationArray,
    //       elementMods?: {
    //         [elementName: string]: {
    //           style?: 'linear' | 'curved',
    //           color?: Array<number>,
    //           direction?: '' | 'up' | 'left' | 'down' | 'right',
    //           mag?: number,
    //         }
    //       },
    //       type?: string,
    //       alignment?: {
    //         fixTo?: Point | string,
    //         scale?: number,
    //         alignH?: TypeHAlign | null,
    //         alignV?: TypeVAlign | null,
    //       },
    //     },
    //   },
    //   formSeries?: {
    //     [seriesName: string]: Array<string>,
    //   },
    // }>) {
    //   const eqn = this.makeEqn();
    //   const defaultOptions = {
    //     color: [0.5, 0.5, 0.5, 1],
    //     position: new Point(0, 0),
    //     currentForm: 'base',
    //     formAlignment: {
    //       fixTo: new Point(0, 0),
    //       scale: 0.7,
    //       alignH: 'left',     // applies to fixTo if fixTo is a DiagramElement
    //       alignV: 'baseline', // applies to fixTo if fixTo is a DiagramElement
    //     },
    //     elements: {},
    //     forms: {},
    //     formSeries: null,
    //   };
    //   const optionsToUse = joinObjects({}, defaultOptions, ...options);
    //   // Create Equation Elements
    //   const defElementOptions = {
    //     text: '',
    //     color: optionsToUse.color,
    //     isTouchable: false,
    //     onClick: null,
    //     direction: '',
    //     mag: 0,
    //     fontOrStyle: null,
    //     drawPriority: 1,
    //     diagramElement: null,
    //     side: 'left',
    //     numLines: 1,
    //   };
    //   Object.keys(optionsToUse.elements).forEach((elementName, index) => {
    //     const elementValue = optionsToUse.elements[elementName];
    //     let elementOptions;
    //     if (typeof elementValue === 'string') {
    //       elementOptions = joinObjects({}, defElementOptions, { text: elementValue });
    //     } else {
    //       elementOptions = joinObjects({}, defElementOptions, elementValue);
    //     }
    //     if (elementOptions.diagramObj != null) {
    //       let diagramElement;
    //       if (elementOptions.diagramObj === 'vinculum') {
    //         diagramElement = this.vinculum(elementOptions.color);
    //       }
    //       if (elementOptions.diagramObj === 'bracket') {
    //         diagramElement = this.bracket(
    //           elementOptions.side, elementOptions.numLines, elementOptions.color,
    //         );
    //       }
    //       if (elementOptions.diagramObj === 'brace') {
    //         diagramElement = this.brace(
    //           elementOptions.side, elementOptions.numLines, elementOptions.color,
    //         );
    //       }
    //       if (elementOptions.diagramObj === 'bar') {
    //         diagramElement = this.bar(
    //           elementOptions.side, elementOptions.numLines, elementOptions.color,
    //         );
    //       }
    //       if (elementOptions.diagramObj === 'squareBracket') {
    //         diagramElement = this.squareBracket(
    //           elementOptions.side, elementOptions.numLines, elementOptions.color,
    //         );
    //       }
    //       if (elementOptions.diagramObj === 'roundedSquareBracket') {
    //         diagramElement = this.roundedSquareBracket(
    //           elementOptions.side, elementOptions.numLines, elementOptions.color,
    //         );
    //       }
    //       if (elementOptions.diagramObj === 'strike') {
    //         diagramElement = this.strike(elementOptions.color);
    //       }
    //       if (elementOptions.diagramObj === 'xStrike') {
    //         diagramElement = this.xStrike(elementOptions.color);
    //       }
    //       if (elementOptions.diagramObj === 'integral') {
    //         diagramElement = this.integral(elementOptions.color);
    //       }
    //       if (diagramElement != null) {
    //         diagramElement.isTouchable = elementOptions.isTouchable;
    //         diagramElement.onClick = elementOptions.onClick;
    //         diagramElement.animate.transform.translation
    //           .options.direction = elementOptions.direction;
    //         diagramElement.animate.transform.translation
    //           .options.magnitude = elementOptions.mag;
    //         diagramElement.drawPriority = elementOptions.drawPriority;
    //         elementOptions = diagramElement;
    //       }
    //     }
    //     const elementObject = {};
    //     elementObject[elementName] = elementOptions;
    //     if (index === 0) {
    //       eqn.createElements(elementObject);
    //     } else {
    //       eqn.createElements(
    //         elementObject,
    //         [], null, new Point(0, 0),
    //         eqn.collection,
    //       );
    //     }
    //     eqn.collection.reorder();
    //   });
    //   // Create Equation Forms
    //   const defElementMods = {
    //     style: 'linear',
    //     color: defElementOptions.color,
    //     direction: defElementOptions.direction,
    //     mag: defElementOptions.mag,
    //   };
    //   const defForm = {
    //     alignment: defaultOptions.formAlignment,
    //     type: 'base',
    //     elementMods: {},
    //     animationTime: null,
    //     addToSeries: false,
    //   };
    //   const makePhrase = (phrase: TypeEquationArray) => {
    //     const out = [];
    //     if (typeof phrase === 'string') {
    //       return [phrase];
    //     }
    //     for (let i = 0; i < phrase.length; i += 1) {
    //       const element = phrase[i];
    //       if (typeof element === 'string') {
    //         if (element.startsWith('.') && i < phrase.length - 1) {
    //           if (element === '.frac') {
    //             const parameters = phrase[i + 1];
    //             if (Array.isArray(parameters)) {
    //               const [num, den, vinculum] = parameters;
    //               out.push(eqn.frac(  // $FlowFixMe
    //                 makePhrase(num),  // $FlowFixMe
    //                 makePhrase(den),  // $FlowFixMe
    //                 vinculum,
    //               ));
    //             } else {
    //               // $FlowFixMe
    //               const { numerator, denominator, vinculum } = parameters;
    //               out.push(eqn.frac(
    //                 makePhrase(numerator),
    //                 makePhrase(denominator),
    //                 vinculum,
    //               ));
    //             }
    //           }
    //           if (element === '.sfrac') {
    //             const parameters = phrase[i + 1];
    //             if (Array.isArray(parameters)) {
    //               const [num, den, vinculum, scale] = parameters;
    //               out.push(eqn.sfrac(     // $FlowFixMe
    //                 makePhrase(num),      // $FlowFixMe
    //                 makePhrase(den),      // $FlowFixMe
    //                 vinculum,             // $FlowFixMe
    //                 scale,
    //               ));
    //             } else {
    //               // $FlowFixMe
    //               const { numerator, denominator } = parameters;  // $FlowFixMe
    //               const { vinculum, scale } = parameters;
    //               out.push(eqn.sfrac(
    //                 makePhrase(numerator),
    //                 makePhrase(denominator),
    //                 vinculum,
    //                 scale,
    //               ));
    //             }
    //           }
    //           if (element === '.strike') {
    //             const parameters = phrase[i + 1];
    //             if (Array.isArray(parameters)) {
    //               const [content, strike, strikeInSize] = parameters;
    //               out.push(eqn.strike(                   // $FlowFixMe
    //                 makePhrase(content),              // $FlowFixMe
    //                 strike,
    //                 strikeInSize,
    //               ));
    //             } else {
    //               // $FlowFixMe
    //               const { content, strike, strikeInSize } = parameters;  // $FlowFixMe
    //               out.push(eqn.strike(
    //                 makePhrase(content),                        // $FlowFixMe
    //                 strike,
    //                 strikeInSize,
    //               ));
    //             }
    //           }
    //           if (element === '.sub') {
    //             const parameters = phrase[i + 1];
    //             if (Array.isArray(parameters)) {
    //               const [content, subscript] = parameters;
    //               out.push(eqn.sub(                   // $FlowFixMe
    //                 makePhrase(content),              // $FlowFixMe
    //                 makePhrase(subscript),            // $FlowFixMe
    //               ));
    //             } else {
    //               // $FlowFixMe
    //               const { content, subscript } = parameters;  // $FlowFixMe
    //               out.push(eqn.sub(
    //                 makePhrase(content),                        // $FlowFixMe
    //                 makePhrase(subscript),
    //               ));
    //             }
    //           }
    //           if (element === '.sup') {
    //             const parameters = phrase[i + 1];
    //             if (Array.isArray(parameters)) {
    //               const [content, superscript] = parameters;
    //               out.push(eqn.sup( // $FlowFixMe
    //                 makePhrase(content),  // $FlowFixMe
    //                 makePhrase(superscript),  // $FlowFixMe
    //               ));
    //             } else {
    //               // $FlowFixMe
    //               const { content, superscript } = parameters;  // $FlowFixMe
    //               out.push(eqn.sup(
    //                 makePhrase(content),                        // $FlowFixMe
    //                 makePhrase(superscript),
    //               ));
    //             }
    //           }
    //           if (element === '.supsub') {
    //             const parameters = phrase[i + 1];
    //             if (Array.isArray(parameters)) {
    //               const [content, subscript, superscript] = parameters;
    //               out.push(eqn.supsub(        // $FlowFixMe
    //                 makePhrase(content),      // $FlowFixMe
    //                 makePhrase(subscript),    // $FlowFixMe
    //                 makePhrase(superscript),  // $FlowFixMe
    //               ));
    //             } else {
    //               // $FlowFixMe
    //               const { content, subscript, superscript } = parameters;  // $FlowFixMe
    //               out.push(eqn.supsub(
    //                 makePhrase(content),  // $FlowFixMe
    //                 makePhrase(subscript),  // $FlowFixMe
    //                 makePhrase(superscript),  // $FlowFixMe
    //               ));
    //             }
    //           }
    //           if (element === '.brac') {
    //             const parameters = phrase[i + 1];
    //             if (Array.isArray(parameters)) {
    //               const [content, left, right, space] = parameters;
    //               out.push(eqn.brac(      // $FlowFixMe
    //                 makePhrase(content),  // $FlowFixMe
    //                 left,                 // $FlowFixMe
    //                 right,                // $FlowFixMe
    //                 space,
    //               ));
    //             } else {
    //               const {                         // $FlowFixMe
    //                 content, left, right, space,
    //               } = parameters;                 // $FlowFixMe
    //               out.push(eqn.brac(
    //                 makePhrase(content),          // $FlowFixMe
    //                 left,                         // $FlowFixMe
    //                 right,                        // $FlowFixMe
    //                 space,
    //               ));
    //             }
    //           }
    //           if (element === '.topComment') {
    //             const parameters = phrase[i + 1];
    //             if (Array.isArray(parameters)) {
    //               const [                       // $FlowFixMe
    //                 content, comment, bar, space, outsideSpace,
    //               ] = parameters;
    //               out.push(eqn.topComment(      // $FlowFixMe
    //                 makePhrase(content),        // $FlowFixMe
    //                 makePhrase(comment),        // $FlowFixMe
    //                 bar,                        // $FlowFixMe
    //                 space,                      // $FlowFixMe
    //                 outsideSpace,
    //               ));
    //             } else {
    //               const {                         // $FlowFixMe
    //                 content, comment, bar, space, outsideSpace,
    //               } = parameters;                 // $FlowFixMe
    //               out.push(eqn.topComment(
    //                 makePhrase(content),          // $FlowFixMe
    //                 makePhrase(comment),          // $FlowFixMe
    //                 bar,                          // $FlowFixMe
    //                 space,                        // $FlowFixMe
    //                 outsideSpace,
    //               ));
    //             }
    //           }
    //           if (element === '.bottomComment') {
    //             const parameters = phrase[i + 1];
    //             if (Array.isArray(parameters)) {
    //               const [                         // $FlowFixMe
    //                 content, comment, bar, space, outsideSpace,
    //               ] = parameters;
    //               out.push(eqn.bottomComment(     // $FlowFixMe
    //                 makePhrase(content),          // $FlowFixMe
    //                 makePhrase(comment),          // $FlowFixMe
    //                 bar,                          // $FlowFixMe
    //                 space,                        // $FlowFixMe
    //                 outsideSpace,
    //               ));
    //             } else {
    //               const {                         // $FlowFixMe
    //                 content, comment, bar, space, outsideSpace,
    //               } = parameters;                 // $FlowFixMe
    //               out.push(eqn.bottomComment(
    //                 makePhrase(content),          // $FlowFixMe
    //                 makePhrase(comment),          // $FlowFixMe
    //                 bar,                          // $FlowFixMe
    //                 space,                        // $FlowFixMe
    //                 outsideSpace,
    //               ));
    //             }
    //           }
    //           if (element === '.topBar') {
    //             const parameters = phrase[i + 1];
    //             if (Array.isArray(parameters)) {
    //               const [                         // $FlowFixMe
    //                 content, bar, space, outsideSpace,
    //               ] = parameters;
    //               out.push(eqn.topBar(     // $FlowFixMe
    //                 makePhrase(content),          // $FlowFixMe
    //                 bar,                          // $FlowFixMe
    //                 space,                        // $FlowFixMe
    //                 outsideSpace,
    //               ));
    //             } else {
    //               const {                         // $FlowFixMe
    //                 content, bar, space, outsideSpace,
    //               } = parameters;                 // $FlowFixMe
    //               out.push(eqn.topBar(
    //                 makePhrase(content),          // $FlowFixMe
    //                 bar,                          // $FlowFixMe
    //                 space,                        // $FlowFixMe
    //                 outsideSpace,
    //               ));
    //             }
    //           }
    //           if (element === '.bottomBar') {
    //             const parameters = phrase[i + 1];
    //             if (Array.isArray(parameters)) {
    //               const [                         // $FlowFixMe
    //                 content, bar, space, outsideSpace,
    //               ] = parameters;
    //               out.push(eqn.bottomBar(     // $FlowFixMe
    //                 makePhrase(content),          // $FlowFixMe
    //                 bar,                          // $FlowFixMe
    //                 space,                        // $FlowFixMe
    //                 outsideSpace,
    //               ));
    //             } else {
    //               const {                         // $FlowFixMe
    //                 content, bar, space, outsideSpace,
    //               } = parameters;                 // $FlowFixMe
    //               out.push(eqn.bottomBar(
    //                 makePhrase(content),          // $FlowFixMe
    //                 bar,                          // $FlowFixMe
    //                 space,                        // $FlowFixMe
    //                 outsideSpace,
    //               ));
    //             }
    //           }
    //           if (element === '.ann') {
    //             const parameters = phrase[i + 1];
    //             if (Array.isArray(parameters)) {
    //               const [                         // $FlowFixMe
    //                 content, xPosition, yPosition, xAlign,  // $FlowFixMe
    //                 yAlign, annotationScale,
    //               ] = parameters;
    //               out.push(eqn.ann(               // $FlowFixMe
    //                 makePhrase(content),          // $FlowFixMe
    //                 xPosition,                    // $FlowFixMe
    //                 yPosition,                    // $FlowFixMe
    //                 xAlign,                       // $FlowFixMe
    //                 yAlign,                       // $FlowFixMe
    //                 annotationScale,              // $FlowFixMe
    //               ));
    //             } else {
    //               const {                         // $FlowFixMe
    //                 content, xPosition, yPosition, xAlign,  // $FlowFixMe
    //                 yAlign, annotationScale,
    //               } = parameters;                 // $FlowFixMe
    //               out.push(eqn.ann(               // $FlowFixMe
    //                 makePhrase(content),          // $FlowFixMe
    //                 xPosition,                    // $FlowFixMe
    //                 yPosition,                    // $FlowFixMe
    //                 xAlign,                       // $FlowFixMe
    //                 yAlign,                       // $FlowFixMe
    //                 annotationScale,              // $FlowFixMe
    //               ));
    //             }
    //           }
    //           if (element === '.annotation') {
    //             const parameters = phrase[i + 1];
    //             if (Array.isArray(parameters)) {
    //               const [                         // $FlowFixMe
    //                 content, annotationArray, annotationInSize,
    //               ] = parameters;
    //               out.push(eqn.annotation(        // $FlowFixMe
    //                 makePhrase(content),          // $FlowFixMe
    //                 makePhrase(annotationArray),  // $FlowFixMe
    //                 annotationInSize,             // $FlowFixMe
    //               ));
    //             } else {
    //               const {                         // $FlowFixMe
    //                 content, annotationArray, annotationInSize,
    //               } = parameters;                 // $FlowFixMe
    //               out.push(eqn.annotation(        // $FlowFixMe
    //                 makePhrase(content),          // $FlowFixMe
    //                 makePhrase(annotationArray),  // $FlowFixMe
    //                 annotationInSize,             // $FlowFixMe
    //               ));
    //             }
    //           }
    //         } else {
    //           out.push(element);
    //         }
    //       }
    //     }
    //     return out;
    //   };
    //   Object.keys(optionsToUse.forms).forEach((name) => {
    //     const form = optionsToUse.forms[name];
    //     const formOptionsArray = [];
    //     if (Array.isArray(form)) {
    //       formOptionsArray.push(joinObjects({}, defForm, { content: form }));
    //     } else if (form.content == null) {
    //       Object.keys(form).forEach((formType) => {
    //         formOptionsArray.push(joinObjects(
    //           {}, defForm, form[formType], { type: formType },
    //         ));
    //       });
    //     } else {
    //       formOptionsArray.push(joinObjects({}, defForm, form));
    //     }
    //     formOptionsArray.forEach((formOptions) => {
    //       Object.keys(formOptions.elementMods).forEach((key) => {
    //         // eslint-disable-next-line no-param-reassign
    //         formOptions.elementMods[key] = joinObjects(
    //           {}, defElementMods,
    //           formOptions.elementMods[key],
    //         );
    //       });
    //       if (typeof formOptions.alignment.fixTo === 'string') {
    //         const elem = getDiagramElement(eqn.collection, formOptions.alignment.fixTo);
    //         if (elem != null) {
    //           eqn.formAlignment.fixTo = elem;
    //         }
    //       } else {
    //         eqn.formAlignment.fixTo = formOptions.alignment.fixTo;
    //       }
    //       eqn.formAlignment.hAlign = formOptions.alignment.hAlign;
    //       eqn.formAlignment.vAlign = formOptions.alignment.vAlign;
    //       eqn.formAlignment.scale = formOptions.alignment.scale;
    //       eqn.addForm(
    //         name,
    //         makePhrase(formOptions.content),
    //         {
    //           animationTime: formOptions.animationTime,
    //           elementMods: formOptions.elementMods,
    //           formType: formOptions.type,
    //           addToSeries: formOptions.addToSeries,
    //         },
    //       );
    //     });
    //   });
    //   if (optionsToUse.formSeries != null) {
    //     eqn.setFormSeries(optionsToUse.formSeries);
    //   }
    //   eqn.collection.setPosition(optionsToUse.position);
    //   eqn.setCurrentForm(optionsToUse.currentForm);
    //   const { addToCollection } = optionsToUse;
    //   if (addToCollection != null) {
    //     addToCollection.eqns[optionsToUse.name] = eqn;
    //     addToCollection.add(optionsToUse.name, eqn.collection);
    //   }
    //   eqn.formTypeOrder = ['rad', 'deg', 'base'];
    //   return eqn;
    // }

  }, {
    key: "addEquation",
    value: function addEquation(parent, name) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      // $FlowFixMe
      var equation = new _DiagramElements_Equation_Equation__WEBPACK_IMPORTED_MODULE_14__["EquationNew"](this.shapes, options);
      parent.add(name, equation);
      return equation;
    }
  }, {
    key: "addNavigator",
    value: function addNavigator(parent, name, options) {
      var navNameToUse = name;
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, options);

      if (optionsToUse.equation == null) {
        // $FlowFixMe
        var equation = this.addEquation(parent, "".concat(name, "Eqn"), options);
        optionsToUse.equation = equation;
        navNameToUse = "".concat(name, "Nav");
      } // $FlowFixMe


      var navigator = new _DiagramObjects_EqnNavigator__WEBPACK_IMPORTED_MODULE_16__["default"](this.shapes, this.animateNextFrame, optionsToUse);
      parent.add(navNameToUse, navigator);
      return navigator;
    } // deprecate
    // Make an Equation Diagram Collection
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "addEquationLegacy",
    value: function addEquationLegacy(parent) {
      var _this = this;

      var defaultEquationOptions = {
        color: [0.5, 0.5, 0.5, 1],
        position: new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0),
        elements: {},
        //
        defaultFormAlignment: {
          fixTo: new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0),
          scale: 0.7,
          alignH: 'left',
          // applies to fixTo if fixTo is a DiagramElement
          alignV: 'baseline' // applies to fixTo if fixTo is a DiagramElement

        },
        forms: {},
        firstForm: null,
        formSeries: []
      };

      for (var _len = arguments.length, options = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        options[_key - 1] = arguments[_key];
      }

      var equationOptionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"].apply(void 0, [{}, defaultEquationOptions].concat(options)); // $FlowFixMe

      var equation = new _DiagramElements_Equation_Equation__WEBPACK_IMPORTED_MODULE_14__["EquationNew"](this.shapes, {
        defaultFormAlignment: equationOptionsToUse.defaultFormAlignment
      });
      parent.add(equationOptionsToUse.name, equation); // Create Equation Elements

      var defEqnElementOptions = {
        color: equationOptionsToUse.color,
        elementOptions: {},
        //
        text: '',
        textOptions: {
          fontOrStyle: null
        },
        symbol: null,
        symbolOptions: {
          side: 'left',
          numLines: 1
        }
      };
      var elements = equationOptionsToUse.elements;
      Object.keys(elements).forEach(function (elementName) {
        var element = elements[elementName];
        var elementToAdd;
        var eqnElementOptions; // If element is defined as string, then it is a text element

        if (typeof element === 'string') {
          eqnElementOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, defEqnElementOptions, {
            text: element
          }); // Otherwise it's an object of options
        } else {
          eqnElementOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, defEqnElementOptions, element);
        } // See if the eqnElementOptions object has a defined symbol. If it
        // does, then create the element.


        var _eqnElementOptions = eqnElementOptions,
            symbol = _eqnElementOptions.symbol;

        if (symbol != null) {
          var _eqnElementOptions$sy = eqnElementOptions.symbolOptions,
              color = _eqnElementOptions$sy.color,
              numLines = _eqnElementOptions$sy.numLines,
              side = _eqnElementOptions$sy.side;
          var diagramElement;

          if (symbol === 'vinculum') {
            diagramElement = _this.vinculum(color);
          }

          if (symbol === 'bracket') {
            diagramElement = _this.bracket(side, numLines, color);
          }

          if (symbol === 'brace') {
            diagramElement = _this.brace(side, numLines, color);
          }

          if (symbol === 'bar') {
            diagramElement = _this.bar(side, numLines, color);
          }

          if (symbol === 'squareBracket') {
            diagramElement = _this.squareBracket(side, numLines, color);
          }

          if (symbol === 'roundedSquareBracket') {
            diagramElement = _this.roundedSquareBracket(side, numLines, color);
          }

          if (symbol === 'strike') {
            diagramElement = _this.strike(color);
          }

          if (symbol === 'xStrike') {
            diagramElement = _this.xStrike(color);
          }

          if (symbol === 'integral') {
            diagramElement = _this.integral(color);
          }

          if (diagramElement != null) {
            diagramElement.setProperties(eqnElementOptions.elementOptions);
            elementToAdd = diagramElement;
          }
        } else {
          elementToAdd = eqnElementOptions;
        }

        if (elementToAdd != null) {
          var elementObject = {};
          elementObject[elementName] = elementToAdd;
          equation.addElements(elementObject);
        }
      });
      equation.reorder(); // Create Equation Forms

      var defElementMods = {
        color: equationOptionsToUse.color,
        elementOptions: {} // fromNext: {
        //   color: equationOptionsToUse.color,
        //   elementOptions: {},
        // },
        // fromPrev: {
        //   color: equationOptionsToUse.color,
        //   elementOptions: {},
        // },
        // color: equationOptionsToUse.color,
        // direction: null,                    // Will populate all from* options
        // elementOptions: {},

      };
      var defForm = {
        alignment: equationOptionsToUse.defaultFormAlignment,
        subForm: 'base',
        elementMods: {},
        animationTime: null // addToSeries: false,

      };

      var makePhrase = function makePhrase(phrase) {
        var out = [];

        if (typeof phrase === 'string') {
          return [phrase];
        }

        for (var i = 0; i < phrase.length; i += 1) {
          var element = phrase[i];

          if (typeof element === 'string') {
            if (i < phrase.length - 1) {
              // eslint-disable-next-line
              var methodName = element;

              if (element === '.frac') {
                var parameters = phrase[i + 1];
                out.push(equation.eqn.functions.frac(parameters));
                i += 1;
              } // if (element === '.sfrac') {
              //   const parameters = phrase[i + 1];
              //   if (Array.isArray(parameters)) {
              //     const [num, den, vinculum, scale] = parameters;
              //     out.push(eqn.sfrac(     // $FlowFixMe
              //       makePhrase(num),      // $FlowFixMe
              //       makePhrase(den),      // $FlowFixMe
              //       vinculum,             // $FlowFixMe
              //       scale,
              //     ));
              //   } else {
              //     // $FlowFixMe
              //     const { numerator, denominator } = parameters;  // $FlowFixMe
              //     const { vinculum, scale } = parameters;
              //     out.push(eqn.sfrac(
              //       makePhrase(numerator),
              //       makePhrase(denominator),
              //       vinculum,
              //       scale,
              //     ));
              //   }
              // }
              // if (element === '.strike') {
              //   const parameters = phrase[i + 1];
              //   if (Array.isArray(parameters)) {
              //     const [content, strike, strikeInSize] = parameters;
              //     out.push(eqn.strike(                   // $FlowFixMe
              //       makePhrase(content),              // $FlowFixMe
              //       strike,
              //       strikeInSize,
              //     ));
              //   } else {
              //     // $FlowFixMe
              //     const { content, strike, strikeInSize } = parameters;  // $FlowFixMe
              //     out.push(eqn.strike(
              //       makePhrase(content),                        // $FlowFixMe
              //       strike,
              //       strikeInSize,
              //     ));
              //   }
              // }
              // if (element === '.sub') {
              //   const parameters = phrase[i + 1];
              //   if (Array.isArray(parameters)) {
              //     const [content, subscript] = parameters;
              //     out.push(eqn.sub(                   // $FlowFixMe
              //       makePhrase(content),              // $FlowFixMe
              //       makePhrase(subscript),            // $FlowFixMe
              //     ));
              //   } else {
              //     // $FlowFixMe
              //     const { content, subscript } = parameters;  // $FlowFixMe
              //     out.push(eqn.sub(
              //       makePhrase(content),                        // $FlowFixMe
              //       makePhrase(subscript),
              //     ));
              //   }
              // }
              // if (element === '.sup') {
              //   const parameters = phrase[i + 1];
              //   if (Array.isArray(parameters)) {
              //     const [content, superscript] = parameters;
              //     out.push(eqn.sup( // $FlowFixMe
              //       makePhrase(content),  // $FlowFixMe
              //       makePhrase(superscript),  // $FlowFixMe
              //     ));
              //   } else {
              //     // $FlowFixMe
              //     const { content, superscript } = parameters;  // $FlowFixMe
              //     out.push(eqn.sup(
              //       makePhrase(content),                        // $FlowFixMe
              //       makePhrase(superscript),
              //     ));
              //   }
              // }
              // if (element === '.supsub') {
              //   const parameters = phrase[i + 1];
              //   if (Array.isArray(parameters)) {
              //     const [content, subscript, superscript] = parameters;
              //     out.push(eqn.supsub(        // $FlowFixMe
              //       makePhrase(content),      // $FlowFixMe
              //       makePhrase(subscript),    // $FlowFixMe
              //       makePhrase(superscript),  // $FlowFixMe
              //     ));
              //   } else {
              //     // $FlowFixMe
              //     const { content, subscript, superscript } = parameters;  // $FlowFixMe
              //     out.push(eqn.supsub(
              //       makePhrase(content),  // $FlowFixMe
              //       makePhrase(subscript),  // $FlowFixMe
              //       makePhrase(superscript),  // $FlowFixMe
              //     ));
              //   }
              // }
              // if (element === '.brac') {
              //   const parameters = phrase[i + 1];
              //   if (Array.isArray(parameters)) {
              //     const [content, left, right, space] = parameters;
              //     out.push(eqn.brac(      // $FlowFixMe
              //       makePhrase(content),  // $FlowFixMe
              //       left,                 // $FlowFixMe
              //       right,                // $FlowFixMe
              //       space,
              //     ));
              //   } else {
              //     const {                         // $FlowFixMe
              //       content, left, right, space,
              //     } = parameters;                 // $FlowFixMe
              //     out.push(eqn.brac(
              //       makePhrase(content),          // $FlowFixMe
              //       left,                         // $FlowFixMe
              //       right,                        // $FlowFixMe
              //       space,
              //     ));
              //   }
              // }
              // if (element === '.topComment') {
              //   const parameters = phrase[i + 1];
              //   if (Array.isArray(parameters)) {
              //     const [                       // $FlowFixMe
              //       content, comment, bar, space, outsideSpace,
              //     ] = parameters;
              //     out.push(eqn.topComment(      // $FlowFixMe
              //       makePhrase(content),        // $FlowFixMe
              //       makePhrase(comment),        // $FlowFixMe
              //       bar,                        // $FlowFixMe
              //       space,                      // $FlowFixMe
              //       outsideSpace,
              //     ));
              //   } else {
              //     const {                         // $FlowFixMe
              //       content, comment, bar, space, outsideSpace,
              //     } = parameters;                 // $FlowFixMe
              //     out.push(eqn.topComment(
              //       makePhrase(content),          // $FlowFixMe
              //       makePhrase(comment),          // $FlowFixMe
              //       bar,                          // $FlowFixMe
              //       space,                        // $FlowFixMe
              //       outsideSpace,
              //     ));
              //   }
              // }
              // if (element === '.bottomComment') {
              //   const parameters = phrase[i + 1];
              //   if (Array.isArray(parameters)) {
              //     const [                         // $FlowFixMe
              //       content, comment, bar, space, outsideSpace,
              //     ] = parameters;
              //     out.push(eqn.bottomComment(     // $FlowFixMe
              //       makePhrase(content),          // $FlowFixMe
              //       makePhrase(comment),          // $FlowFixMe
              //       bar,                          // $FlowFixMe
              //       space,                        // $FlowFixMe
              //       outsideSpace,
              //     ));
              //   } else {
              //     const {                         // $FlowFixMe
              //       content, comment, bar, space, outsideSpace,
              //     } = parameters;                 // $FlowFixMe
              //     out.push(eqn.bottomComment(
              //       makePhrase(content),          // $FlowFixMe
              //       makePhrase(comment),          // $FlowFixMe
              //       bar,                          // $FlowFixMe
              //       space,                        // $FlowFixMe
              //       outsideSpace,
              //     ));
              //   }
              // }
              // if (element === '.topBar') {
              //   const parameters = phrase[i + 1];
              //   if (Array.isArray(parameters)) {
              //     const [                         // $FlowFixMe
              //       content, bar, space, outsideSpace,
              //     ] = parameters;
              //     out.push(eqn.topBar(     // $FlowFixMe
              //       makePhrase(content),          // $FlowFixMe
              //       bar,                          // $FlowFixMe
              //       space,                        // $FlowFixMe
              //       outsideSpace,
              //     ));
              //   } else {
              //     const {                         // $FlowFixMe
              //       content, bar, space, outsideSpace,
              //     } = parameters;                 // $FlowFixMe
              //     out.push(eqn.topBar(
              //       makePhrase(content),          // $FlowFixMe
              //       bar,                          // $FlowFixMe
              //       space,                        // $FlowFixMe
              //       outsideSpace,
              //     ));
              //   }
              // }
              // if (element === '.bottomBar') {
              //   const parameters = phrase[i + 1];
              //   if (Array.isArray(parameters)) {
              //     const [                         // $FlowFixMe
              //       content, bar, space, outsideSpace,
              //     ] = parameters;
              //     out.push(eqn.bottomBar(     // $FlowFixMe
              //       makePhrase(content),          // $FlowFixMe
              //       bar,                          // $FlowFixMe
              //       space,                        // $FlowFixMe
              //       outsideSpace,
              //     ));
              //   } else {
              //     const {                         // $FlowFixMe
              //       content, bar, space, outsideSpace,
              //     } = parameters;                 // $FlowFixMe
              //     out.push(eqn.bottomBar(
              //       makePhrase(content),          // $FlowFixMe
              //       bar,                          // $FlowFixMe
              //       space,                        // $FlowFixMe
              //       outsideSpace,
              //     ));
              //   }
              // }
              // if (element === '.ann') {
              //   const parameters = phrase[i + 1];
              //   if (Array.isArray(parameters)) {
              //     const [                         // $FlowFixMe
              //       content, xPosition, yPosition, xAlign,  // $FlowFixMe
              //       yAlign, annotationScale,
              //     ] = parameters;
              //     out.push(eqn.ann(               // $FlowFixMe
              //       makePhrase(content),          // $FlowFixMe
              //       xPosition,                    // $FlowFixMe
              //       yPosition,                    // $FlowFixMe
              //       xAlign,                       // $FlowFixMe
              //       yAlign,                       // $FlowFixMe
              //       annotationScale,              // $FlowFixMe
              //     ));
              //   } else {
              //     const {                         // $FlowFixMe
              //       content, xPosition, yPosition, xAlign,  // $FlowFixMe
              //       yAlign, annotationScale,
              //     } = parameters;                 // $FlowFixMe
              //     out.push(eqn.ann(               // $FlowFixMe
              //       makePhrase(content),          // $FlowFixMe
              //       xPosition,                    // $FlowFixMe
              //       yPosition,                    // $FlowFixMe
              //       xAlign,                       // $FlowFixMe
              //       yAlign,                       // $FlowFixMe
              //       annotationScale,              // $FlowFixMe
              //     ));
              //   }
              // }
              // if (element === '.annotation') {
              //   const parameters = phrase[i + 1];
              //   if (Array.isArray(parameters)) {
              //     const [                         // $FlowFixMe
              //       content, annotationArray, annotationInSize,
              //     ] = parameters;
              //     out.push(eqn.annotation(        // $FlowFixMe
              //       makePhrase(content),          // $FlowFixMe
              //       makePhrase(annotationArray),  // $FlowFixMe
              //       annotationInSize,             // $FlowFixMe
              //     ));
              //   } else {
              //     const {                         // $FlowFixMe
              //       content, annotationArray, annotationInSize,
              //     } = parameters;                 // $FlowFixMe
              //     out.push(eqn.annotation(        // $FlowFixMe
              //       makePhrase(content),          // $FlowFixMe
              //       makePhrase(annotationArray),  // $FlowFixMe
              //       annotationInSize,             // $FlowFixMe
              //     ));
              //   }
              // }

            } else {
              out.push(element);
            }
          } else if (Array.isArray(element)) {
            out.push(element);
          } else {
            var _methodName = Object.keys(element)[0];
            var methodParams = Object.values(element)[0]; // $FlowFixMe

            if (equation.eqn.functions[_methodName]) {
              // $FlowFixMe
              out.push(equation.eqn.functions[_methodName](methodParams));
            }
          }
        }

        return out;
      }; // Go through each form and create it


      Object.keys(equationOptionsToUse.forms).forEach(function (name) {
        var form = equationOptionsToUse.forms[name];
        var formOptionsArray = []; // If the form is an array

        if (Array.isArray(form)) {
          formOptionsArray.push(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, defForm, {
            content: form
          })); // Otherwise if it's an object without a content field (meaning it's keys
          // will just be formTypes)
        } else if (form.content == null) {
          Object.keys(form).forEach(function (subForm) {
            formOptionsArray.push(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])(defForm, form[subForm], {
              subForm: subForm
            }));
          }); // Otherwise it's a form fully defined as an object
        } else {
          formOptionsArray.push(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, defForm, form));
        } // Populate the elementMods with default values when values are missing


        formOptionsArray.forEach(function (formOptions) {
          Object.keys(formOptions.elementMods).forEach(function (key) {
            // eslint-disable-next-line no-param-reassign
            formOptions.elementMods[key] = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, defElementMods, formOptions.elementMods[key]);
          });

          if (typeof formOptions.alignment.fixTo === 'string') {
            var elem = Object(_DiagramElements_Equation_GLEquation__WEBPACK_IMPORTED_MODULE_13__["getDiagramElement"])(equation, formOptions.alignment.fixTo);

            if (elem != null) {
              equation.eqn.defaultFormAlignment.fixTo = elem;
            }
          } else {
            equation.eqn.defaultFormAlignment.fixTo = formOptions.alignment.fixTo;
          }

          equation.eqn.defaultFormAlignment.alignH = formOptions.alignment.alignH;
          equation.eqn.defaultFormAlignment.alignV = formOptions.alignment.alignV;
          equation.eqn.scale = formOptions.alignment.scale;
          equation.addForm(name, // $FlowFixMe
          makePhrase(formOptions.content), {
            animationTime: formOptions.animationTime,
            elementMods: formOptions.elementMods,
            subForm: formOptions.subForm,
            addToSeries: formOptions.addToSeries
          });
        });
      }); // if (optionsToUse.formSeries != null) {
      //   eqn.setFormSeries(optionsToUse.formSeries);
      // }
      // eqn.collection.setPosition(optionsToUse.position);
      // eqn.setCurrentForm(optionsToUse.currentForm);
      // const { addToCollection } = optionsToUse;
      // if (addToCollection != null) {
      //   addToCollection.eqns[optionsToUse.name] = eqn;
      //   addToCollection.add(optionsToUse.name, eqn.collection);
      // }
      // eqn.formTypeOrder = ['rad', 'deg', 'base'];
      // return eqn;
    }
  }, {
    key: "fraction",
    value: function fraction() {
      var defaultOptions = {
        numerator: '1',
        denominator: 'NOT DEFINED',
        color: [1, 0, 0, 1],
        scale: 0.5
      };

      for (var _len2 = arguments.length, options = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        options[_key2] = arguments[_key2];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(options));
      var eqn = this.makeEqn();
      eqn.createElements({
        num: optionsToUse.numerator,
        den: optionsToUse.denominator,
        v: this.vinculum(optionsToUse.color)
      }, optionsToUse.color);
      eqn.formAlignment.hAlign = 'center';
      eqn.formAlignment.vAlign = 'baseline';
      eqn.formAlignment.scale = optionsToUse.scale;
      eqn.addForm('base', [eqn.frac('num', 'den', 'v')]);
      eqn.setCurrentForm('base');
      return eqn;
    }
  }, {
    key: "fractionPre",
    value: function fractionPre() {
      var defaultOptions = {
        numerator: '1',
        denominator: 'NOT DEFINED',
        main: 'NOT DEFINED',
        color: [1, 0, 0, 1],
        scale: 0.5,
        fracScale: 0.6
      };

      for (var _len3 = arguments.length, options = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        options[_key3] = arguments[_key3];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(options));
      var eqn = this.makeEqn();
      eqn.createElements({
        num: optionsToUse.numerator,
        den: optionsToUse.denominator,
        main: optionsToUse.main,
        v: this.vinculum(optionsToUse.color)
      }, optionsToUse.color);
      eqn.formAlignment.hAlign = 'center';
      eqn.formAlignment.vAlign = 'baseline';
      eqn.formAlignment.scale = optionsToUse.scale;
      eqn.addForm('base', [eqn.sfrac('num', 'den', 'v', optionsToUse.fracScale), 'space', 'main']);
      eqn.setCurrentForm('base');
      return eqn;
    }
  }]);

  return DiagramEquation;
}();



/***/ }),

/***/ "./src/js/diagram/DiagramObjects/Angle.js":
/*!************************************************!*\
  !*** ./src/js/diagram/DiagramObjects/Angle.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _EquationLabel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EquationLabel */ "./src/js/diagram/DiagramObjects/EquationLabel.js");
/* harmony import */ var _DiagramElements_Equation_GLEquation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../DiagramElements/Equation/GLEquation */ "./src/js/diagram/DiagramElements/Equation/GLEquation.js");
function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import Diagram from '../Diagram';







// Angle is a class that manages:
//   A angle curve
//   Label
//   Arrows
//   Straight Lines
//
// The angle collection comprises:
//   * Positioned at 0, 0 in vertex space
//   * Curve from 0 to angle size (where 0 is along x axis in vertex space)
//   * Label in center of curve
//   * Arrows at ends of curve
//   * Straight lines forming the corner
//
// To give the angle a custom position and rotation from 0, the main class's
// transform is used:
//   - Translation for position
//   - Rotation for rotation
//
// An angle can be defined in two ways:
//   - Angle, rotation, position
//   - p1, p2, p3
var AngleLabel =
/*#__PURE__*/
function (_EquationLabel) {
  _inherits(AngleLabel, _EquationLabel);

  function AngleLabel(equation, labelText, color, radius) {
    var _this;

    var curvePosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
    var showRealAngle = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    var realAngleDecimals = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
    var autoHide = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : -1;
    var orientation = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 'horizontal';
    var scale = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0.7;

    _classCallCheck(this, AngleLabel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AngleLabel).call(this, equation, {
      label: labelText,
      color: color,
      scale: scale
    }));
    _this.radius = radius;
    _this.curvePosition = curvePosition;
    _this.showRealAngle = showRealAngle;
    _this.orientation = orientation;
    _this.realAngleDecimals = realAngleDecimals;
    _this.autoHide = autoHide;
    return _this;
  }

  return AngleLabel;
}(_EquationLabel__WEBPACK_IMPORTED_MODULE_4__["default"]);

var DiagramObjectAngle =
/*#__PURE__*/
function (_DiagramElementCollec) {
  _inherits(DiagramObjectAngle, _DiagramElementCollec);

  _createClass(DiagramObjectAngle, [{
    key: "calculateFromP1P2P3",
    // Diagram elements
    // Objects that may or may not exist
    // angle properties - pulic read only
    // angle properties - pulic read/write
    // angle properties - private internal use only
    // Pulic Angle methods
    // eslint-disable-next-line class-methods-use-this
    value: function calculateFromP1P2P3(p1, p2, p3) {
      var position = p2._dup();

      var L21 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p2, p1);
      var rotation = L21.angle();
      var angle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["threePointAngle"])(p1, p2, p3);
      return {
        position: position,
        rotation: rotation,
        angle: angle
      };
    }
  }]);

  function DiagramObjectAngle(shapes, equation, isTouchDevice, animateNextFrame) {
    var _this2;

    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    _classCallCheck(this, DiagramObjectAngle);

    var defaultOptions = {
      position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      rotation: 0,
      angle: 1,
      // radius: 0.1,
      color: [0, 1, 0, 1],
      // clockwise: false,
      autoRightAngle: false,
      rightAngleRange: 0.001,
      curve: null,
      sides: null,
      sideStart: null,
      sideStop: null,
      arrows: null,
      arrow1: null,
      arrow2: null,
      label: null,
      p1: null,
      // if p1, p2 and p3 are defined, position, angle and
      p2: null,
      // rotation will be overridden
      p3: null,
      mods: {}
    };
    var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultOptions, options);
    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(DiagramObjectAngle).call(this, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Line').scale(1, 1).rotate(0).translate(0, 0), shapes.limits));

    _this2.setColor(optionsToUse.color);

    _this2.shapes = shapes;
    _this2.equation = equation;
    _this2.largerTouchBorder = optionsToUse.largerTouchBorder;
    _this2.isTouchDevice = isTouchDevice;
    _this2.animateNextFrame = animateNextFrame; // Calculate and store the angle geometry

    _this2.position = optionsToUse.position;
    _this2.rotation = optionsToUse.rotation;
    _this2.angle = optionsToUse.angle;
    _this2.lastLabelRotationOffset = 0;
    _this2.autoRightAngle = optionsToUse.autoRightAngle;
    _this2.rightAngleRange = optionsToUse.rightAngleRange; // this.clockwise = optionsToUse.clockwise;
    // this.radius = optionsToUse.radius;

    if (optionsToUse.p1 != null && optionsToUse.p2 != null && optionsToUse.p3 != null) {
      var _this2$calculateFromP = _this2.calculateFromP1P2P3(optionsToUse.p1, optionsToUse.p2, optionsToUse.p3),
          position = _this2$calculateFromP.position,
          rotation = _this2$calculateFromP.rotation,
          angle = _this2$calculateFromP.angle;

      _this2.angle = angle;
      _this2.rotation = rotation;
      _this2.position = position;
    }

    _this2.transform.updateTranslation(_this2.position);

    _this2.transform.updateRotation(_this2.rotation); // Setup default values for sides, arrows, curve and label


    _this2.side1 = null;
    _this2.side2 = null;
    _this2.arrow1 = null;
    _this2.arrow2 = null;
    _this2.curve = null;
    _this2.label = null; // If the curve is to be shown (and not just a label) then make it

    _this2._curve = null;

    if (optionsToUse.curve) {
      _this2.addCurve(optionsToUse.curve);
    } // Arrows


    if (optionsToUse.arrow1 || optionsToUse.arrows) {
      _this2.addArrow(1, Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, optionsToUse.arrow1, optionsToUse.arrows));
    }

    if (optionsToUse.arrow2 || optionsToUse.arrows) {
      _this2.addArrow(2, Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, optionsToUse.arrow2, optionsToUse.arrows));
    } // Label


    if (optionsToUse.label) {
      _this2.addLabel(optionsToUse.label);
    } // Sides


    var defaultSideLength = 0.5;

    if (_this2.curve) {
      defaultSideLength = _this2.curve.radius * 2;
    }

    var defaultSideWidth = 0.01;

    if (_this2.curve) {
      defaultSideWidth = _this2.curve.width;
    }

    var defaultSideOptions = {
      length: defaultSideLength,
      width: defaultSideWidth,
      color: _this2.color
    };

    if (optionsToUse.side1) {
      var sideOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultSideOptions, optionsToUse.side1);

      _this2.addSide(1, sideOptions.length, sideOptions.width, sideOptions.color);
    }

    if (optionsToUse.side2) {
      var _sideOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultSideOptions, optionsToUse.side2);

      _this2.addSide(2, _sideOptions.length, _sideOptions.width, _sideOptions.color);
    } // Sides overrides side1 and side2


    if (optionsToUse.sides) {
      var sides = {};

      if (_typeof(optionsToUse.sides) === 'object') {
        sides = optionsToUse.sides;
      }

      var _sideOptions2 = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultSideOptions, sides);

      _this2.addSide(1, _sideOptions2.length, _sideOptions2.width, _sideOptions2.color);

      _this2.addSide(2, _sideOptions2.length, _sideOptions2.width, _sideOptions2.color);
    }

    _this2.update();

    if (optionsToUse.mods != null && optionsToUse.mods !== {}) {
      _this2.setProperties(optionsToUse.mods);
    }

    return _this2;
  }

  _createClass(DiagramObjectAngle, [{
    key: "setAngle",
    value: function setAngle() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.position != null) {
        this.position = options.position;
      }

      if (options.rotation != null) {
        this.rotation = options.rotation;
      }

      if (options.angle != null) {
        this.angle = options.angle;
      }

      if (options.p1 != null && options.p2 != null && options.p3 != null) {
        var _this$calculateFromP = this.calculateFromP1P2P3(options.p1, options.p2, options.p3),
            position = _this$calculateFromP.position,
            rotation = _this$calculateFromP.rotation,
            angle = _this$calculateFromP.angle;

        this.angle = angle;
        this.rotation = rotation;
        this.position = position;
      }

      this.update();
    }
  }, {
    key: "addSide",
    value: function addSide(index) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.color;
      var line = this.shapes.horizontalLine(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), 1, width, 0, color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).rotate(0)); // $FlowFixMe

      this["side".concat(index)] = {
        length: length,
        width: width
      };
      this.add("side".concat(index), line);
    }
  }, {
    key: "addLabel",
    value: function addLabel() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultLabelOptions = {
        text: null,
        radius: 0.4,
        curvePosition: 0.5,
        showRealAngle: false,
        realAngleDecimals: 0,
        orientation: 'horizontal',
        autoHide: -1,
        textScale: 0.7,
        color: this.color
      };

      if (this.curve) {
        defaultLabelOptions.radius = this.curve.radius;
      } // console.log(options)


      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultLabelOptions, options);

      if (optionsToUse.text === null) {
        optionsToUse.text = '';
        optionsToUse.showRealAngle = true;
      }

      this.label = new AngleLabel(this.equation, optionsToUse.text, optionsToUse.color, optionsToUse.radius, optionsToUse.curvePosition, optionsToUse.showRealAngle, optionsToUse.realAngleDecimals, optionsToUse.autoHide, optionsToUse.orientation, optionsToUse.textScale);

      if (this.label != null) {
        this.add('label', this.label.eqn.collection);
      } // this.updateLabel();

    }
  }, {
    key: "addCurve",
    value: function addCurve() {
      var curveOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultCurveOptions = {
        width: 0.01,
        sides: 50,
        radius: 0.5,
        num: 1,
        step: 0
      };
      var optionsToUse = Object.assign({}, defaultCurveOptions, curveOptions);

      for (var i = 0; i < optionsToUse.num; i += 1) {
        var curve = this.shapes.polygon({
          sides: optionsToUse.sides,
          radius: optionsToUse.radius + i * optionsToUse.step,
          width: optionsToUse.width,
          color: this.color,
          fill: false,
          transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('AngleCurve').rotate(0)
        });
        this.curve = optionsToUse;
        var name = 'curve';

        if (i > 0) {
          name = "".concat(name).concat(i);
        }

        this.add(name, curve);
      } // Right Angle


      if (this.autoRightAngle) {
        var right = this.shapes.collection();
        var rightLength = optionsToUse.radius; // / Math.sqrt(2);

        right.add('line1', this.shapes.horizontalLine(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](rightLength, 0), rightLength + optionsToUse.width / 2, optionsToUse.width, Math.PI / 2, this.color));
        right.add('line2', this.shapes.horizontalLine(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, rightLength), rightLength - optionsToUse.width / 2, optionsToUse.width, 0, this.color));
        this.add('curveRight', right);
      }
    } // pulseWidth() {
    //   const line = this._line;
    //   if (line != null) {
    //     line.stopPulsing();
    //     const oldTransformMethod = line.pulse.transformMethod;
    //     const oldPulseCallback = line.pulse.callback;
    //     const finishPulsing = () => {
    //       line.pulse.transformMethod = oldTransformMethod;
    //       line.pulse.callback = oldPulseCallback;
    //     };
    //     line.pulse.callback = finishPulsing;
    //     line.pulse.transformMethod = s => new Transform().scale(1, s);
    //     line.pulseScaleNow(1, 3);
    //   }
    //   const arrow1 = this._arrow1;
    //   const arrow2 = this._arrow2;
    //   if (arrow1 != null) {
    //     arrow1.pulseScaleNow(1, 2);
    //   }
    //   if (arrow2 != null) {
    //     arrow2.pulseScaleNow(1, 2);
    //   }
    //   const label = this._label;
    //   if (label != null) {
    //     label.pulseScaleNow(1, 1.5);
    //   }
    //   this.animateNextFrame();
    // }

  }, {
    key: "addArrow",
    value: function addArrow(index) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var defaultArrowDimension = 0.04;

      if (this.curve) {
        defaultArrowDimension = this.curve.width * 4;
      }

      var defaultArrowRadius = 0.1;

      if (this.curve) {
        defaultArrowRadius = this.curve.radius;
      }

      var defaultArrowOptions = {
        width: defaultArrowDimension,
        height: defaultArrowDimension,
        radius: defaultArrowRadius,
        autoHide: true,
        curveOverlap: 0.3
      };
      var optionsToUse = {};

      if (options != null) {
        optionsToUse = options;
      }

      var arrowOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultArrowOptions, optionsToUse);
      var width = arrowOptions.width,
          height = arrowOptions.height;
      var r = Math.PI / 2;

      if (index === 2) {
        r = Math.PI / 2 * 3;
      }

      var a = this.shapes.arrowLegacy(width, 0, height, 0, this.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(0).translate(0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), r); // $FlowFixMe

      this["arrow".concat(index)] = arrowOptions;
      this.add("arrow".concat(index), a);
      this.update();
    }
  }, {
    key: "updateCurve",
    value: function updateCurve(primaryCurveAngle, angle, rotation, show) {
      var curve = this.curve;

      if (curve) {
        for (var i = 0; i < curve.num; i += 1) {
          var name = '_curve';

          if (i > 0) {
            name = "_curve".concat(i);
          } // $FlowFixMe


          var element = this[name]; // console.log(element)

          if (element) {
            if (show) {
              element.show();

              if (i === 0) {
                var delta = 0;

                if (this.curve) {
                  delta = primaryCurveAngle % (2 * Math.PI / this.curve.sides);
                }

                element.angleToDraw = primaryCurveAngle;
                element.transform.updateRotation(rotation + delta / 2);
              } else {
                var _delta = 0;

                if (this.curve) {
                  _delta = angle % (2 * Math.PI / this.curve.sides);
                }

                element.angleToDraw = angle;
                element.transform.updateRotation(_delta / 2);
              }
            } else {
              element.hide();
            }
          }
        }
      }
    }
  }, {
    key: "update",
    value: function update() {
      var labelRotationOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var _arrow1 = this._arrow1,
          arrow1 = this.arrow1;
      var _arrow2 = this._arrow2,
          arrow2 = this.arrow2;
      var arrow1Hide = false;
      var arrow2Hide = false;
      var rotationForArrow1 = 0;
      var curveAngle = this.angle;
      var trueCurveAngle = this.angle; // const arrow2LengthModifier = 0.5;
      // const arrowLengthMod = 0.9;

      var arrow1Angle = 0;
      var arrow2Angle = 0;

      if (arrow1 && this.arrow1) {
        arrow1Angle = arrow1.height / arrow1.radius * (1 - this.arrow1.curveOverlap);
        curveAngle -= arrow1Angle;
        trueCurveAngle -= arrow1.height / arrow1.radius;
      }

      if (arrow2 && this.arrow2) {
        arrow2Angle = arrow2.height / arrow2.radius * (1 - this.arrow2.curveOverlap);
        curveAngle -= arrow2Angle;
        trueCurveAngle -= arrow2.height / arrow2.radius;
      }

      if (trueCurveAngle < 0) {
        if (arrow1 && arrow1.autoHide) {
          arrow1Hide = true;
          trueCurveAngle += arrow1.height / arrow1.radius;
          curveAngle += arrow1Angle;
        }

        if (arrow2 && arrow2.autoHide) {
          arrow2Hide = true;
          trueCurveAngle += arrow2.height / arrow2.radius;
          curveAngle += arrow2Angle;
        }
      }

      if (_arrow1 && arrow1) {
        if (arrow1Hide) {
          _arrow1.hide();
        } else {
          _arrow1.show();

          _arrow1.transform.updateTranslation(arrow1.radius, 0);

          var arrowLengthAngle = arrow1.height / arrow1.radius;

          _arrow1.transform.updateRotation(Math.PI / 2 + arrowLengthAngle);

          rotationForArrow1 = arrow1Angle;
        }
      }

      if (_arrow2 && arrow2) {
        if (arrow2Hide) {
          _arrow2.hide();
        } else {
          _arrow2.show();

          _arrow2.transform.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(arrow2.radius, this.angle));

          var _arrowLengthAngle = arrow2.height / arrow2.radius;

          _arrow2.transform.updateRotation(this.angle + Math.PI / 2 - _arrowLengthAngle); // curveAngle += arrowLengthAngle * (1 - arrow2LengthModifier);

        }
      }

      if (labelRotationOffset != null) {
        this.lastLabelRotationOffset = labelRotationOffset;
      }

      this.transform.updateTranslation(this.position);
      this.transform.updateRotation(this.rotation);
      var _curve = this._curve,
          curve = this.curve,
          _curveRight = this._curveRight;

      if (_curve != null && curve != null) {
        if (this.autoRightAngle && this.angle >= Math.PI / 2 - this.rightAngleRange / 2 && this.angle <= Math.PI / 2 + this.rightAngleRange / 2) {
          if (_curveRight != null) {
            _curveRight.showAll();
          }

          _curve.hide();

          if (_arrow1 != null) {
            _arrow1.hide();
          }

          if (_arrow2 != null) {
            _arrow2.hide();
          }
        } else {
          if (_curveRight != null) {
            _curveRight.hide();
          }

          if (_arrow1 != null && arrow1Hide === false) {
            _arrow1.show();
          }

          if (_arrow2 != null && arrow2Hide === false) {
            _arrow2.show();
          } // _curve.show();


          curveAngle = Math.max(curveAngle, 0); // _curve.angleToDraw = curveAngle;
          // _curve.transform.updateRotation(rotationForArrow1);

          this.updateCurve(curveAngle, this.angle, rotationForArrow1, true);
        }
      }

      var _label = this._label,
          label = this.label;

      if (_label && label) {
        if (label.autoHide > this.angle) {
          _label.hide();
        } else {
          _label.show();

          if (label.showRealAngle) {
            var angleText = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(this.angle * 180 / Math.PI, label.realAngleDecimals).toString();

            _label._base.drawingObject.setText("".concat(angleText, "\xBA"));

            label.eqn.reArrangeCurrentForm();
          }

          var labelPosition = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(label.radius, this.angle * label.curvePosition);

          if (label.orientation === 'horizontal') {
            label.updateRotation(-this.rotation - this.lastLabelRotationOffset, labelPosition, label.radius / 5, this.angle * label.curvePosition);
          }

          if (label.orientation === 'tangent') {
            label.updateRotation(this.angle * label.curvePosition - Math.PI / 2, labelPosition, label.radius / 50, this.angle * label.curvePosition);
          }
        }
      }

      var _side1 = this._side1,
          side1 = this.side1;

      if (_side1 && side1) {
        // _side1.transform.updateRotation(this.rotation);
        _side1.transform.updateScale(side1.length, 1);
      }

      var _side2 = this._side2,
          side2 = this.side2;

      if (_side2 && side2) {
        _side2.transform.updateRotation(this.angle);

        _side2.transform.updateScale(side2.length, 1);
      }
    }
  }, {
    key: "showAll",
    value: function showAll() {
      _get(_getPrototypeOf(DiagramObjectAngle.prototype), "showAll", this).call(this);

      this.update();
    }
  }]);

  return DiagramObjectAngle;
}(_Element__WEBPACK_IMPORTED_MODULE_3__["DiagramElementCollection"]);

/* harmony default export */ __webpack_exports__["default"] = (DiagramObjectAngle);

/***/ }),

/***/ "./src/js/diagram/DiagramObjects/DiagramObjects.js":
/*!*********************************************************!*\
  !*** ./src/js/diagram/DiagramObjects/DiagramObjects.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DiagramObjects; });
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DrawContext2D */ "./src/js/diagram/DrawContext2D.js");
/* harmony import */ var _EquationNavigator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EquationNavigator */ "./src/js/diagram/DiagramObjects/EquationNavigator.js");
/* harmony import */ var _DiagramElements_Equation_GLEquation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../DiagramElements/Equation/GLEquation */ "./src/js/diagram/DiagramElements/Equation/GLEquation.js");
/* harmony import */ var _Line__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Line */ "./src/js/diagram/DiagramObjects/Line.js");
/* harmony import */ var _Angle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Angle */ "./src/js/diagram/DiagramObjects/Angle.js");
/* harmony import */ var _PolyLine__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./PolyLine */ "./src/js/diagram/DiagramObjects/PolyLine.js");
/* harmony import */ var _EquationLabel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./EquationLabel */ "./src/js/diagram/DiagramObjects/EquationLabel.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



 // import {
//   DiagramElementCollection,
// } from '../Element';









var DiagramObjects =
/*#__PURE__*/
function () {
  function DiagramObjects(shapes, equation, isTouchDevice, animateNextFrame) {
    _classCallCheck(this, DiagramObjects);

    this.webgl = shapes.webgl;
    this.draw2D = shapes.draw2D;
    this.limits = shapes.limits;
    this.shapes = shapes;
    this.isTouchDevice = isTouchDevice;
    this.animateNextFrame = animateNextFrame;
    this.equation = equation;
  }

  _createClass(DiagramObjects, [{
    key: "equationNavigator",
    value: function equationNavigator(equation, offset) {
      var navType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'threeLine';
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      var xAlign = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'left';
      var vAlign = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'middle';
      var id = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "id_lesson__equation_navigator_".concat(Math.floor(Math.random() * 10000));
      return new _EquationNavigator__WEBPACK_IMPORTED_MODULE_4__["default"](this.shapes, this.animateNextFrame, equation, offset, navType, options, xAlign, vAlign, id);
    }
  }, {
    key: "line",
    value: function line() {
      for (var _len = arguments.length, options = new Array(_len), _key = 0; _key < _len; _key++) {
        options[_key] = arguments[_key];
      }

      // const optionsToUse = Object.assign({}, ...options);
      // console.log(Object.assign({}, ...options))
      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options));
      return new _Line__WEBPACK_IMPORTED_MODULE_6__["default"](this.shapes, this.equation, this.isTouchDevice, this.animateNextFrame, optionsToUse);
    }
  }, {
    key: "angle",
    value: function angle() {
      for (var _len2 = arguments.length, options = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        options[_key2] = arguments[_key2];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options));
      return new _Angle__WEBPACK_IMPORTED_MODULE_7__["default"](this.shapes, this.equation, this.isTouchDevice, this.animateNextFrame, optionsToUse);
    }
  }, {
    key: "label",
    value: function label() {
      for (var _len3 = arguments.length, options = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        options[_key3] = arguments[_key3];
      }

      // const optionsToUse = Object.assign({}, ...options);
      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options));
      return new _EquationLabel__WEBPACK_IMPORTED_MODULE_9__["default"](this.equation, optionsToUse);
    }
  }, {
    key: "polyLine",
    value: function polyLine() {
      for (var _len4 = arguments.length, options = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        options[_key4] = arguments[_key4];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options));
      return new _PolyLine__WEBPACK_IMPORTED_MODULE_8__["default"](this.shapes, this.equation, this, this.isTouchDevice, this.animateNextFrame, optionsToUse);
    } // lineNew(
    //   position: Point,
    //   length: number,
    //   angle: number,
    //   width: number,
    //   color: Array<number>,
    //   vertexSpaceStart: 'start' | 'end' | 'center' | number | Point = 'start',
    //   showLine: boolean,
    //   largerTouchBorder: boolean,
    // ) {
    //   return new DiagramObjectLine(
    //     this.shapes, this.equation, this.isTouchDevice, this.animateNextFrame,
    //     {
    //       position,
    //       length,
    //       angle,
    //       vertexSpaceStart,
    //       width,
    //       color,
    //       showLine,
    //       largerTouchBorder,
    //     },
    //   );
    // }
    // linePoints(
    //   p1: Point,
    //   p2: Point,
    //   width: number,
    //   color: Array<number>,
    //   vertexOrigin: 'start' | 'end' | 'center' | number | Point = 'start',
    //   showLine: boolean,
    //   largerTouchBorder: boolean,
    //   ) {
    // }
    // length
    // width
    // color
    // vertexOrigin
    // line(
    //   p1OrPositionOrLength: Point | number,
    //   p2OrLengthOrWidth: Point | number,
    //   widthOrAngleOrColor: number | Array<number>,
    //   colorOrWidthOrVertexOrigin: Array<number> | number | TypeVertexSpaceStart | null = null,
    //   vertexOriginOrColor: TypeVertexOrigin | Array<number> | null = null,
    //   showLineOrVertexOrigin: boolean | TypeVertexOrigin | null = null,
    //   largerTouchBorderOrShowLine: boolean | null = null,
    //   largerTouchBorder: boolean | null = null,
    // ) {
    //   let position = new Point(0, 0);
    //   let length = 1;
    //   let angle = 0;
    //   let width = 0.01;
    //   let color = [1, 0, 0, 1];
    //   let vertexOrigin = 'start';
    //   let showLine = true;
    //   let largerTouchBorderToUse = true;
    //   if (p1OrPositionOrLength instanceof Point
    //     && p2OrLengthOrWidth instanceof Point) {
    //     const p1 = p1OrPositionOrLength;
    //     const p2 = p2OrLengthOrWidth;
    //     const line = new Line(p1, p2);
    //     position = p1OrPositionOrLength;
    //     length = line.length();
    //     angle = line.angle();
    //     width = widthOrAngleOrColor;
    //     color = colorOrWidthOrVertexOrigin;
    //     vertexOrigin = vertexOriginOrColor;
    //     showLine = showLineOrVertexOrigin;
    //     largerTouchBorderToUse = largerTouchBorderOrShowLine;
    //   } else if (p1OrPositionOrLength instanceof Point
    //     && typeof p2OrLengthOrWidth === 'number'
    //   ) {
    //     position = p1OrPositionOrLength;
    //     length = p2OrLengthOrWidth;
    //     angle = widthOrAngleOrColor;
    //     width = colorOrWidthOrVertexOrigin;
    //     color = vertexOriginOrColor;
    //     vertexOrigin = showLineOrVertexOrigin;
    //     showLine = largerTouchBorderOrShowLine;
    //     largerTouchBorderToUse = largerTouchBorder;
    //   } else {
    //     position = new Point(0, 0);
    //     length = p1OrPositionOrLength;
    //     width = p2OrLengthOrWidth;
    //     color = widthOrAngleOrColor;
    //     vertexOrigin = colorOrWidthOrVertexOrigin;
    //     showLine = true;
    //     largerTouchBorderToUse = true;
    //   }
    //   if (vertexOrigin == null) {
    //     vertexOrigin = 'start';
    //   }
    //   if (showLine == null) {
    //     showLine = true;
    //   }
    //   if (largerTouchBorderToUse == null) {
    //     largerTouchBorderToUse = true;
    //   }
    //   return new DiagramObjectLine(
    //     // $FlowFixMe
    //     this.shapes, this.equation, this.isTouchDevice, this.animateNextFrame,
    //     {
    //       position,
    //       length,
    //       angle,
    //       vertexOrigin,
    //       width,
    //       color,
    //       showLine,
    //       largerTouchBorder,
    //     },
    //   );
    // }
    // lineOld(
    //   referenceOrP1: TypeVertexSpaceStart | Point = 'center',
    //   lengthOrP2: number | Point,
    //   width: number,
    //   color: Array<number>,
    //   showLine: boolean = true,
    //   largerTouchBorder: boolean = true,
    // ) {
    //   let line;
    //   if (referenceOrP1 instanceof Point && lengthOrP2 instanceof Point) {
    //     line = new DiagramObjectLine(
    //       this.shapes, this.equation, this.isTouchDevice, this.animateNextFrame,
    //       {
    //         position: referenceOrP1,
    //         width,
    //         color,
    //         showLine,
    //         largerTouchBorder,
    //       },
    //     );
    //     line.setEndPoints(referenceOrP1, lengthOrP2);
    //     // return line;
    //   } else if (referenceOrP1 instanceof Point && typeof lengthOrP2 === 'number') {
    //     line = this.lineNew(
    //       referenceOrP1, lengthOrP2, 0, width, color, 'start', showLine,
    //       largerTouchBorder,
    //     );
    //     // return line;
    //     // const line = new DiagramObjectLine(
    //     //   this.shapes, this.equation, this.isTouchDevice, this.animateNextFrame,
    //     //   referenceOrP1, lengthOrP2, width, 'end', width, color, showLine,
    //     //   largerTouchBorder,
    //     // )
    //     // return new DiagramObjectLine(
    //     //   this.shapes, this.equation, this.isTouchDevice, this.animateNextFrame,
    //     //   referenceOrP1, lengthOrP2, width, color, showLine, largerTouchBorder,
    //     // );
    //   } else if (typeof lengthOrP2 === 'number') {
    //     line = this.lineNew(
    //       new Point(0, 0), lengthOrP2, 0, width, color, referenceOrP1, showLine,
    //       largerTouchBorder,
    //     );
    //   } else {
    //     line = this.lineNew(
    //       new Point(0, 0), 1, 0, 0.01, [1, 0, 0, 1], 'start', true, true,
    //     );
    //   }
    //   return line;
    // }
    // lineArrow(
    //   referenceOrP1: TypeVertexSpaceStart = 'center',
    //   lengthOrP2: number | Point,
    //   width: number,
    //   color: Array<number>,
    //   arrowHeight: number = width * 4,
    //   arrowWidth: number = width * 4,
    //   largerTouchBorder: boolean = true,
    // ) {
    //   const line = this.lineOld(
    //     referenceOrP1, lengthOrP2, width, color,
    //     true, largerTouchBorder,
    //   );
    //   // const line = new DiagramObjectLine(
    //   //   this.shapes, this.equation, this.isTouchDevice, this.animateNextFrame,
    //   //   referenceOrP1, lengthOrP2, width, color, true, largerTouchBorder,
    //   // );
    //   line.addArrow(2, arrowWidth, arrowHeight);
    //   return line;
    // }
    // lineArrows(
    //   referenceOrP1: TypeVertexSpaceStart = 'center',
    //   lengthOrP2: number | Point,
    //   width: number,
    //   color: Array<number>,
    //   arrowHeight: number = width * 4,
    //   arrowWidth: number = width * 4,
    //   largerTouchBorder: boolean = true,
    // ) {
    //   const line = this.lineArrow(
    //     referenceOrP1, lengthOrP2, width, color, arrowHeight, arrowWidth,
    //     largerTouchBorder,
    //   );
    //   line.addArrow(1, arrowWidth, arrowHeight);
    //   return line;
    // }
    // lineLabelOnly(
    //   referenceOrP1: TypeVertexSpaceStart = 'center',
    //   lengthOrP2: number | Point,
    //   color: Array<number>,
    //   labelText: string | Equation | Array<string>,
    //   offset: number,
    //   location: TypeLineLabelLocation = 'outside',
    //   subLocation: TypeLineLabelSubLocation = 'left',
    //   orientation: TypeLineLabelOrientation = 'horizontal',
    //   linePosition: number = 0.5,
    // ) {
    //   const line = this.lineOld(
    //     referenceOrP1, lengthOrP2, 0.001, color,
    //     false, false,
    //   );
    //   // const line = new DiagramObjectLine(
    //   //   this.shapes, this.equation, this.isTouchDevice, this.animateNextFrame,
    //   //   referenceOrP1, lengthOrP2, 0.001, color, false, false,
    //   // );
    //   line.addLabel(
    //     labelText, offset, location, subLocation, orientation, linePosition,
    //   );
    //   return line;
    // }
    // lineLabel(
    //   referenceOrP1: TypeVertexSpaceStart = 'center',
    //   lengthOrP2: number | Point,
    //   width: number,
    //   color: Array<number>,
    //   labelText: string | Equation | Array<string>,
    //   offset: number,
    //   location: TypeLineLabelLocation = 'outside',
    //   subLocation: TypeLineLabelSubLocation = 'left',
    //   orientation: TypeLineLabelOrientation = 'horizontal',
    //   linePosition: number = 0.5,
    // ) {
    //   // const line = new DiagramObjectLine(
    //   //   this.shapes, this.equation, this.isTouchDevice, this.animateNextFrame,
    //   //   referenceOrP1, lengthOrP2, width, color, true, false,
    //   // );
    //   const line = this.lineOld(
    //     referenceOrP1, lengthOrP2, width, color,
    //     true, false,
    //   );
    //   line.addLabel(
    //     labelText, offset, location, subLocation, orientation, linePosition,
    //   );
    //   return line;
    // }

  }]);

  return DiagramObjects;
}();



/***/ }),

/***/ "./src/js/diagram/DiagramObjects/EqnNavigator.js":
/*!*******************************************************!*\
  !*** ./src/js/diagram/DiagramObjects/EqnNavigator.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EqnNavigator; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _DiagramElements_Equation_EquationForm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DiagramElements/Equation/EquationForm */ "./src/js/diagram/DiagramElements/Equation/EquationForm.js");
/* harmony import */ var _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tools/htmlGenerator */ "./src/js/tools/htmlGenerator.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _DiagramElements_Equation_Equation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../DiagramElements/Equation/Equation */ "./src/js/diagram/DiagramElements/Equation/Equation.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }


 // import { Equation } from '../DiagramElements/Equation/GLEquation';




 // eslint-disable-next-line no-use-before-define
// export type TypeEquationNavigator = EquationNavigator;

function updateDescription(eqn, subForm, descriptionElement, index) {
  var setClicks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var prefix = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';
  var element = descriptionElement;

  if (element == null) {
    return;
  }

  var form = null; // $FlowFixMe
  // form = eqn.eqn.formSeries[index][formType];

  form = eqn.getForm(eqn.eqn.formSeries[index], subForm);

  if (form == null) {
    return;
  }

  if (form.description == null) {
    return;
  }

  var monochrome = !setClicks;

  if (descriptionElement) {
    if (setClicks) {
      // eslint-disable-next-line no-param-reassign
      descriptionElement.innerHTML = _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_3__["applyModifiers"]("".concat(prefix).concat(form.description), form.modifiers);
      _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_3__["setOnClicks"](form.modifiers);
    } else {
      // eslint-disable-next-line no-param-reassign
      descriptionElement.innerHTML = _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_3__["applyModifiers"]("".concat(prefix).concat(form.description), form.modifiers, '', monochrome);
    }
  }
}

function enableTouch(element) {
  if (element) {
    element.classList.remove('lesson__eqn_nav__not_touchable');
  }
}

function disableTouch(element) {
  if (element) {
    element.classList.add('lesson__eqn_nav__not_touchable');
  }
}

function _updateButtons( // eslint-disable-next-line no-use-before-define
nav) {
  var includeNextPrevPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var nextPrefix = '';
  var prevPrefix = '';

  if (includeNextPrevPrefix) {
    nextPrefix = 'NEXT: ';
    prevPrefix = 'PREV: ';
  }

  var currentForm = nav.eqn.getCurrentForm();

  if (currentForm != null) {
    var index = nav.eqn.getFormIndex(currentForm);

    if (index === 0) {
      disableTouch(nav.refresh);
      disableTouch(nav.prev);
      disableTouch(nav.prevDescription);
      disableTouch(nav.description); // enableTouch(nav.nextDescription, true);
    } else {
      enableTouch(nav.refresh);
      enableTouch(nav.prev);
      enableTouch(nav.prevDescription);
      enableTouch(nav.description);
    }

    if (nav.eqn.eqn.formSeries.length > 1) {
      enableTouch(nav.next);
      enableTouch(nav.nextDescription);
    } else {
      disableTouch(nav.next);
      disableTouch(nav.nextDescription);
    }

    var nextIndex = index + 1;

    if (nextIndex > nav.eqn.eqn.formSeries.length - 1) {
      if (nav.nextDescription) {
        // eslint-disable-next-line no-param-reassign
        nav.nextDescription.innerHTML = 'RESTART from begining';
      }
    } else {
      updateDescription(nav.eqn, currentForm.subForm, nav.nextDescription, nextIndex, false, nextPrefix);
    }

    updateDescription(nav.eqn, currentForm.subForm, nav.description, index, true); // nav.eqn.updateDescription(currentForm);

    var prevIndex = index - 1;

    if (prevIndex >= 0) {
      updateDescription(nav.eqn, currentForm.subForm, nav.prevDescription, prevIndex, false, prevPrefix);
    } else if (nav.prevDescription) {
      // eslint-disable-next-line no-param-reassign
      nav.prevDescription.innerHTML = '';
    }
  }
} // eslint-disable-next-line no-use-before-define


function updateButtonsDescriptionOnly(nav) {
  var currentForm = nav.eqn.getCurrentForm();

  if (currentForm != null) {
    var index = nav.eqn.getFormIndex(currentForm);
    enableTouch(nav.description);
    updateDescription(nav.eqn, currentForm.subForm, nav.description, index, true);
  }
}

// Nav3Line
function makeType3Line(prevMethod, refreshMethod, nextMethod, options) {
  var table = document.createElement('table');
  var prevGroup = document.createElement('tr');
  var currentGroup = document.createElement('tr');
  var nextGroup = document.createElement('tr');
  var prev = document.createElement('td');
  var refresh = document.createElement('td');
  var next = document.createElement('td');
  var prevDescription = document.createElement('td');
  var description = document.createElement('td');
  var nextDescription = document.createElement('td');
  prevGroup.appendChild(prev);
  prevGroup.appendChild(prevDescription);
  nextGroup.appendChild(next);
  nextGroup.appendChild(nextDescription);
  currentGroup.appendChild(refresh);
  currentGroup.appendChild(description);
  table.appendChild(prevGroup);
  table.appendChild(currentGroup);
  table.appendChild(nextGroup);
  table.classList.add('lesson__eqn_nav__table');
  prevGroup.classList.add('lesson__eqn_nav__3line__prevRow');
  currentGroup.classList.add('lesson__eqn_nav__3line__currentRow');
  nextGroup.classList.add('lesson__eqn_nav__3line__nextRow');
  prev.classList.add('lesson__eqn_nav__3line__prevRow__button');
  refresh.classList.add('lesson__eqn_nav__3line__currentRow__button');
  next.classList.add('lesson__eqn_nav__3line__nextRow__button');
  prevDescription.classList.add('lesson__eqn_nav__3line__prevRow__description');
  description.classList.add('lesson__eqn_nav__3line__currentRow__description');
  description.classList.add('lesson__eqn_nav__description');
  nextDescription.classList.add('lesson__eqn_nav__3line__nextRow__description');
  var defaultOptions = {
    forceTwoLines: false,
    arrows: false
  };
  var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, options); // if (!Array.isArray(options)) {
  //   optionsToUse = [options];
  // }
  // Use two lines to stop jittering when transitioning from one line to two
  // lines

  if (optionsToUse.forceTwoLines) {
    prevGroup.classList.add('lesson__eqn_nav__3line__prev_twoLines');
    currentGroup.classList.add('lesson__eqn_nav__3line__current_twoLines');
    nextGroup.classList.add('lesson__eqn_nav__3line__next_twoLines');
  }

  prevGroup.onclick = prevMethod;
  currentGroup.onclick = refreshMethod;
  nextGroup.onclick = nextMethod;
  next.innerHTML = 'Next';
  prev.innerHTML = 'Prev';
  refresh.innerHTML = 'Refresh';
  return {
    table: table,
    prevGroup: prevGroup,
    currentGroup: currentGroup,
    nextGroup: nextGroup,
    prev: prev,
    refresh: refresh,
    next: next,
    prevDescription: prevDescription,
    description: description,
    nextDescription: nextDescription
  };
} // NavDescriptionOnly


function makeTypeDescriptionOnly(nextMethod) {
  var table = document.createElement('table');
  var currentGroup = document.createElement('tr');
  var description = document.createElement('td');
  currentGroup.appendChild(description);
  table.appendChild(currentGroup);
  table.classList.add('lesson__eqn_nav__table');
  currentGroup.classList.add('lesson__eqn_nav__description_only__currentRow');
  description.classList.add('lesson__eqn_nav__description_only__currentRow__description');
  description.classList.add('lesson__eqn_nav__description');
  currentGroup.onclick = nextMethod;
  return {
    table: table,
    currentGroup: currentGroup,
    description: description
  };
} // Nav1Line


function makeType1Line(prevMethod, refreshMethod, nextMethod, options) // can be: 'twoLines'
{
  var table = document.createElement('table');
  var currentGroup = document.createElement('tr');
  var prev = document.createElement('td');
  var next = document.createElement('td');
  var description = document.createElement('td');
  currentGroup.appendChild(prev);
  currentGroup.appendChild(description);
  currentGroup.appendChild(next);
  table.appendChild(currentGroup);
  table.classList.add('lesson__eqn_nav__table');
  currentGroup.classList.add('lesson__eqn_nav__1line__currentRow');
  prev.classList.add('lesson__eqn_nav__1line__prev__button');
  next.classList.add('lesson__eqn_nav__1line__next__button');
  description.classList.add('lesson__eqn_nav__1line__currentRow__description');
  description.classList.add('lesson__eqn_nav__description');
  var defaultOptions = {
    forceTwoLines: false,
    arrows: false
  };
  var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, options); // Use two lines to stop jittering when transitioning from one line to two
  // lines

  if (optionsToUse.forceTwoLines) {
    currentGroup.classList.add('lesson__eqn_nav__1line__current_twoLines');
  }

  prev.onclick = prevMethod;
  description.onclick = refreshMethod;
  next.onclick = nextMethod;

  if (optionsToUse.arrows) {
    var nextArrow = document.createElement('div');
    nextArrow.classList.add('lesson__eqn_nav__arrow_right');
    next.appendChild(nextArrow);
    var prevArrow = document.createElement('div');
    prevArrow.classList.add('lesson__eqn_nav__arrow_left');
    prev.appendChild(prevArrow);
  } else {
    next.innerHTML = 'Next';
    prev.innerHTML = 'Prev';
  }

  return {
    table: table,
    currentGroup: currentGroup,
    prev: prev,
    next: next,
    description: description
  };
} // Nav2Line


function makeType2Line(prevMethod, refreshMethod, nextMethod, options) {
  var table = document.createElement('table');
  var row = document.createElement('tr');
  var descriptionRows = document.createElement('tr');
  var currentGroup = document.createElement('tr');
  var prev = document.createElement('td');
  var next = document.createElement('td');
  var nextGroup = document.createElement('tr'); // const descriptionRows = document.createElement('td');
  // const descriptionRow = document.createElement('tr');
  // const nextDescriptionRow = document.createElement('tr');

  var description = document.createElement('td');
  var nextDescription = document.createElement('td');
  currentGroup.appendChild(description);
  nextGroup.appendChild(nextDescription);
  descriptionRows.appendChild(currentGroup);
  descriptionRows.appendChild(nextGroup);
  row.appendChild(prev);
  row.appendChild(descriptionRows);
  row.appendChild(next);
  table.appendChild(row);
  table.classList.add('lesson__eqn_nav__table');
  currentGroup.classList.add('lesson__eqn_nav__2lines__currentRow');
  nextGroup.classList.add('lesson__eqn_nav__2lines__nextRow');
  prev.classList.add('lesson__eqn_nav__2lines__prev__button');
  next.classList.add('lesson__eqn_nav__2lines__next__button');
  description.classList.add('lesson__eqn_nav__2lines__currentRow__description');
  description.classList.add('lesson__eqn_nav__description');
  nextDescription.classList.add('lesson__eqn_nav__2lines__nextRow__description');
  var defaultOptions = {
    forceTwoLines: false,
    arrows: false
  };
  var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, options); // Use two lines to stop jittering when transitioning from one line to two
  // lines

  if (optionsToUse.forceTwoLines > -1) {
    currentGroup.classList.add('lesson__eqn_nav__2lines__current_twoLines');
  }

  prev.onclick = prevMethod;
  description.onclick = refreshMethod;
  next.onclick = nextMethod;
  nextDescription.onclick = nextMethod;

  if (optionsToUse.arrows) {
    var nextArrow = document.createElement('div');
    nextArrow.classList.add('lesson__eqn_nav__arrow_right');
    next.appendChild(nextArrow);
    var prevArrow = document.createElement('div');
    prevArrow.classList.add('lesson__eqn_nav__arrow_left');
    prev.appendChild(prevArrow);
  } else {
    next.innerHTML = 'Next';
    prev.innerHTML = 'Prev';
  }

  return {
    table: table,
    currentGroup: currentGroup,
    nextGroup: nextGroup,
    prev: prev,
    next: next,
    nextDescription: nextDescription,
    description: description
  };
}

var EqnNavigator =
/*#__PURE__*/
function (_DiagramElementCollec) {
  _inherits(EqnNavigator, _DiagramElementCollec);

  // setEquation: (Equation) => void;
  function EqnNavigator(shapes, // eqn: EquationNew,
  animateNextFrame) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, EqnNavigator);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(EqnNavigator).call(this, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Eqn Nav').scale(1, 1).translate(0, 0), shapes.limits)); // super(shapes, eqnOptions);

    _this.shapes = shapes; // this.setEquation(equation);

    _this.prev = null;
    _this.next = null;
    _this.refresh = null;
    _this.description = null;
    _this.nextDescription = null;
    _this.prevDescription = null;
    _this.table = null;
    _this.prevGroup = null;
    _this.currentGroup = null;
    _this.nextGroup = null;
    _this.animateNextFrame = animateNextFrame;
    var defaultOptions = {
      offset: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      navType: 'twoLine',
      navTypeOptions: {
        forceTwoLines: false,
        arrows: false
      },
      alignH: 'left',
      alignV: 'middle',
      id: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["generateUniqueId"])('id_lesson__equation_navigator_')
    };
    var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, options);
    _this.eqn = optionsToUse.equation;
    _this.navType = optionsToUse.navType;
    var navigatorHTMLElement = null;

    if (_this.navType === '3Line') {
      navigatorHTMLElement = makeType3Line(_this.clickPrev.bind(_assertThisInitialized(_assertThisInitialized(_this))), _this.clickRefresh.bind(_assertThisInitialized(_assertThisInitialized(_this))), _this.clickNext.bind(_assertThisInitialized(_assertThisInitialized(_this))), optionsToUse.navTypeOptions);
    }

    if (_this.navType === 'description') {
      navigatorHTMLElement = makeTypeDescriptionOnly(_this.clickNext.bind(_assertThisInitialized(_assertThisInitialized(_this))));
    }

    if (_this.navType === '1Line') {
      navigatorHTMLElement = makeType1Line(_this.clickPrev.bind(_assertThisInitialized(_assertThisInitialized(_this))), _this.clickRefresh.bind(_assertThisInitialized(_assertThisInitialized(_this))), _this.clickNext.bind(_assertThisInitialized(_assertThisInitialized(_this))), optionsToUse.navTypeOptions);
    }

    if (_this.navType === '2Line') {
      navigatorHTMLElement = makeType2Line(_this.clickPrev.bind(_assertThisInitialized(_assertThisInitialized(_this))), _this.clickRefresh.bind(_assertThisInitialized(_assertThisInitialized(_this))), _this.clickNext.bind(_assertThisInitialized(_assertThisInitialized(_this))), optionsToUse.navTypeOptions);
    } // const eqnCollectionPosition = this.eqn.getPosition();


    if (navigatorHTMLElement != null) {
      var offsetToUse = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["parsePoint"])(optionsToUse.offset, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
      Object.assign(_assertThisInitialized(_assertThisInitialized(_this)), navigatorHTMLElement);

      var table = _this.shapes.htmlElement(navigatorHTMLElement.table, "".concat(optionsToUse.id, "_table"), '', offsetToUse, optionsToUse.alignV, optionsToUse.alignH);

      _this.add('table', table);
    }

    _this.eqn.onClick = _this.clickNext.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.eqn.hasTouchableElements = true;
    _this.eqn.isTouchable = true;
    _this.eqn.touchInBoundingRect = true;
    return _this;
  } // const navigator = shapes.collection(;
  // setEquation(eqn: Equation) {
  //   this.eqn = eqn;
  //   // this._eqn = [];
  //   this.add('eqn', eqn.collection);
  // }


  _createClass(EqnNavigator, [{
    key: "clickNext",
    value: function clickNext() {
      this.eqn.nextForm(1.5);
      this.updateButtons();
      this.animateNextFrame();
    }
  }, {
    key: "clickPrev",
    value: function clickPrev() {
      this.eqn.prevForm(1.5);
      this.updateButtons();
      this.animateNextFrame();
    }
  }, {
    key: "clickRefresh",
    value: function clickRefresh() {
      var currentForm = this.eqn.getCurrentForm();

      if (currentForm != null) {
        var index = this.eqn.getFormIndex(currentForm);

        if (index > 0) {
          this.eqn.replayCurrentForm(1.5);
          this.animateNextFrame();
        }
      }

      this.updateButtons();
    }
  }, {
    key: "updateButtons",
    value: function updateButtons() {
      if (this.navType === 'equationOnly') {
        return;
      }

      if (this.navType === 'description') {
        updateButtonsDescriptionOnly(this);
      } else if (this.navType === '2Line') {
        _updateButtons(this, true);
      } else {
        _updateButtons(this);
      }
    }
  }, {
    key: "showForm",
    value: function showForm(formOrName) {
      var formType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.show();
      this.eqn.showForm(formOrName, formType); // this.showForm(formOrName, formType);

      if (this._table) {
        this._table.show();

        this.updateButtons();
      }
    }
  }]);

  return EqnNavigator;
}(_Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementCollection"]);



/***/ }),

/***/ "./src/js/diagram/DiagramObjects/EquationLabel.js":
/*!********************************************************!*\
  !*** ./src/js/diagram/DiagramObjects/EquationLabel.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EquationLabel; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _DiagramElements_Equation_GLEquation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DiagramElements/Equation/GLEquation */ "./src/js/diagram/DiagramElements/Equation/GLEquation.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// import Diagram from '../Diagram';


 // export type TypeEquationLabel = {
//   eqn: Equation;
//   updateRotation: (number, Point, number, number) => void;
//   setText: (string) => {};
//   getText: void => string;
//   // updateScale: (Point) => void;
// };

var EquationLabel =
/*#__PURE__*/
function () {
  function EquationLabel(equations) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, EquationLabel);

    var defaultOptions = {
      label: '',
      color: [0, 0, 1, 1],
      scale: 0.7,
      position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      form: '0',
      formType: 'base',
      vAlign: 'middle',
      hAlign: 'center'
    };
    var optionsToUse = Object.assign({}, defaultOptions, options);
    var labelTextOrEquation = optionsToUse.label;
    var color = optionsToUse.color,
        scale = optionsToUse.scale,
        position = optionsToUse.position;
    var form = optionsToUse.form,
        formType = optionsToUse.formType;
    var vAlign = optionsToUse.vAlign,
        hAlign = optionsToUse.hAlign;
    var eqn;

    if (typeof labelTextOrEquation === 'string') {
      eqn = equations.makeEqn();
      eqn.createElements({
        base: labelTextOrEquation
      }, color);
      eqn.collection.transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).rotate(0).translate(position);
      eqn.formAlignment.fixTo = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      eqn.formAlignment.hAlign = hAlign;
      eqn.formAlignment.vAlign = vAlign;
      eqn.formAlignment.scale = scale;
      eqn.addForm('base', ['base']);
      eqn.setCurrentForm('base');
    } else if (labelTextOrEquation instanceof _DiagramElements_Equation_GLEquation__WEBPACK_IMPORTED_MODULE_1__["Equation"]) {
      eqn = labelTextOrEquation;
    } else if (Array.isArray(labelTextOrEquation)) {
      eqn = equations.makeEqn();
      var elements = {};
      labelTextOrEquation.forEach(function (labelText, index) {
        elements["_".concat(index)] = labelText;
      });
      eqn.createElements(elements, color);
      eqn.collection.transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).rotate(0).translate(position);
      eqn.formAlignment.fixTo = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      eqn.formAlignment.hAlign = hAlign;
      eqn.formAlignment.vAlign = vAlign;
      eqn.formAlignment.scale = scale;
      labelTextOrEquation.forEach(function (labelText, index) {
        eqn.addForm("".concat(index), ["_".concat(index)]);
      });
      eqn.setCurrentForm(form, formType);
    } else {
      // eslint-disable-next-line no-lonely-if
      if (labelTextOrEquation.eqn === 'fraction') {
        var defaultFracOptions = {
          color: color,
          scale: 0.5
        };
        var fracOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultFracOptions, labelTextOrEquation);
        eqn = equations.fraction(fracOptions);
        eqn.setCurrentForm('base');
      } else {
        // if (labelTextOrEquation.eqn === 'fractionPre') {
        var _defaultFracOptions = {
          color: color,
          scale: 0.7,
          fracScale: 0.5
        };

        var _fracOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, _defaultFracOptions, labelTextOrEquation);

        eqn = equations.fractionPre(_fracOptions);
        eqn.setCurrentForm('base');
      }
    }

    this.eqn = eqn;
  }

  _createClass(EquationLabel, [{
    key: "setText",
    value: function setText(text) {
      var form = this.eqn.getCurrentForm();

      if (form != null) {
        var key = Object.keys(form.elements)[0]; // This is ok to fix for flow because all the elements of the
        // simple equation created by Equationlabel will be Primatives
        // $FlowFixMe

        var textObject = form.elements[key].drawingObject;

        if (textObject != null) {
          textObject.setText(text);
        }

        form.arrange(this.eqn.formAlignment.scale, this.eqn.formAlignment.hAlign, this.eqn.formAlignment.vAlign, this.eqn.formAlignment.fixTo);
      }
    }
  }, {
    key: "getText",
    value: function getText() {
      var textToReturn = '';
      var form = this.eqn.getCurrentForm();

      if (form != null) {
        var key = Object.keys(form.elements)[0]; // This is ok to fix for flow because all the elements of the
        // simple equation created by Equationlabel will be Primatives
        // $FlowFixMe

        var textObject = form.elements[key].drawingObject; // This is ok to fix for flow because all the elements of the
        // simple equation created by Equationlabel will be Primatives
        // that are text objects

        if (textObject != null) {
          // $FlowFixMe
          textToReturn = textObject.text[0].text;
        }
      }

      return textToReturn;
    }
  }, {
    key: "updateRotation",
    value: function updateRotation(labelAngle, position) {
      var offsetMag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var offsetAngle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      if (offsetMag !== 0) {
        var labelWidth = 0;
        var labelHeight = 0;
        var currentForm = this.eqn.getCurrentForm();

        if (currentForm != null) {
          labelWidth = currentForm.width / 2 + 0.04;
          labelHeight = currentForm.height / 2 + 0.04;
        }

        var a = labelWidth + offsetMag;
        var b = labelHeight + offsetMag;
        var r = a * b / Math.sqrt(Math.pow(b * Math.cos(labelAngle - offsetAngle), 2) + Math.pow(a * Math.sin(labelAngle - offsetAngle), 2));
        this.eqn.collection.setPosition(position.add(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(r, offsetAngle)));
      } else {
        this.eqn.collection.setPosition(position);
      }

      this.eqn.collection.transform.updateRotation(labelAngle);
    } // const label = {
    //   eqn,
    //   updateRotation,
    //   setText,
    //   getText,
    //   // updateScale,
    // };
    // return label;

  }]);

  return EquationLabel;
}();



/***/ }),

/***/ "./src/js/diagram/DiagramObjects/EquationNavigator.js":
/*!************************************************************!*\
  !*** ./src/js/diagram/DiagramObjects/EquationNavigator.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EquationNavigator; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _DiagramElements_Equation_GLEquation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DiagramElements/Equation/GLEquation */ "./src/js/diagram/DiagramElements/Equation/GLEquation.js");
/* harmony import */ var _DiagramElements_Equation_EquationForm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DiagramElements/Equation/EquationForm */ "./src/js/diagram/DiagramElements/Equation/EquationForm.js");
/* harmony import */ var _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/htmlGenerator */ "./src/js/tools/htmlGenerator.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }






 // eslint-disable-next-line no-use-before-define

function updateDescription(eqn, formType, descriptionElement, index) {
  var setClicks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var prefix = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';
  var element = descriptionElement;

  if (element == null) {
    return;
  }

  var form = null; // $FlowFixMe

  form = eqn.formSeries[index][formType];

  if (form == null) {
    return;
  }

  if (form.description == null) {
    return;
  }

  var monochrome = !setClicks;

  if (descriptionElement) {
    if (setClicks) {
      // eslint-disable-next-line no-param-reassign
      descriptionElement.innerHTML = _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_4__["applyModifiers"]("".concat(prefix).concat(form.description), form.modifiers);
      _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_4__["setOnClicks"](form.modifiers);
    } else {
      // eslint-disable-next-line no-param-reassign
      descriptionElement.innerHTML = _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_4__["applyModifiers"]("".concat(prefix).concat(form.description), form.modifiers, '', monochrome);
    }
  }
}

function enableTouch(element) {
  if (element) {
    element.classList.remove('lesson__eqn_nav__not_touchable');
  }
}

function disableTouch(element) {
  if (element) {
    element.classList.add('lesson__eqn_nav__not_touchable');
  }
}

function _updateButtons(nav) {
  var includeNextPrevPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var nextPrefix = '';
  var prevPrefix = '';

  if (includeNextPrevPrefix) {
    nextPrefix = 'NEXT: ';
    prevPrefix = 'PREV: ';
  }

  var currentForm = nav.eqn.getCurrentForm();

  if (currentForm != null) {
    var index = nav.eqn.getFormIndex(currentForm);

    if (index === 0) {
      disableTouch(nav.refresh);
      disableTouch(nav.prev);
      disableTouch(nav.prevDescription);
      disableTouch(nav.description); // enableTouch(nav.nextDescription, true);
    } else {
      enableTouch(nav.refresh);
      enableTouch(nav.prev);
      enableTouch(nav.prevDescription);
      enableTouch(nav.description);
    }

    if (nav.eqn.formSeries.length > 1) {
      enableTouch(nav.next);
      enableTouch(nav.nextDescription);
    } else {
      disableTouch(nav.next);
      disableTouch(nav.nextDescription);
    }

    var nextIndex = index + 1;

    if (nextIndex > nav.eqn.formSeries.length - 1) {
      if (nav.nextDescription) {
        // eslint-disable-next-line no-param-reassign
        nav.nextDescription.innerHTML = 'RESTART from begining';
      }
    } else {
      updateDescription(nav.eqn, currentForm.type, nav.nextDescription, nextIndex, false, nextPrefix);
    }

    updateDescription(nav.eqn, currentForm.type, nav.description, index, true); // nav.eqn.updateDescription(currentForm);

    var prevIndex = index - 1;

    if (prevIndex >= 0) {
      updateDescription(nav.eqn, currentForm.type, nav.prevDescription, prevIndex, false, prevPrefix);
    } else if (nav.prevDescription) {
      // eslint-disable-next-line no-param-reassign
      nav.prevDescription.innerHTML = '';
    }
  }
}

function updateButtonsDescriptionOnly(nav) {
  var currentForm = nav.eqn.getCurrentForm();

  if (currentForm != null) {
    var index = nav.eqn.getFormIndex(currentForm);
    enableTouch(nav.description);
    updateDescription(nav.eqn, currentForm.type, nav.description, index, true);
  }
}

function makeType3Line(prevMethod, refreshMethod, nextMethod) // can be: 'twoLines'
{
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var table = document.createElement('table');
  var prevGroup = document.createElement('tr');
  var currentGroup = document.createElement('tr');
  var nextGroup = document.createElement('tr');
  var prev = document.createElement('td');
  var refresh = document.createElement('td');
  var next = document.createElement('td');
  var prevDescription = document.createElement('td');
  var description = document.createElement('td');
  var nextDescription = document.createElement('td');
  prevGroup.appendChild(prev);
  prevGroup.appendChild(prevDescription);
  nextGroup.appendChild(next);
  nextGroup.appendChild(nextDescription);
  currentGroup.appendChild(refresh);
  currentGroup.appendChild(description);
  table.appendChild(prevGroup);
  table.appendChild(currentGroup);
  table.appendChild(nextGroup);
  table.classList.add('lesson__eqn_nav__table');
  prevGroup.classList.add('lesson__eqn_nav__3line__prevRow');
  currentGroup.classList.add('lesson__eqn_nav__3line__currentRow');
  nextGroup.classList.add('lesson__eqn_nav__3line__nextRow');
  prev.classList.add('lesson__eqn_nav__3line__prevRow__button');
  refresh.classList.add('lesson__eqn_nav__3line__currentRow__button');
  next.classList.add('lesson__eqn_nav__3line__nextRow__button');
  prevDescription.classList.add('lesson__eqn_nav__3line__prevRow__description');
  description.classList.add('lesson__eqn_nav__3line__currentRow__description');
  description.classList.add('lesson__eqn_nav__description');
  nextDescription.classList.add('lesson__eqn_nav__3line__nextRow__description');
  var optionsToUse = options;

  if (!Array.isArray(options)) {
    optionsToUse = [options];
  } // Use two lines to stop jittering when transitioning from one line to two
  // lines


  if (optionsToUse.indexOf('twoLines') > -1) {
    prevGroup.classList.add('lesson__eqn_nav__3line__prev_twoLines');
    currentGroup.classList.add('lesson__eqn_nav__3line__current_twoLines');
    nextGroup.classList.add('lesson__eqn_nav__3line__next_twoLines');
  }

  prevGroup.onclick = prevMethod;
  currentGroup.onclick = refreshMethod;
  nextGroup.onclick = nextMethod;
  next.innerHTML = 'Next';
  prev.innerHTML = 'Prev';
  refresh.innerHTML = 'Refresh';
  return {
    table: table,
    prevGroup: prevGroup,
    currentGroup: currentGroup,
    nextGroup: nextGroup,
    prev: prev,
    refresh: refresh,
    next: next,
    prevDescription: prevDescription,
    description: description,
    nextDescription: nextDescription
  };
}

function makeTypeDescriptionOnly(nextMethod) {
  var table = document.createElement('table');
  var currentGroup = document.createElement('tr');
  var description = document.createElement('td');
  currentGroup.appendChild(description);
  table.appendChild(currentGroup);
  table.classList.add('lesson__eqn_nav__table');
  currentGroup.classList.add('lesson__eqn_nav__description_only__currentRow');
  description.classList.add('lesson__eqn_nav__description_only__currentRow__description');
  description.classList.add('lesson__eqn_nav__description');
  currentGroup.onclick = nextMethod;
  return {
    table: table,
    currentGroup: currentGroup,
    description: description
  };
}

function makeType1Line(prevMethod, refreshMethod, nextMethod) // can be: 'twoLines'
{
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var table = document.createElement('table');
  var currentGroup = document.createElement('tr');
  var prev = document.createElement('td');
  var next = document.createElement('td');
  var description = document.createElement('td');
  currentGroup.appendChild(prev);
  currentGroup.appendChild(description);
  currentGroup.appendChild(next);
  table.appendChild(currentGroup);
  table.classList.add('lesson__eqn_nav__table');
  currentGroup.classList.add('lesson__eqn_nav__1line__currentRow');
  prev.classList.add('lesson__eqn_nav__1line__prev__button');
  next.classList.add('lesson__eqn_nav__1line__next__button');
  description.classList.add('lesson__eqn_nav__1line__currentRow__description');
  description.classList.add('lesson__eqn_nav__description');
  var optionsToUse = options;

  if (!Array.isArray(options)) {
    optionsToUse = [options];
  } // Use two lines to stop jittering when transitioning from one line to two
  // lines


  if (optionsToUse.indexOf('twoLines') > -1) {
    currentGroup.classList.add('lesson__eqn_nav__1line__current_twoLines');
  }

  prev.onclick = prevMethod;
  description.onclick = refreshMethod;
  next.onclick = nextMethod;

  if (optionsToUse.indexOf('arrows') > -1) {
    var nextArrow = document.createElement('div');
    nextArrow.classList.add('lesson__eqn_nav__arrow_right');
    next.appendChild(nextArrow);
    var prevArrow = document.createElement('div');
    prevArrow.classList.add('lesson__eqn_nav__arrow_left');
    prev.appendChild(prevArrow);
  } else {
    next.innerHTML = 'Next';
    prev.innerHTML = 'Prev';
  }

  return {
    table: table,
    currentGroup: currentGroup,
    prev: prev,
    next: next,
    description: description
  };
}

function makeType2Line(prevMethod, refreshMethod, nextMethod) // can be: 'twoLines'
{
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var table = document.createElement('table');
  var row = document.createElement('tr');
  var descriptionRows = document.createElement('tr');
  var currentGroup = document.createElement('tr');
  var prev = document.createElement('td');
  var next = document.createElement('td');
  var nextGroup = document.createElement('tr'); // const descriptionRows = document.createElement('td');
  // const descriptionRow = document.createElement('tr');
  // const nextDescriptionRow = document.createElement('tr');

  var description = document.createElement('td');
  var nextDescription = document.createElement('td');
  currentGroup.appendChild(description);
  nextGroup.appendChild(nextDescription);
  descriptionRows.appendChild(currentGroup);
  descriptionRows.appendChild(nextGroup);
  row.appendChild(prev);
  row.appendChild(descriptionRows);
  row.appendChild(next);
  table.appendChild(row);
  table.classList.add('lesson__eqn_nav__table');
  currentGroup.classList.add('lesson__eqn_nav__2lines__currentRow');
  nextGroup.classList.add('lesson__eqn_nav__2lines__nextRow');
  prev.classList.add('lesson__eqn_nav__2lines__prev__button');
  next.classList.add('lesson__eqn_nav__2lines__next__button');
  description.classList.add('lesson__eqn_nav__2lines__currentRow__description');
  description.classList.add('lesson__eqn_nav__description');
  nextDescription.classList.add('lesson__eqn_nav__2lines__nextRow__description');
  var optionsToUse = options;

  if (!Array.isArray(options)) {
    optionsToUse = [options];
  } // Use two lines to stop jittering when transitioning from one line to two
  // lines


  if (optionsToUse.indexOf('twoLines') > -1) {
    currentGroup.classList.add('lesson__eqn_nav__2lines__current_twoLines');
  }

  prev.onclick = prevMethod;
  description.onclick = refreshMethod;
  next.onclick = nextMethod;
  nextDescription.onclick = nextMethod;

  if (optionsToUse.indexOf('arrows') > -1) {
    var nextArrow = document.createElement('div');
    nextArrow.classList.add('lesson__eqn_nav__arrow_right');
    next.appendChild(nextArrow);
    var prevArrow = document.createElement('div');
    prevArrow.classList.add('lesson__eqn_nav__arrow_left');
    prev.appendChild(prevArrow);
  } else {
    next.innerHTML = 'Next';
    prev.innerHTML = 'Prev';
  }

  return {
    table: table,
    currentGroup: currentGroup,
    nextGroup: nextGroup,
    prev: prev,
    next: next,
    nextDescription: nextDescription,
    description: description
  };
}

var EquationNavigator =
/*#__PURE__*/
function (_DiagramElementCollec) {
  _inherits(EquationNavigator, _DiagramElementCollec);

  function EquationNavigator(shapes, animateNextFrame, equation, offset) {
    var _this;

    var navType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'threeLine';
    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';
    var xAlign = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'left';
    var vAlign = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'middle';
    var id = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : Object(_tools_tools__WEBPACK_IMPORTED_MODULE_5__["generateUniqueId"])('id_lesson__equation_navigator_');

    _classCallCheck(this, EquationNavigator);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(EquationNavigator).call(this, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Eqn Nav').scale(1, 1).translate(0, 0), shapes.limits));
    _this.shapes = shapes;

    _this.setEquation(equation);

    _this.prev = null;
    _this.next = null;
    _this.refresh = null;
    _this.description = null;
    _this.nextDescription = null;
    _this.prevDescription = null;
    _this.table = null;
    _this.prevGroup = null;
    _this.currentGroup = null;
    _this.nextGroup = null;
    _this.animateNextFrame = animateNextFrame;
    _this.navType = navType;
    var navigatorHTMLElement = null;

    if (_this.navType === 'threeLine') {
      navigatorHTMLElement = makeType3Line(_this.clickPrev.bind(_assertThisInitialized(_assertThisInitialized(_this))), _this.clickRefresh.bind(_assertThisInitialized(_assertThisInitialized(_this))), _this.clickNext.bind(_assertThisInitialized(_assertThisInitialized(_this))), options);
    }

    if (_this.navType === 'descriptionOnly') {
      navigatorHTMLElement = makeTypeDescriptionOnly(_this.clickNext.bind(_assertThisInitialized(_assertThisInitialized(_this))));
    }

    if (_this.navType === 'oneLine') {
      navigatorHTMLElement = makeType1Line(_this.clickPrev.bind(_assertThisInitialized(_assertThisInitialized(_this))), _this.clickRefresh.bind(_assertThisInitialized(_assertThisInitialized(_this))), _this.clickNext.bind(_assertThisInitialized(_assertThisInitialized(_this))), options);
    }

    if (_this.navType === 'twoLine') {
      navigatorHTMLElement = makeType2Line(_this.clickPrev.bind(_assertThisInitialized(_assertThisInitialized(_this))), _this.clickRefresh.bind(_assertThisInitialized(_assertThisInitialized(_this))), _this.clickNext.bind(_assertThisInitialized(_assertThisInitialized(_this))), options);
    }

    var eqnCollectionPosition = _this.eqn.collection.getPosition();

    if (navigatorHTMLElement != null) {
      Object.assign(_assertThisInitialized(_assertThisInitialized(_this)), navigatorHTMLElement);

      var table = _this.shapes.htmlElement(navigatorHTMLElement.table, "".concat(id, "_table"), '', eqnCollectionPosition.add(offset), vAlign, xAlign);

      _this.add('table', table);
    }

    _this.eqn.collection.onClick = _this.clickNext.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.hasTouchableElements = true;
    _this.eqn.collection.isTouchable = true;
    _this.eqn.collection.touchInBoundingRect = true;
    return _this;
  } // const navigator = shapes.collection(;


  _createClass(EquationNavigator, [{
    key: "setEquation",
    value: function setEquation(eqn) {
      this.eqn = eqn; // this._eqn = [];

      this.add('eqn', eqn.collection);
    }
  }, {
    key: "clickNext",
    value: function clickNext() {
      this.eqn.nextForm(1.5);
      this.updateButtons();
      this.animateNextFrame();
    }
  }, {
    key: "clickPrev",
    value: function clickPrev() {
      this.eqn.prevForm(1.5);
      this.updateButtons();
      this.animateNextFrame();
    }
  }, {
    key: "clickRefresh",
    value: function clickRefresh() {
      var currentForm = this.eqn.getCurrentForm();

      if (currentForm != null) {
        var index = this.eqn.getFormIndex(currentForm);

        if (index > 0) {
          this.eqn.replayCurrentForm(1.5);
          this.animateNextFrame();
        }
      }

      this.updateButtons();
    }
  }, {
    key: "updateButtons",
    value: function updateButtons() {
      if (this.navType === 'equationOnly') {
        return;
      }

      if (this.navType === 'descriptionOnly') {
        updateButtonsDescriptionOnly(this);
      } else if (this.navType === 'twoLine') {
        _updateButtons(this, true);
      } else {
        _updateButtons(this);
      }
    }
  }, {
    key: "showForm",
    value: function showForm(formOrName) {
      var formType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.show();
      this.eqn.showForm(formOrName, formType);

      if (this._table) {
        this._table.show();

        this.updateButtons();
      }
    }
  }]);

  return EquationNavigator;
}(_Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementCollection"]);



/***/ }),

/***/ "./src/js/diagram/DiagramObjects/Line.js":
/*!***********************************************!*\
  !*** ./src/js/diagram/DiagramObjects/Line.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DiagramObjectLine; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _EquationLabel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EquationLabel */ "./src/js/diagram/DiagramObjects/EquationLabel.js");
/* harmony import */ var _DiagramElements_Equation_GLEquation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../DiagramElements/Equation/GLEquation */ "./src/js/diagram/DiagramElements/Equation/GLEquation.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import Diagram from '../Diagram';




 // top - text is on top of line (except when line is vertical)
// bottom - text is on bottom of line (except when line is vertical)
// left - text is to left of line (except when line is horiztonal)
// right - text is to right of line (except when line is horiztonal)
// end1 - text is on first end of line
// end2 - text is on second end of line
// outside - text is on left of line when line is vertical from 0 to 1
//           or, if a polygon is defined clockwise, outside will be outside.
// inside - text is on right of line when line is vertical from 0 to 1
//           or, if a polygon is defined anti-clockwise, outside will be outside.

// Line is a class that manages:
//   A straight line
//   Arrows
//   Label
//   Future: Dimension posts
//
// In vertex space, a line is defined as:
//   - horizontal
//   - length 1
//   - width defined by user
//   - left side (start) of line defined at a point by user
//
// To give the line a custom position, length and angle, the main
// class's transform is used:
//   - Translation for vertex space origin position
//   - Scale for line length
//   - Rotation for line angle
//
// In vertex space, a line would normally be positioned along the x axis.
//
//
// A line can be defined in three ways:
//   - p1, p2, width, vertexSpaceStart
//      - width and vertexSpaceStart used to calculate vertex line
//      - p1, p2 used to calculate length, angle, position
//      - length, angle, position used to modify transform
//   - Length, angle, width, vertexSpaceStart, position of vertexSpaceOrigin
//      - width and vertexSpaceStart used to calculate vertex line
//      - Length, angle, position used to modify transform
//   - p1, length, angle, width, vertexSpaceStart
//      - width and vertexSpaceStart used to calculate vertex line
//      - p1 used to calculate position
//      - length, angle, position used to modify transform
var LineLabel =
/*#__PURE__*/
function (_EquationLabel) {
  _inherits(LineLabel, _EquationLabel);

  function LineLabel(equation, labelText, color, offset) {
    var _this;

    var location = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'top';
    var subLocation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'left';
    var orientation = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'horizontal';
    var linePosition = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0.5;
    var scale = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0.7;

    _classCallCheck(this, LineLabel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(LineLabel).call(this, equation, {
      label: labelText,
      color: color,
      scale: scale
    }));
    _this.offset = offset;
    _this.location = location;
    _this.subLocation = subLocation;
    _this.orientation = orientation;
    _this.linePosition = linePosition;
    return _this;
  }

  return LineLabel;
}(_EquationLabel__WEBPACK_IMPORTED_MODULE_3__["default"]);

function makeStraightLine(shapes, length, width, position, color, dashStyle, largerTouchBorder, isTouchDevice) {
  var straightLine = shapes.horizontalLine(position, length, width, 0, color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).translate(0, 0));

  if (dashStyle) {
    straightLine = shapes.dashedLine(position, dashStyle.maxLength, width, 0, dashStyle.style, color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).translate(0, 0));
  }

  if (largerTouchBorder) {
    var multiplier = isTouchDevice ? 16 : 8;

    var increaseBorderSize = function increaseBorderSize(element) {
      for (var i = 0; i < element.drawingObject.border[0].length; i += 1) {
        // eslint-disable-next-line no-param-reassign
        element.drawingObject.border[0][i].y *= multiplier;
      }
    };

    increaseBorderSize(straightLine);
  }

  return straightLine;
} // export type TypeLine = {
//   _line: DiagramElementPrimative;
//   currentLength: number;
//   setLength: (number) => void;
//   setEndPoints: (Point, Point, number) => void;
//   animateLengthTo: (number, number, boolean, ?() => void) => void;
//   grow: (number, number, boolean, ?() => void) => void;
//   reference: 'center' | 'end';
//   showRealLength: boolean;
//   label: ?LineLabel;
//   _label: DiagramElementCollection;
//   arrow1: null | {
//     height: number;
//   };
//   arrow2: null | {
//     height: number;
//   };
//   setMovable: (?boolean) => void;
//   addArrow1: (number, number) => void;
//   addArrow2: (number, number) => void;
//   addLabel: (string, number, TypeLineLabelLocation,
//              TypeLineLabelSubLocation, TypeLineLabelOrientation, number
//             ) => void;
//   setEndPoints: (Point, Point, ?number) => void;
//   animateLengthTo: (number, number, boolean, ?() => void) => void;
//   grow: (number, number, boolean, ?() => void) => void;
//   pulseWidth: () => void;
//   updateLabel: (?number) => {};
//   offset: number;
// } & DiagramElementCollection;
// A line is always defined as horiztonal with length 1 in vertex space
// The line's position and rotation is the line collection transform
// translation and rotation respectively.
// The line's length is the _line primative x scale.


var DiagramObjectLine =
/*#__PURE__*/
function (_DiagramElementCollec) {
  _inherits(DiagramObjectLine, _DiagramElementCollec);

  _createClass(DiagramObjectLine, [{
    key: "calculateFromP1LengthAngle",
    // Diagram elements
    // label and arrow objects that exist if labels and arrows exist
    // line properties - read only
    // deprecate
    // line properties - read/write
    // line properties - private internal use only
    // line methods
    value: function calculateFromP1LengthAngle(p1, length, angle) {
      var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(length, 1).rotate(angle);
      var startTransformed = this.vertexSpaceStart.transformBy(t.matrix());
      var position = p1.sub(startTransformed);
      return {
        length: length,
        angle: angle,
        position: position
      };
    }
  }, {
    key: "calculateFromP1P2",
    value: function calculateFromP1P2(p1, p2) {
      var line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, p2);
      var length = line.length();
      var angle = line.angle();
      var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(length, 1).rotate(angle);
      var startTransformed = this.vertexSpaceStart.transformBy(t.matrix());
      var position = p1.sub(startTransformed);
      return {
        length: length,
        angle: angle,
        position: position
      };
    }
  }]);

  function DiagramObjectLine(shapes, equation, isTouchDevice, animateNextFrame) {
    var _this2;

    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    _classCallCheck(this, DiagramObjectLine);

    var defaultOptions = {
      position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      length: 1,
      angle: 0,
      width: 0.01,
      vertexSpaceStart: 'start',
      color: [0, 0, 1, 1],
      showLine: true,
      largerTouchBorder: true,
      offset: 0,
      dashStyle: null,
      mods: {}
    };
    var optionsToUse = Object.assign({}, defaultOptions, options);
    var dashStyle = optionsToUse.dashStyle;

    if (dashStyle) {
      var defaultMaxLength = optionsToUse.length;

      if (optionsToUse.p1 != null && optionsToUse.p2 != null) {
        defaultMaxLength = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["distance"])(optionsToUse.p1, optionsToUse.p2);
      }

      dashStyle = Object.assign({}, {
        maxLength: defaultMaxLength,
        dashStyle: [0.1]
      }, options.dashStyle);
    }

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(DiagramObjectLine).call(this, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Line').scale(1, 1).rotate(0).translate(0, 0), shapes.limits));

    _this2.setColor(optionsToUse.color);

    _this2.shapes = shapes;
    _this2.equation = equation;
    _this2.largerTouchBorder = optionsToUse.largerTouchBorder;
    _this2.isTouchDevice = isTouchDevice;
    _this2.animateNextFrame = animateNextFrame;
    _this2.dashStyle = dashStyle; // Calculate and store the line geometry
    //    The length, angle, p1 and p2 properties also exist in this.line,
    //    but are at this level for convenience

    _this2.offset = optionsToUse.offset;
    _this2.width = optionsToUse.width;
    _this2.position = optionsToUse.position;
    _this2.length = optionsToUse.length;
    _this2.angle = optionsToUse.angle;

    _this2.transform.updateTranslation(_this2.position);

    _this2.transform.updateRotation(_this2.angle); // Line is defined in vertex space as horiztonal along the x axis.
    // The reference will define how it is offset where:
    //    - start: line extends from 0 to length in x
    //    - end: line extends from -length to 0 in length
    //    - middle: line extends from -length / 2 to length / 2
    //    - percent: line extends from -length * % to length * (1 - %)


    _this2.vertexSpaceLength = 1;
    _this2.vertexSpaceStart = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

    if (optionsToUse.vertexSpaceStart === 'end') {
      _this2.vertexSpaceStart = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-1, 0);
    } else if (optionsToUse.vertexSpaceStart === 'center') {
      _this2.vertexSpaceStart = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-0.5, 0);
    } else if (typeof optionsToUse.vertexSpaceStart === 'number') {
      _this2.vertexSpaceStart = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-optionsToUse.vertexSpaceStart, 0);
    } else if (optionsToUse.vertexSpaceStart instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
      _this2.vertexSpaceStart = optionsToUse.vertexSpaceStart;
    } // this.vertexOrigin = vertexOrigin;
    // MultiMove means the line has a middle section that when touched
    // translates the line collection, and when the rest of the line is
    // touched then the line collection is rotated.


    _this2.multiMove = {
      vertexSpaceMidLength: 0,
      bounds: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2)
    };
    _this2._midLine = null; // If the line is to be shown (and not just a label) then make it

    _this2._line = null;

    if (optionsToUse.showLine) {
      // let dashStyleToUse = optionsToUse.dashStyle;
      // if (dashStyleToUse == null) {  // If undefined, make null
      //   dashStyleToUse = null;
      // }
      var straightLine = makeStraightLine(_this2.shapes, _this2.vertexSpaceLength, _this2.width, _this2.vertexSpaceStart, optionsToUse.color, _this2.dashStyle, optionsToUse.largerTouchBorder, isTouchDevice);

      _this2.add('line', straightLine);
    } // Arrow related properties


    _this2.arrow1 = null;
    _this2.arrow2 = null;
    _this2._arrow1 = null;
    _this2._arrow2 = null; // Label related properties

    _this2.label = null;
    _this2._label = null;
    _this2.showRealLength = false;

    _this2.setLength(_this2.length);

    if (optionsToUse.p1 != null && optionsToUse.p2 != null) {
      _this2.setEndPoints(optionsToUse.p1, optionsToUse.p2);
    }

    var defaultArrowOptions = {
      width: _this2.width * 4,
      height: _this2.width * 4
    };

    if (optionsToUse.arrowStart) {
      var arrowOptions = Object.assign({}, defaultArrowOptions, optionsToUse.arrowStart);

      _this2.addArrowStart(arrowOptions.height, arrowOptions.width);
    }

    if (optionsToUse.arrowEnd) {
      var _arrowOptions = Object.assign({}, defaultArrowOptions, optionsToUse.arrowEnd);

      _this2.addArrowEnd(_arrowOptions.height, _arrowOptions.width);
    } // Arrows overrides arrowStart or arrowEnd


    if (optionsToUse.arrows) {
      var arrows = {};

      if (_typeof(optionsToUse.arrows) === 'object') {
        arrows = optionsToUse.arrows;
      }

      var _arrowOptions2 = Object.assign({}, defaultArrowOptions, arrows);

      _this2.addArrows(_arrowOptions2.height, _arrowOptions2.width);
    }

    var defaultLabelOptions = {
      text: null,
      offset: 0,
      location: 'top',
      subLocation: 'left',
      orientation: 'horizontal',
      linePosition: 0.5,
      scale: 0.7,
      color: optionsToUse.color
    };

    if (optionsToUse.label) {
      var labelOptions = Object.assign({}, defaultLabelOptions, optionsToUse.label);

      if (labelOptions.text === null) {
        labelOptions.text = '';
        _this2.showRealLength = true;
      }

      _this2.addLabel(labelOptions.text, labelOptions.offset, labelOptions.location, labelOptions.subLocation, labelOptions.orientation, labelOptions.linePosition, labelOptions.scale, labelOptions.color);
    }

    if (optionsToUse.mods != null && optionsToUse.mods !== {}) {
      _this2.setProperties(optionsToUse.mods);
    }

    return _this2;
  }

  _createClass(DiagramObjectLine, [{
    key: "pulseWidth",
    value: function pulseWidth() {
      var line = this._line;

      if (line != null) {
        line.stopPulsing();
        var oldTransformMethod = line.pulse.transformMethod;
        var oldPulseCallback = line.pulse.callback;

        var finishPulsing = function finishPulsing() {
          line.pulse.transformMethod = oldTransformMethod;
          line.pulse.callback = oldPulseCallback;
        };

        line.pulse.callback = finishPulsing;

        line.pulse.transformMethod = function (s) {
          return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, s);
        };

        line.pulseScaleNow(1, 3);
      }

      var arrow1 = this._arrow1;
      var arrow2 = this._arrow2;

      if (arrow1 != null) {
        arrow1.pulseScaleNow(1, 2);
      }

      if (arrow2 != null) {
        arrow2.pulseScaleNow(1, 2);
      }

      var label = this._label;

      if (label != null) {
        label.pulseScaleNow(1, 1.5);
      }

      this.animateNextFrame();
    }
  }, {
    key: "addArrow",
    value: function addArrow(index) {
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.width * 4;
      var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : height;
      var r = Math.PI / 2;

      if (index === 2) {
        r = Math.PI / 2 * 3;
      }

      var a = this.shapes.arrowLegacy(width, 0, height, 0, this.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(this.vertexSpaceStart.x, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), r); // $FlowFixMe

      this["arrow".concat(index)] = {
        height: height
      };
      this.add("arrow".concat(index), a);
      this.setLength(this.currentLength);
    }
  }, {
    key: "addArrows",
    value: function addArrows() {
      var arrowHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.width * 4;
      var arrowWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arrowHeight;
      this.addArrow1(arrowHeight, arrowWidth);
      this.addArrow2(arrowHeight, arrowWidth);
    }
  }, {
    key: "addArrow1",
    value: function addArrow1() {
      var arrowHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.width * 4;
      var arrowWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arrowHeight;
      this.addArrow(1, arrowHeight, arrowWidth);
    }
  }, {
    key: "addArrow2",
    value: function addArrow2() {
      var arrowHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.width * 4;
      var arrowWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arrowHeight;
      this.addArrow(2, arrowHeight, arrowWidth);
    }
  }, {
    key: "addArrowStart",
    value: function addArrowStart() {
      var arrowHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.width * 4;
      var arrowWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arrowHeight;
      this.addArrow1(arrowHeight, arrowWidth);
    }
  }, {
    key: "addArrowEnd",
    value: function addArrowEnd() {
      var arrowHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.width * 4;
      var arrowWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arrowHeight;
      this.addArrow2(arrowHeight, arrowWidth);
    }
  }, {
    key: "setMovable",
    value: function setMovable() {
      var movable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var moveType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.move.type;
      var middleLengthPercent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.333;
      var translationBounds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.diagramLimits;

      if (movable) {
        if (moveType === 'translation' || moveType === 'rotation' || moveType === 'scale' || moveType === 'scaleX' || moveType === 'scaleY') {
          this.move.type = moveType;
          this.isTouchable = true;
          this.isMovable = true;
          this.hasTouchableElements = true;

          if (this._line != null) {
            this._line.isTouchable = true;
            this._line.isMovable = false;
          }

          if (this._midLine) {
            this._midLine.isMovable = false;
          }

          this.multiMove.bounds = translationBounds;
        } else {
          this.setMultiMovable(middleLengthPercent, translationBounds);
        }
      } else {
        this.isMovable = false;
      }
    }
  }, {
    key: "setMultiMovable",
    value: function setMultiMovable(middleLengthPercent, translationBounds) {
      this.multiMove.vertexSpaceMidLength = middleLengthPercent * this.vertexSpaceLength;
      var start = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.vertexSpaceStart.x + this.vertexSpaceLength / 2 - this.multiMove.vertexSpaceMidLength / 2, 0);
      var midLine = makeStraightLine(this.shapes, this.multiMove.vertexSpaceMidLength, this.width, start, this.color, null, this.largerTouchBorder, this.isTouchDevice); // console.log(midLine)

      midLine.isTouchable = true;
      midLine.move.type = 'translation';
      midLine.move.element = this;
      midLine.isMovable = true;
      midLine.move.canBeMovedAfterLoosingTouch = true;
      this.add('midLine', midLine);

      if (this._line) {
        this._line.isTouchable = true;
        this._line.move.type = 'rotation';
        this._line.move.element = this;
        this._line.isMovable = true;
        this._line.move.canBeMovedAfterLoosingTouch = true;
      }

      this.hasTouchableElements = true;
      this.isTouchable = false;
      this.isMovable = false;
      this.multiMove.bounds = translationBounds;
      this.setLength(this.currentLength);
    }
  }, {
    key: "updateMoveTransform",
    value: function updateMoveTransform(t) {
      var r = t.r();
      var bounds = this.multiMove.bounds;

      if (r != null) {
        var w = Math.abs(this.currentLength / 2 * Math.cos(r));
        var h = Math.abs(this.currentLength / 2 * Math.sin(r));
        this.move.maxTransform.updateTranslation(bounds.right - w, bounds.top - h);
        this.move.minTransform.updateTranslation(bounds.left + w, bounds.bottom + h);

        if (r > 2 * Math.PI) {
          this.transform.updateRotation(r - 2 * Math.PI);
        }

        if (r < 0) {
          this.transform.updateRotation(r + 2 * Math.PI);
        }
      }
    }
  }, {
    key: "addLabel",
    value: function addLabel(labelText, offset) {
      var location = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'top';
      var subLocation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'left';
      var orientation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'horizontal';
      var linePosition = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.5;
      var scale = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0.7;
      var color = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : this.color;
      this.label = new LineLabel(this.equation, labelText, color, offset, location, subLocation, orientation, linePosition, scale);

      if (this.label != null) {
        this.add('label', this.label.eqn.collection);
      }

      this.updateLabel();
    }
  }, {
    key: "updateLabel",
    value: function updateLabel() {
      var parentRotationOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var label = this.label;

      if (label == null) {
        return;
      }

      var lineAngle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["normAngle"])(this.transform.r() || 0);
      var labelAngle = 0;

      if (this.showRealLength && this._label) {
        this._label._base.drawingObject.setText(Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(this.currentLength, 2).toString());

        label.eqn.reArrangeCurrentForm();
      }

      var labelPosition = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.vertexSpaceStart.x * this.currentLength + label.linePosition * this.currentLength, 0);
      var labelOffsetAngle = Math.PI / 2;
      var labelOffsetMag = label.offset;

      if (label.location === 'end1' || label.location === 'end2') {
        if (label.location === 'end1') {
          labelPosition.x = this.vertexSpaceStart.x * this.currentLength - label.offset;
          labelOffsetAngle = -Math.PI;
        }

        if (label.location === 'end2') {
          labelPosition.x = this.vertexSpaceStart.x * this.currentLength + this.currentLength + label.offset;
          labelOffsetAngle = 0;
        }
      } else {
        var offsetTop = Math.cos(lineAngle) < 0 ? -Math.PI / 2 : Math.PI / 2;
        var offsetBottom = -offsetTop;
        var offsetLeft = Math.sin(lineAngle) > 0 ? Math.PI / 2 : -Math.PI / 2;
        var offsetRight = -offsetLeft;

        if (label.location === 'top') {
          labelOffsetAngle = offsetTop;
        }

        if (label.location === 'bottom') {
          labelOffsetAngle = offsetBottom;
        }

        if (label.location === 'right') {
          labelOffsetAngle = offsetRight;
        }

        if (label.location === 'left') {
          labelOffsetAngle = offsetLeft;
        }

        if (Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(Math.sin(lineAngle), 4) === 0 && (label.location === 'left' || label.location === 'right')) {
          if (label.subLocation === 'top') {
            labelOffsetAngle = offsetTop;
          }

          if (label.subLocation === 'bottom') {
            labelOffsetAngle = offsetBottom;
          }
        }

        if (Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(Math.cos(lineAngle), 4) === 0 && (label.location === 'top' || label.location === 'bottom')) {
          if (label.subLocation === 'right') {
            labelOffsetAngle = offsetRight;
          }

          if (label.subLocation === 'left') {
            labelOffsetAngle = offsetLeft;
          }
        }

        if (label.location === 'inside') {
          labelOffsetAngle = -Math.PI / 2;
        }

        if (label.location === 'outside') {
          labelOffsetAngle = Math.PI / 2;
        }
      }

      if (label.orientation === 'horizontal') {
        labelAngle = -lineAngle;
      }

      if (label.orientation === 'baseToLine') {
        if (labelPosition.y < 0) {
          labelAngle = Math.PI;
        }
      }

      if (label.orientation === 'baseAway') {
        if (labelPosition.y > 0) {
          labelAngle = Math.PI;
        }
      }

      if (label.orientation === 'baseUpright') {
        if (Math.cos(lineAngle) < 0) {
          labelAngle = Math.PI;
        }
      }

      label.updateRotation(labelAngle - parentRotationOffset, labelPosition, labelOffsetMag, labelOffsetAngle);
    }
  }, {
    key: "setLength",
    value: function setLength(newLength) {
      var lineStart = this.vertexSpaceStart.x * newLength;
      var lineLength = newLength;
      var straightLineLength = lineLength;
      var startOffset = 0;

      if (this.arrow1 && this._arrow1) {
        straightLineLength -= this.arrow1.height;
        startOffset = this.arrow1.height;

        this._arrow1.setPosition(lineStart);
      }

      if (this.arrow2 && this._arrow2) {
        straightLineLength -= this.arrow2.height;

        this._arrow2.setPosition(lineStart + lineLength, 0);
      }

      var line = this._line;

      if (line) {
        if (this.dashStyle) {
          line.lengthToDraw = straightLineLength; // const newStart = this.vertexSpaceStart.x * straightLineLength;
          // const delta = lineStart + startOffset - newStart;

          line.setPosition(lineStart + startOffset - this.vertexSpaceStart.x, 0);
        } else {
          line.transform.updateScale(straightLineLength, 1);
          var newStart = this.vertexSpaceStart.x * straightLineLength;
          var delta = lineStart + startOffset - newStart;
          line.setPosition(delta, 0);
        }
      }

      var midLine = this._midLine;

      if (midLine) {
        midLine.transform.updateScale(newLength, 1);
      }

      this.length = newLength;
      this.updateLineGeometry();
      this.currentLength = newLength; // to deprecate?

      this.updateLabel();
    }
  }, {
    key: "updateLineGeometry",
    value: function updateLineGeometry() {
      var t = this.transform.t();
      var r = this.transform.r();

      if (t != null && r != null) {
        this.position = t;
        this.angle = r;
        var p1 = this.vertexSpaceStart.transformBy(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(this.length).rotate(this.angle).translate(this.position).m());
        var line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, this.length, this.angle);
        this.p1 = line.getPoint(1);
        this.p2 = line.getPoint(2);
        this.line = line;
      }
    }
  }, {
    key: "setLineDimensions",
    value: function setLineDimensions() {
      var offset = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(this.offset, this.angle + Math.PI / 2);
      this.transform.updateTranslation(this.position.add(offset));
      this.transform.updateRotation(this.angle);
      this.setLength(this.length);
      this.updateLabel();
    }
  }, {
    key: "setEndPoints",
    value: function setEndPoints(p, q) {
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.offset;
      this.offset = offset;

      var _this$calculateFromP = this.calculateFromP1P2(p, q),
          length = _this$calculateFromP.length,
          angle = _this$calculateFromP.angle,
          position = _this$calculateFromP.position;

      this.angle = angle;
      this.length = length;
      this.position = position;
      this.setLineDimensions(); // const pq = new Line(p, q);
      // this.angle = pq.angle();
      // this.length = pq.length();
      // this.position = p;
      // if (this.vertexOrigin === 'center') {
      //   this.position = pq.midpoint();
      // } else if (this.vertexOrigin === 'end') {
      //   this.position = q;
      // } else if (typeof this.vertexOrigin === 'number') {
      //   this.position = p.add(polarToRect(this.vertexOrigin * this.length, this.angle));
      // } else if (this.vertexOrigin instanceof Point) {
      //   this.position = p.add(this.vertexOrigin);
      // }
      // // this.updateLineGeometry();
      // // const newLength = distance(q, p);
      // // const pq = new Line(p, q);
      // this.transform.updateRotation(pq.angle());
      // const offsetdelta = polarToRect(offset, pq.angle() + Math.PI / 2);
      // // if (this.reference === 'center') {
      // this.transform.updateTranslation(this.position.add(offsetdelta));
      // // } else {
      // //   this.transform.updateTranslation(p.add(offsetdelta));
      // // }
      // this.setLength(this.length);
      // this.updateLabel();
    }
  }, {
    key: "animateLengthTo",
    value: function animateLengthTo() {
      var _this3 = this;

      var toLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var finishOnCancel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      this.stop();
      var initialLength = this.currentLength;
      var deltaLength = toLength - this.currentLength;

      var func = function func(percent) {
        _this3.setLength(initialLength + deltaLength * percent);
      };

      var done = function done() {
        if (finishOnCancel) {
          _this3.setLength(initialLength + deltaLength);
        }

        if (typeof callback === 'function' && callback) {
          callback();
        }
      };

      this.animations.new('Line Length').custom({
        callback: func,
        duration: time
      }).whenFinished(done).start(); // this.animations.start();

      this.animateNextFrame(); // console.log(this)
      // this.animateCustomTo(func, time, 0, done);
    }
  }, {
    key: "grow",
    value: function grow() {
      var fromLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var finishOnCancel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      this.stop();
      var target = this.currentLength;
      this.setLength(fromLength);
      this.animateLengthTo(target, time, finishOnCancel, callback);
    }
  }, {
    key: "showLineOnly",
    value: function showLineOnly() {
      this.show();

      if (this._line) {
        this._line.show();
      }

      if (this._arrow1) {
        this._arrow1.show();
      }

      if (this._arrow2) {
        this._arrow2.show();
      }

      if (this._label) {
        this._label.hideAll();
      }
    }
  }]);

  return DiagramObjectLine;
}(_Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"]); // export type TypeLine = DiagramObjectLine;
// export class MovableLine extends DiagramObjectLine {
//   // constructor(
//   //   fullLength: number,
//   //   endLength: number,
//   //   width: number,
//   //   boundary: Rect,
//   // ) {
//   // }
// }
// export type TypeMovableLine = MovableLine;




/***/ }),

/***/ "./src/js/diagram/DiagramObjects/PolyLine.js":
/*!***************************************************!*\
  !*** ./src/js/diagram/DiagramObjects/PolyLine.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DiagramObjectPolyLine; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _DiagramPrimatives_DiagramPrimatives__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DiagramPrimatives/DiagramPrimatives */ "./src/js/diagram/DiagramPrimatives/DiagramPrimatives.js");
/* harmony import */ var _DiagramObjects__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DiagramObjects */ "./src/js/diagram/DiagramObjects/DiagramObjects.js");
/* harmony import */ var _DiagramEquation_DiagramEquation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../DiagramEquation/DiagramEquation */ "./src/js/diagram/DiagramEquation/DiagramEquation.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }








function makeArray(possibleArray, count) {
  if (Array.isArray(possibleArray)) {
    if (count === possibleArray.length) {
      return possibleArray;
    }

    var _outArray = [];

    for (var i = 0; i < count; i += 1) {
      _outArray.push(possibleArray[i % possibleArray.length]);
    }

    return _outArray;
  }

  var outArray = [];

  for (var _i = 0; _i < count; _i += 1) {
    outArray.push(possibleArray);
  }

  return outArray;
} // function makeColorArray(
//   possibleArray: Array<Array<number> | number>,
//   count: number,
// ): Array<Array<number>> {
//   if (Array.isArray(possibleArray[0])) {
//     if (count === possibleArray.length) {                   // $FlowFixMe
//       return possibleArray;
//     }
//     const outArray = [];
//     for (let i = 0; i < count; i += 1) {                    // $FlowFixMe
//       outArray.push(possibleArray[i % possibleArray.length].slice());
//     }
//     return outArray;
//   }
//   const outArray = [];
//   for (let i = 0; i < count; i += 1) {
//     outArray.push(possibleArray.slice());
//   }                                                         // $FlowFixMe
//   return outArray;
// }


var DiagramObjectPolyLine =
/*#__PURE__*/
function (_DiagramElementCollec) {
  _inherits(DiagramObjectPolyLine, _DiagramElementCollec);

  function DiagramObjectPolyLine(shapes, equation, objects, isTouchDevice, animateNextFrame) {
    var _this;

    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

    _classCallCheck(this, DiagramObjectPolyLine);

    var defaultOptions = {
      position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      color: [0, 1, 0, 1],
      points: [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 1)],
      close: false,
      showLine: true,
      borderToPoint: 'never',
      width: 0.01
    };
    var defaultSideOptions = {
      showLine: false,
      offset: 0,
      width: 0.01,
      color: options.color == null ? [0, 1, 0, 1] : options.color
    };
    var defaultSideLabelOptions = {
      offset: 0.1,
      text: null,
      location: 'outside',
      subLocation: 'top',
      orientation: 'horizontal',
      linePosition: 0.5,
      scale: 0.7
    };
    var defaultAngleOptions = {
      color: options.color == null ? [0, 1, 0, 1] : options.color,
      curve: {},
      autoRightAngle: true
    };
    var defaultAngleLabelOptions = {
      text: null
    };
    var defaultPadOptions = {
      sides: 20,
      radius: 0.1,
      color: options.color == null ? [0, 1, 0, 1] : options.color,
      fill: true,
      isMovable: false
    };

    if (options.side != null) {
      defaultOptions.side = defaultSideOptions; // $FlowFixMe

      if (options.side.label != null) {
        defaultOptions.side.label = defaultSideLabelOptions;
      }
    }

    if (options.angle != null) {
      defaultOptions.angle = defaultAngleOptions; // $FlowFixMe

      if (options.angle.label != null) {
        defaultOptions.angle.label = defaultAngleLabelOptions;
      }
    }

    if (options.pad != null) {
      defaultOptions.pad = defaultPadOptions;
    }

    var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, options);

    if (Array.isArray(options.side)) {
      // $FlowFixMe
      optionsToUse.side = options.side.map(function (side) {
        return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions.side, side);
      });
    }

    if (Array.isArray(options.angle)) {
      // $FlowFixMe
      optionsToUse.angle = options.angle.map(function (angle) {
        return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions.angle, angle);
      });
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DiagramObjectPolyLine).call(this, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('PolyLine').scale(1, 1).rotate(0).translate(0, 0), shapes.limits));

    _this.setColor(optionsToUse.color);

    _this.shapes = shapes;
    _this.equation = equation;
    _this.objects = objects;
    _this.largerTouchBorder = optionsToUse.largerTouchBorder;
    _this.isTouchDevice = isTouchDevice;
    _this.animateNextFrame = animateNextFrame;
    _this.position = optionsToUse.position;

    _this.transform.updateTranslation(_this.position);

    _this.close = optionsToUse.close;
    _this.options = optionsToUse;
    _this.points = optionsToUse.points; // Add Pads

    if (optionsToUse.pad) {
      var pad = optionsToUse.pad;
      var pCount = optionsToUse.points.length;
      var padArray = makeArray(pad, pCount);

      var _loop = function _loop(i) {
        var name = "pad".concat(i);
        var padOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
          transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(optionsToUse.points[i])
        }, padArray[i]);

        var padShape = _this.shapes.polygon(padOptions);

        if (padArray[i].isMovable) {
          padShape.isMovable = true;
          padShape.isTouchable = true;
          padShape.move.limitToDiagram = true;
          padShape.setMoveBoundaryToDiagram();

          padShape.setTransformCallback = function (transform) {
            var index = parseInt(padShape.name.slice(3), 10);
            var translation = transform.t();

            if (translation != null) {
              _this.points[index] = translation._dup();

              _this.updatePoints(_this.points);
            }
          };

          if (padArray[i].touchRadius != null) {
            var multiplier = padArray[i].touchRadius / padArray[i].radius;
            padShape.increaseBorderSize(multiplier);
          }
        }

        _this.add(name, padShape);
      };

      for (var i = 0; i < pCount; i += 1) {
        _loop(i);
      }
    } // Add Line


    if (optionsToUse.showLine) {
      var line = _this.shapes.polyLine({
        points: optionsToUse.points,
        color: optionsToUse.color,
        close: optionsToUse.close,
        borderToPoint: optionsToUse.borderToPoint,
        width: optionsToUse.width
      });

      _this.add('line', line);
    } // Add Sides


    if (optionsToUse.side) {
      var side = optionsToUse.side;

      var _pCount = optionsToUse.points.length - 1;

      if (optionsToUse.close) {
        _pCount += 1;
      }

      var sideArray = makeArray(side, _pCount);

      for (var i = 0; i < _pCount; i += 1) {
        var j = i + 1;

        if (i === _pCount - 1 && optionsToUse.close) {
          j = 0;
        }

        var name = "side".concat(i).concat(j);
        var sideOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
          p1: optionsToUse.points[i],
          p2: optionsToUse.points[j]
        }, sideArray[i]);

        var sideLine = _this.objects.line(sideOptions);

        _this.add(name, sideLine);
      }
    } // Add Angles


    if (optionsToUse.angle) {
      var angle = optionsToUse.angle;
      var _pCount2 = optionsToUse.points.length;

      if (optionsToUse.close === false) {
        _pCount2 -= 2;
      }

      var angleArray = makeArray(angle, _pCount2);
      var firstIndex = 0;

      if (optionsToUse.close === false) {
        firstIndex = 1;
      }

      for (var _i2 = firstIndex; _i2 < _pCount2 + firstIndex; _i2 += 1) {
        var _j = _i2 + 1;

        var k = _i2 - 1;

        if (_i2 === _pCount2 - 1 && optionsToUse.close) {
          _j = 0;
        }

        if (_i2 === 0 && optionsToUse.close) {
          k = _pCount2 - 1;
        }

        var _name = "angle".concat(_i2);

        var angleOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
          p1: optionsToUse.points[k],
          p2: optionsToUse.points[_i2],
          p3: optionsToUse.points[_j]
        }, angleArray[_i2]);

        var angleAnnotation = _this.objects.angle(angleOptions);

        _this.add(_name, angleAnnotation);
      }
    }

    return _this;
  }

  _createClass(DiagramObjectPolyLine, [{
    key: "updatePoints",
    value: function updatePoints(newPoints) {
      if (this._line != null) {
        this._line.drawingObject.change(newPoints);
      } // Add Pads


      var pCount = this.points.length;

      if (this.options.pad) {
        for (var i = 0; i < pCount; i += 1) {
          var name = "pad".concat(i);

          if (this.elements[name]) {
            // if (this.elements[name].isMovable === false) {
            this.elements[name].transform.updateTranslation(newPoints[i]); // }
          }
        }
      }

      if (this.options.side != null) {
        pCount = this.points.length - 1;

        if (this.close) {
          pCount += 1;
        }

        for (var _i3 = 0; _i3 < pCount; _i3 += 1) {
          var j = _i3 + 1;

          if (_i3 === pCount - 1 && this.close) {
            j = 0;
          }

          var _name2 = "side".concat(_i3).concat(j);

          if (this.elements[_name2] != null) {
            this.elements[_name2].setEndPoints(newPoints[_i3], newPoints[j]);
          }
        }
      }

      if (this.options.angle != null) {
        pCount = this.points.length;

        if (this.close === false) {
          pCount -= 2;
        }

        var firstIndex = 0;

        if (this.close === false) {
          firstIndex = 1;
        }

        for (var _i4 = firstIndex; _i4 < pCount + firstIndex; _i4 += 1) {
          var _j2 = _i4 + 1;

          var k = _i4 - 1;

          if (_i4 === pCount - 1 && this.close) {
            _j2 = 0;
          }

          if (_i4 === 0 && this.close) {
            k = pCount - 1;
          }

          var _name3 = "angle".concat(_i4);

          if (this.elements[_name3] != null) {
            this.elements[_name3].setAngle({
              p1: newPoints[k],
              p2: newPoints[_i4],
              p3: newPoints[_j2]
            });
          }
        }
      }

      this.points = newPoints;
    }
  }]);

  return DiagramObjectPolyLine;
}(_Element__WEBPACK_IMPORTED_MODULE_2__["DiagramElementCollection"]);



/***/ }),

/***/ "./src/js/diagram/DiagramPrimatives/DiagramPrimatives.js":
/*!***************************************************************!*\
  !*** ./src/js/diagram/DiagramPrimatives/DiagramPrimatives.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DiagramPrimatives; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/diagram/Element.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DrawContext2D */ "./src/js/diagram/DrawContext2D.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
/* harmony import */ var _DiagramElements_PolyLine__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../DiagramElements/PolyLine */ "./src/js/diagram/DiagramElements/PolyLine.js");
/* harmony import */ var _DiagramElements_Fan__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../DiagramElements/Fan */ "./src/js/diagram/DiagramElements/Fan.js");
/* harmony import */ var _DiagramElements_Polygon__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../DiagramElements/Polygon */ "./src/js/diagram/DiagramElements/Polygon.js");
/* harmony import */ var _DiagramElements_RadialLines__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../DiagramElements/RadialLines */ "./src/js/diagram/DiagramElements/RadialLines.js");
/* harmony import */ var _DiagramElements_HorizontalLine__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../DiagramElements/HorizontalLine */ "./src/js/diagram/DiagramElements/HorizontalLine.js");
/* harmony import */ var _DiagramElements_DashedLine__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../DiagramElements/DashedLine */ "./src/js/diagram/DiagramElements/DashedLine.js");
/* harmony import */ var _DiagramElements_RectangleFilled__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../DiagramElements/RectangleFilled */ "./src/js/diagram/DiagramElements/RectangleFilled.js");
/* harmony import */ var _DiagramElements_Lines__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../DiagramElements/Lines */ "./src/js/diagram/DiagramElements/Lines.js");
/* harmony import */ var _DiagramElements_Arrow__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../DiagramElements/Arrow */ "./src/js/diagram/DiagramElements/Arrow.js");
/* harmony import */ var _DiagramElements_Plot_AxisProperties__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../DiagramElements/Plot/AxisProperties */ "./src/js/diagram/DiagramElements/Plot/AxisProperties.js");
/* harmony import */ var _DiagramElements_Plot_Axis__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../DiagramElements/Plot/Axis */ "./src/js/diagram/DiagramElements/Plot/Axis.js");
/* harmony import */ var _DiagramElements_Text__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../DiagramElements/Text */ "./src/js/diagram/DiagramElements/Text.js");
/* harmony import */ var _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../DrawingObjects/TextObject/TextObject */ "./src/js/diagram/DrawingObjects/TextObject/TextObject.js");
/* harmony import */ var _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../DrawingObjects/HTMLObject/HTMLObject */ "./src/js/diagram/DrawingObjects/HTMLObject/HTMLObject.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }























var DiagramPrimatives =
/*#__PURE__*/
function () {
  function DiagramPrimatives(webgl, draw2D, // draw2DFigures: Object,
  htmlCanvas, limits, spaceTransforms, animateNextFrame) {
    _classCallCheck(this, DiagramPrimatives);

    this.webgl = webgl;
    this.draw2D = draw2D;
    this.htmlCanvas = htmlCanvas;
    this.limits = limits;
    this.animateNextFrame = animateNextFrame;
    this.spaceTransforms = spaceTransforms; // this.draw2DFigures = draw2DFigures;
  }

  _createClass(DiagramPrimatives, [{
    key: "polyLineLegacy",
    value: function polyLineLegacy(points, close, lineWidth, color) {
      var borderToPoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'never';
      var transform = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      return Object(_DiagramElements_PolyLine__WEBPACK_IMPORTED_MODULE_7__["PolyLine"])(this.webgl, points, close, lineWidth, color, borderToPoint, transform, this.limits);
    }
  }, {
    key: "polyLine",
    value: function polyLine() {
      var defaultOptions = {
        color: [1, 0, 0, 1],
        close: true,
        width: 0.01,
        borderToPoint: 'never',
        position: null,
        transform: null
      };

      for (var _len = arguments.length, options = new Array(_len), _key = 0; _key < _len; _key++) {
        options[_key] = arguments[_key];
      }

      var optionsToUse = Object.assign.apply(Object, [{}, defaultOptions].concat(options));
      var o = optionsToUse;
      var transform = o.transform;

      if (transform == null && o.position != null) {
        transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('polyLine').translate(o.position);
      } else if (transform == null) {
        transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('polyLine');
      }

      return Object(_DiagramElements_PolyLine__WEBPACK_IMPORTED_MODULE_7__["PolyLine"])(this.webgl, o.points, o.close, o.width, o.color, o.borderToPoint, transform, this.limits);
    }
  }, {
    key: "fan",
    value: function fan() {
      var defaultOptions = {
        points: [],
        color: [1, 0, 0, 1],
        transform: null,
        position: null
      };

      for (var _len2 = arguments.length, options = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        options[_key2] = arguments[_key2];
      }

      var optionsToUse = Object.assign.apply(Object, [{}, defaultOptions].concat(options));
      var o = optionsToUse;
      var transform = o.transform;

      if (transform == null && o.position != null) {
        transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('fan').translate(o.position);
      } else if (transform == null) {
        transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('fan');
      }

      return Object(_DiagramElements_Fan__WEBPACK_IMPORTED_MODULE_8__["default"])(this.webgl, o.points, o.color, transform, this.limits);
    } // fan(
    //   points: Array<Point>,
    //   color: Array<number>,
    //   transform: Transform | Point = new Transform(),
    // ) {
    //   return Fan(
    //     this.webgl, points,
    //     color, transform, this.limits,
    //   );
    // }

  }, {
    key: "textGL",
    value: function textGL(options) {
      return Object(_DiagramElements_Text__WEBPACK_IMPORTED_MODULE_18__["default"])(this.webgl, this.limits, options);
    }
  }, {
    key: "txt",
    value: function txt(textOrOptions) {
      var defaultOptions = {
        text: '',
        position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
        font: null,
        family: 'Times New Roman',
        style: 'italic',
        size: 0.2,
        weight: '200',
        hAlign: 'center',
        vAlign: 'middle',
        offset: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
        // vertex space offset
        color: [1, 0, 0, 1] // draw2D: this.draw2D,

      };
      var options;

      for (var _len3 = arguments.length, optionsIn = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        optionsIn[_key3 - 1] = arguments[_key3];
      }

      if (typeof textOrOptions === 'string') {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_5__["joinObjects"].apply(void 0, [{}, defaultOptions, {
          text: textOrOptions
        }].concat(optionsIn));
      } else {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_5__["joinObjects"].apply(void 0, [{}, defaultOptions, textOrOptions].concat(optionsIn));
      } // if (typeof options.draw2D === 'string') {
      //   if (options.draw2D in this.draw2DFigures) {
      //     options.draw2D = this.draw2DFigures[options.draw2D];
      //   }
      // }
      // const optionsToUse = joinObjects(defaultOptions, ...options);


      var o = options;
      var text = o.text;
      var fontToUse = o.font;

      if (fontToUse === null) {
        fontToUse = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_19__["DiagramFont"](o.family, o.style, o.size, o.weight, o.hAlign, o.vAlign, o.color);
      }

      var dT = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_19__["DiagramText"](o.offset, text, fontToUse);
      var to = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_19__["TextObject"](this.draw2D, [dT]);
      return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"](to, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).translate(o.position.x, o.position.y), o.color, this.limits);
    }
  }, {
    key: "arrow",
    value: function arrow() {
      var defaultOptions = {
        width: 1,
        legWidth: 1,
        height: 1,
        legHeight: 1,
        color: [1, 0, 0, 1],
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).rotate(0).translate(0, 0),
        tip: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
        rotation: 0
      };

      for (var _len4 = arguments.length, optionsIn = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        optionsIn[_key4] = arguments[_key4];
      }

      var o = _tools_tools__WEBPACK_IMPORTED_MODULE_5__["joinObjects"].apply(void 0, [defaultOptions].concat(optionsIn));
      return Object(_DiagramElements_Arrow__WEBPACK_IMPORTED_MODULE_15__["default"])(this.webgl, o.width, o.legWidth, o.height, o.legHeight, o.tip, o.rotation, o.color, o.transform, this.limits);
    }
  }, {
    key: "arrowLegacy",
    value: function arrowLegacy() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var legWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
      var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var legHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;
      var color = arguments.length > 4 ? arguments[4] : undefined;
      var transform = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      var tip = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var rotation = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      return Object(_DiagramElements_Arrow__WEBPACK_IMPORTED_MODULE_15__["default"])(this.webgl, width, legWidth, height, legHeight, tip, rotation, color, transform, this.limits);
    }
  }, {
    key: "text",
    value: function text(textInput, location, color) {
      var fontInput = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var font = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_19__["DiagramFont"]('Times New Roman', 'italic', 0.2, '200', 'center', 'middle', color);

      if (fontInput !== null) {
        font = fontInput;
      }

      var dT = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_19__["DiagramText"](new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), textInput, font);
      var to = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_19__["TextObject"](this.draw2D, [dT]);
      return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"](to, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).translate(location.x, location.y), color, this.limits);
    }
  }, {
    key: "htmlElement",
    value: function htmlElement(elementToAdd) {
      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "id__temp_".concat(Math.round(Math.random() * 10000));
      var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var location = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var alignV = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'middle';
      var alignH = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'left';
      var element = document.createElement('div');

      if (classes && element) {
        var classArray = classes.split(' ');
        classArray.forEach(function (c) {
          return element.classList.add(c.trim());
        });
      }

      if (Array.isArray(elementToAdd)) {
        elementToAdd.forEach(function (e) {
          return element.appendChild(e);
        });
      } else {
        element.appendChild(elementToAdd);
      }

      element.style.position = 'absolute';
      element.setAttribute('id', id);
      this.htmlCanvas.appendChild(element);
      var hT = new _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_20__["default"](this.htmlCanvas, id, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), alignV, alignH);
      var diagramElement = new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementPrimative"](hT, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).translate(location.x, location.y), [1, 1, 1, 1], this.limits); // console.log('html', diagramElement.transform.mat, location)
      // diagramElement.setFirstTransform();

      return diagramElement;
    }
  }, {
    key: "htmlText",
    value: function htmlText(textInput) {
      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object(_tools_tools__WEBPACK_IMPORTED_MODULE_5__["generateUniqueId"])('id__html_text_');
      var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var location = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var alignV = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'middle';
      var alignH = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'left';
      // const inside = document.createTextNode(textInput);
      var inside = document.createElement('div');
      inside.innerHTML = textInput;
      return this.htmlElement(inside, id, classes, location, alignV, alignH);
    }
  }, {
    key: "lines",
    value: function lines(linePairs) {
      var numLinesThick = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var color = arguments.length > 2 ? arguments[2] : undefined;
      var transform = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      return Object(_DiagramElements_Lines__WEBPACK_IMPORTED_MODULE_14__["default"])(this.webgl, linePairs, numLinesThick, color, transform, this.limits);
    }
  }, {
    key: "grid",
    value: function grid(bounds, xStep, yStep, numLinesThick, color) {
      var transform = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      var linePairs = []; // const xLimit = tools.roundNum(bounds.righ + xStep);

      if (xStep !== 0) {
        for (var x = bounds.left; _tools_math__WEBPACK_IMPORTED_MODULE_4__["roundNum"](x, 8) <= bounds.right; x += xStep) {
          linePairs.push([new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](x, bounds.top), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](x, bounds.bottom)]);
        }
      }

      if (yStep !== 0) {
        for (var y = bounds.bottom; _tools_math__WEBPACK_IMPORTED_MODULE_4__["roundNum"](y, 8) <= bounds.top; y += yStep) {
          linePairs.push([new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bounds.left, y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bounds.right, y)]);
        }
      }

      return this.lines(linePairs, numLinesThick, color, transform);
    }
  }, {
    key: "polyLineCorners",
    value: function polyLineCorners(points, close, cornerLength, lineWidth, color) {
      var transform = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      return Object(_DiagramElements_PolyLine__WEBPACK_IMPORTED_MODULE_7__["PolyLineCorners"])(this.webgl, points, close, cornerLength, lineWidth, color, transform, this.limits);
    } // polygon(
    //   numSides: number,
    //   radius: number,
    //   lineWidth: number,
    //   rotation: number,
    //   direction: -1 | 1,
    //   numSidesToDraw: number,
    //   color: Array<number>,
    //   transform: Transform | Point = new Transform(),
    // ) {
    //   return Polygon(
    //     this.webgl, numSides, radius, lineWidth,
    //     rotation, direction, numSidesToDraw, color, transform, this.limits,
    //   );
    // }
    // polygonFilled(
    //   numSides: number,
    //   radius: number,
    //   rotation: number,
    //   numSidesToDraw: number,
    //   color: Array<number>,
    //   transform: Transform | Point = new Transform(),
    //   textureLocation: string = '',
    //   textureCoords: Rect = new Rect(0, 0, 1, 1),
    // ) {
    //   return PolygonFilled(
    //     this.webgl, numSides, radius,
    //     rotation, numSidesToDraw, color, transform, this.limits, textureLocation, textureCoords,
    //   );
    // }

  }, {
    key: "polygon",
    value: function polygon() {
      var defaultOptions = {
        sides: 4,
        radius: 1,
        width: 0.01,
        rotation: 0,
        clockwise: false,
        sidesToDraw: null,
        color: [1, 0, 0, 1],
        fill: false,
        transform: null,
        point: null,
        textureLocation: '',
        // If including a texture, make sure to use
        textureCoords: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](0, 0, 1, 1),
        // correct shader in diagram
        onLoad: this.animateNextFrame,
        mods: {}
      };

      for (var _len5 = arguments.length, options = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        options[_key5] = arguments[_key5];
      }

      var optionsToUse = Object.assign.apply(Object, [{}, defaultOptions].concat(options));
      var o = optionsToUse;
      var transform = o.transform;

      if (transform == null && o.point != null) {
        transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('polygon').translate(o.point);
      } else if (transform == null) {
        transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('polygon');
      }

      if (o.sidesToDraw == null) {
        o.sidesToDraw = o.sides;
      }

      var direction = 1;

      if (o.clockwise) {
        direction = -1;
      }

      var element;

      if (o.fill) {
        element = Object(_DiagramElements_Polygon__WEBPACK_IMPORTED_MODULE_9__["PolygonFilled"])(this.webgl, o.sides, o.radius, o.rotation, o.sidesToDraw, o.color, transform, this.limits, o.textureLocation, o.textureCoords, o.onLoad);
      } else {
        element = Object(_DiagramElements_Polygon__WEBPACK_IMPORTED_MODULE_9__["Polygon"])(this.webgl, o.sides, o.radius, o.width, o.rotation, direction, o.sidesToDraw, o.color, transform, this.limits);
      }

      if (optionsToUse.mods != null && optionsToUse.mods !== {}) {
        element.setProperties(optionsToUse.mods);
      }

      return element;
    }
  }, {
    key: "polygonLine",
    value: function polygonLine(numSides, radius, rotation, direction, numSidesToDraw, numLines, // equivalent to thickness - integer
    color) {
      var transform = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      return Object(_DiagramElements_Polygon__WEBPACK_IMPORTED_MODULE_9__["PolygonLine"])(this.webgl, numSides, radius, rotation, direction, numSidesToDraw, numLines, color, transform, this.limits);
    }
  }, {
    key: "horizontalLine",
    value: function horizontalLine(start, length, width, rotation, color) {
      var transform = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      return Object(_DiagramElements_HorizontalLine__WEBPACK_IMPORTED_MODULE_11__["default"])(this.webgl, start, length, width, rotation, color, transform, this.limits);
    }
  }, {
    key: "dashedLine",
    value: function dashedLine(start, length, width, rotation, dashStyle, color) {
      var transform = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      return Object(_DiagramElements_DashedLine__WEBPACK_IMPORTED_MODULE_12__["default"])(this.webgl, start, length, width, rotation, dashStyle, color, transform, this.limits);
    }
  }, {
    key: "rectangleFilled",
    value: function rectangleFilled(topLeft, width, height, cornerRadius, cornerSides, color) {
      var transform = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      return Object(_DiagramElements_RectangleFilled__WEBPACK_IMPORTED_MODULE_13__["default"])(this.webgl, topLeft, width, height, cornerRadius, cornerSides, color, transform, this.limits);
    }
  }, {
    key: "radialLines",
    value: function radialLines() {
      var innerRadius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var outerRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.05;
      var dAngle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI / 4;
      var color = arguments.length > 4 ? arguments[4] : undefined;
      var transform = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      return Object(_DiagramElements_RadialLines__WEBPACK_IMPORTED_MODULE_10__["default"])(this.webgl, innerRadius, outerRadius, width, dAngle, color, transform, this.limits);
    }
  }, {
    key: "collection",
    value: function collection() {
      var transformOrPointOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]()
      };
      var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();

      if (transformOrPointOrOptions instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        transform = transform.translate(transformOrPointOrOptions.x, transformOrPointOrOptions.y);
      } else if (transformOrPointOrOptions instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]) {
        transform = transformOrPointOrOptions._dup();
      } else {
        for (var _len6 = arguments.length, moreOptions = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
          moreOptions[_key6 - 1] = arguments[_key6];
        }

        var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_5__["joinObjects"].apply(void 0, [transformOrPointOrOptions].concat(moreOptions));

        if (optionsToUse.position != null) {
          transform = transform.translate(optionsToUse.position.x, optionsToUse.position.y);
        }

        if (optionsToUse.transform != null) {
          transform = optionsToUse.transform;
        }
      }

      return new _Element__WEBPACK_IMPORTED_MODULE_1__["DiagramElementCollection"](transform, this.limits);
    }
  }, {
    key: "repeatPattern",
    value: function repeatPattern(element, xNum, yNum, xStep, yStep) {
      var transform = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      var group;

      if (transform instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]) {
        group = this.collection({
          transform: transform
        });
      } else {
        group = this.collection({
          transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(transform)
        });
      }

      var t = element.transform.t();

      var transformToUse = element.transform._dup();

      if (t === null) {
        t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
        transformToUse = transformToUse.translate(0, 0);
      }

      if (t) {
        for (var x = 0; x < xNum; x += 1) {
          for (var y = 0; y < yNum; y += 1) {
            var copy = element._dup();

            copy.transform = transformToUse._dup();
            copy.transform.updateTranslation(t.x + xStep * x, t.y + yStep * y);
            group.add("xy".concat(x).concat(y), copy);
          }
        }
      }

      return group;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "repeatPatternVertex",
    value: function repeatPatternVertex(element, xNum, yNum, xStep, yStep) {
      var transform = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();

      var copy = element._dup();

      var drawingObject = element.drawingObject; // console.log(element.drawingObject.points)

      if (drawingObject instanceof _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_6__["default"]) {
        copy.transform = transform._dup();
        var newPoints = [];
        var points = drawingObject.points;

        for (var x = 0; x < xNum; x += 1) {
          for (var y = 0; y < yNum; y += 1) {
            for (var p = 0; p < points.length; p += 2) {
              newPoints.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](points[p] + x * xStep, points[p + 1] + y * yStep)); // console.log(points[p], points[p+1], newPoints.slice(-1))
            }
          }
        } // console.log(newPoints)


        copy.drawingObject.changeVertices(newPoints);
      }

      return copy;
    }
  }, {
    key: "axes",
    value: function axes() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var limits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2);
      var yAxisLocation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var xAxisLocation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var stepX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.1;
      var stepY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0.1;
      var fontSize = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0.13;
      var showGrid = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : true;
      var color = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : [1, 1, 1, 0];
      var gridColor = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : [1, 1, 1, 0];
      var location = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      var decimalPlaces = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 1;
      var lineWidth = 0.01;
      var xProps = new _DiagramElements_Plot_AxisProperties__WEBPACK_IMPORTED_MODULE_16__["AxisProperties"]('x', 0);
      xProps.minorTicks.mode = 'off';
      xProps.minorGrid.mode = 'off';
      xProps.majorGrid.mode = 'off';
      xProps.length = width;
      xProps.width = lineWidth;
      xProps.limits = {
        min: limits.left,
        max: limits.right
      };
      xProps.color = color.slice();
      xProps.title = '';
      xProps.majorTicks.start = limits.left;
      xProps.majorTicks.step = stepX;
      xProps.majorTicks.length = lineWidth * 5;
      xProps.majorTicks.offset = -xProps.majorTicks.length / 2;
      xProps.majorTicks.width = lineWidth * 2;
      xProps.majorTicks.labelMode = 'off';
      xProps.majorTicks.labels = _tools_math__WEBPACK_IMPORTED_MODULE_4__["range"](xProps.limits.min, xProps.limits.max, stepX).map(function (v) {
        return v.toFixed(decimalPlaces);
      }).map(function (v) {
        if (v === yAxisLocation.toString() && yAxisLocation === xAxisLocation) {
          return "".concat(v, "     ");
        }

        return v;
      }); // xProps.majorTicks.labels[xProps.majorTicks.labels / 2] = '   0';

      xProps.majorTicks.labelOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, xProps.majorTicks.offset - fontSize * 0.1);
      xProps.majorTicks.labelsHAlign = 'center';
      xProps.majorTicks.labelsVAlign = 'top';
      xProps.majorTicks.fontColor = color.slice();
      xProps.majorTicks.fontSize = fontSize;
      xProps.majorTicks.fontWeight = '400';
      var xAxis = new _DiagramElements_Plot_Axis__WEBPACK_IMPORTED_MODULE_17__["default"](this.webgl, this.draw2D, xProps, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).rotate(0).translate(0, xAxisLocation - limits.bottom * height / 2), this.limits);
      var yProps = new _DiagramElements_Plot_AxisProperties__WEBPACK_IMPORTED_MODULE_16__["AxisProperties"]('x', 0);
      yProps.minorTicks.mode = 'off';
      yProps.minorGrid.mode = 'off';
      yProps.majorGrid.mode = 'off';
      yProps.length = height;
      yProps.width = xProps.width;
      yProps.limits = {
        min: limits.bottom,
        max: limits.top
      };
      yProps.color = xProps.color;
      yProps.title = '';
      yProps.rotation = Math.PI / 2;
      yProps.majorTicks.step = stepY;
      yProps.majorTicks.start = limits.bottom;
      yProps.majorTicks.length = xProps.majorTicks.length;
      yProps.majorTicks.offset = -yProps.majorTicks.length / 2;
      yProps.majorTicks.width = xProps.majorTicks.width;
      yProps.majorTicks.labelMode = 'off';
      yProps.majorTicks.labels = _tools_math__WEBPACK_IMPORTED_MODULE_4__["range"](yProps.limits.min, yProps.limits.max, stepY).map(function (v) {
        return v.toFixed(decimalPlaces);
      }).map(function (v) {
        if (v === xAxisLocation.toString() && yAxisLocation === xAxisLocation) {
          return '';
        }

        return v;
      }); // yProps.majorTicks.labels[3] = '';

      yProps.majorTicks.labelOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](yProps.majorTicks.offset - fontSize * 0.2, 0);
      yProps.majorTicks.labelsHAlign = 'right';
      yProps.majorTicks.labelsVAlign = 'middle';
      yProps.majorTicks.fontColor = xProps.majorTicks.fontColor;
      yProps.majorTicks.fontSize = fontSize;
      yProps.majorTicks.fontWeight = xProps.majorTicks.fontWeight;
      var yAxis = new _DiagramElements_Plot_Axis__WEBPACK_IMPORTED_MODULE_17__["default"](this.webgl, this.draw2D, yProps, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).rotate(0).translate(yAxisLocation - limits.left * width / 2, 0), this.limits);
      var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();

      if (location instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        transform = transform.translate(location.x, location.y);
      } else {
        transform = location._dup();
      }

      var xy = this.collection(transform);

      if (showGrid) {
        var gridLines = this.grid(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](0, 0, width, height), _tools_math__WEBPACK_IMPORTED_MODULE_4__["roundNum"](stepX * width / limits.width, 8), _tools_math__WEBPACK_IMPORTED_MODULE_4__["roundNum"](stepY * height / limits.height, 8), 1, gridColor, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).rotate(0).translate(0, 0));
        xy.add('grid', gridLines);
      }

      xy.add('y', yAxis);
      xy.add('x', xAxis);
      return xy;
    }
  }]);

  return DiagramPrimatives;
}();



/***/ }),

/***/ "./src/js/diagram/DrawContext2D.js":
/*!*****************************************!*\
  !*** ./src/js/diagram/DrawContext2D.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DrawContext2D =
/*#__PURE__*/
function () {
  function DrawContext2D(canvas) {
    _classCallCheck(this, DrawContext2D);

    this.canvas = canvas;
    this.ctx = this.canvas.getContext('2d');
    /* $FlowFixMe */

    var bsr = this.ctx.webkitBackingStorePixelRatio
    /* $FlowFixMe */
    || this.ctx.mozBackingStorePixelRatio
    /* $FlowFixMe */
    || this.ctx.msBackingStorePixelRatio
    /* $FlowFixMe */
    || this.ctx.oBackingStorePixelRatio
    /* $FlowFixMe */
    || this.ctx.backingStorePixelRatio || 1;
    var dpr = window.devicePixelRatio || 1;

    if (dpr === 1) {
      dpr = 2;
    }

    this.ratio = dpr / bsr;
    this.resize();
  }

  _createClass(DrawContext2D, [{
    key: "resize",
    value: function resize() {
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.canvas.width = this.canvas.clientWidth * this.ratio;
      this.canvas.height = this.canvas.clientHeight * this.ratio;
      this.ctx.scale(this.ratio, this.ratio);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      return this;
    }
  }]);

  return DrawContext2D;
}();

/* harmony default export */ __webpack_exports__["default"] = (DrawContext2D);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/DrawingObject.js":
/*!********************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/DrawingObject.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

 // A Drawing object can be:
//  - GL primitive vertices
//  - Text object for 2D drawing contexts
//  - HTML Object in the diagram_html div
//
// It must have:
//
//   Properties:
//     - location     A reference location where relative boundaries are
//                    calculated from
//     - border       Array of borders in Diagram Units
//
//   Methods:
//     - drawWithTransformMatrix(transformMatrix)
//     - calcBorder(lastDrawTransformMatrix, glToDiagramTransform)
//

var DrawingObject =
/*#__PURE__*/
function () {
  // numPoints: number;           // Number of primative vertices
  // Border vertices
  // Border of any holes inside of main border
  // Only used for drawing objects with asynchronous
  //                            loading (like textures)
  function DrawingObject() {
    _classCallCheck(this, DrawingObject);

    // this.numPoints = 0;
    this.location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    this.border = [[]];
    this.holeBorder = [[]];
    this.onLoad = null;
    this.type = 'drawingObject';
  }

  _createClass(DrawingObject, [{
    key: "_dup",
    value: function _dup() {
      return this;
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "setText",
    value: function setText(text) {}
  }, {
    key: "getGLBoundaries",
    value: function getGLBoundaries(lastDrawTransformMatrix) {
      var glBoundaries = [];
      this.border.forEach(function (boundary) {
        var glBorder = [];
        boundary.forEach(function (point) {
          glBorder.push(point.transformBy(lastDrawTransformMatrix));
        });
        glBoundaries.push(glBorder);
      });
      return glBoundaries;
    }
  }, {
    key: "getGLBoundaryHoles",
    value: function getGLBoundaryHoles(lastDrawTransformMatrix) {
      var glBoundaries = [];
      this.holeBorder.forEach(function (boundary) {
        var glBorder = [];
        boundary.forEach(function (point) {
          glBorder.push(point.transformBy(lastDrawTransformMatrix));
        });
        glBoundaries.push(glBorder);
      });
      return glBoundaries;
    }
    /* eslint-enable */

    /* eslint-disable class-methods-use-this, no-unused-vars */

  }, {
    key: "drawWithTransformMatrix",
    value: function drawWithTransformMatrix(transformMatrix, color, numPoints) {}
    /* eslint-enable */

  }, {
    key: "getGLBoundingRect",
    value: function getGLBoundingRect(lastDrawTransformMatrix) {
      var boundaries = this.getGLBoundaries(lastDrawTransformMatrix); // const min = new Point(0, 0);
      // const max = new Point(0, 0);
      // let firstPoint = true;
      // boundaries.forEach((boundary) => {
      //   boundary.forEach((point) => {
      //     if (firstPoint) {
      //       min.x = point.x;
      //       min.y = point.y;
      //       max.x = point.x;
      //       max.y = point.y;
      //       firstPoint = false;
      //     } else {
      //       min.x = point.x < min.x ? point.x : min.x;
      //       min.y = point.y < min.y ? point.y : min.y;
      //       max.x = point.x > max.x ? point.x : max.x;
      //       max.y = point.y > max.y ? point.y : max.y;
      //     }
      //   });
      // });
      // return new Rect(min.x, min.y, max.x - min.x, max.y - min.y);

      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(boundaries);
    }
  }, {
    key: "getVertexSpaceBoundingRect",
    value: function getVertexSpaceBoundingRect() {
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(this.border);
    }
  }, {
    key: "getLocation",
    value: function getLocation() {
      return this.location;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getGLLocation",
    value: function getGLLocation(lastDrawTransformMatrix) {
      return this.getLocation().transformBy(lastDrawTransformMatrix);
    }
  }, {
    key: "getRelativeGLBoundingRect",
    value: function getRelativeGLBoundingRect(lastDrawTransformMatrix) {
      var glLocation = this.getGLLocation(lastDrawTransformMatrix);
      var glAbsoluteBoundaries = this.getGLBoundingRect(lastDrawTransformMatrix);
      var glRelativeBoundaries = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](glAbsoluteBoundaries.left - glLocation.x, glAbsoluteBoundaries.bottom - glLocation.y, glAbsoluteBoundaries.width, glAbsoluteBoundaries.height);
      return glRelativeBoundaries;
    }
  }, {
    key: "getRelativeVertexSpaceBoundingRect",
    value: function getRelativeVertexSpaceBoundingRect() {
      var absoluteBoundaries = this.getVertexSpaceBoundingRect();
      var relativeBoundaries = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](absoluteBoundaries.left - this.location.x, absoluteBoundaries.bottom - this.location.y, absoluteBoundaries.width, absoluteBoundaries.height);
      return relativeBoundaries;
    } // eslint-disable-next-line no-unused-vars, class-methods-use-this

  }, {
    key: "change",
    value: function change() {}
  }]);

  return DrawingObject;
}();

/* harmony default export */ __webpack_exports__["default"] = (DrawingObject);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/HTMLObject/HTMLObject.js":
/*!****************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/HTMLObject/HTMLObject.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _DrawingObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DrawingObject */ "./src/js/diagram/DrawingObjects/DrawingObject.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import * as m2 from '../tools/m2';



var HTMLObject =
/*#__PURE__*/
function (_DrawingObject) {
  _inherits(HTMLObject, _DrawingObject);

  // diagramLimits: Rect;
  function HTMLObject(parentDiv, id, location) {
    var _this;

    var alignV = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'middle';
    var alignH = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'center';

    _classCallCheck(this, HTMLObject);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HTMLObject).call(this));
    var element = document.getElementById(id);

    if (element) {
      _this.element = element;
    }

    _this.location = location;
    _this.alignV = alignV;
    _this.alignH = alignH;
    _this.parentDiv = parentDiv;
    _this.show = true;

    _this.setBorder();

    return _this;
  }

  _createClass(HTMLObject, [{
    key: "_dup",
    value: function _dup() {
      var c = new HTMLObject(this.parentDiv, this.id, this.location._dup(), this.alignV, this.alignH);
      c.show = this.show;
      c.border = this.border.map(function (b) {
        return b.map(function (p) {
          return p._dup();
        });
      });
      return c;
    }
  }, {
    key: "setBorder",
    value: function setBorder() {
      var parentRect = this.parentDiv.getBoundingClientRect();
      var elementRect = this.element.getBoundingClientRect();
      var left = elementRect.left - parentRect.left;
      var right = left + elementRect.width;
      var top = elementRect.top - parentRect.top;
      var bottom = top + elementRect.height;
      var boundary = [];
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](left, top));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](right, top));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](right, bottom));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](left, bottom));
      this.border = [];
      this.border.push(boundary);
    }
  }, {
    key: "getGLBoundaries",
    value: function getGLBoundaries() {
      var parentRect = this.parentDiv.getBoundingClientRect();
      var glSpace = {
        x: {
          bottomLeft: -1,
          width: 2
        },
        y: {
          bottomLeft: -1,
          height: 2
        }
      };
      var pixelSpace = {
        x: {
          bottomLeft: 0,
          width: parentRect.width
        },
        y: {
          bottomLeft: parentRect.height,
          height: -parentRect.height
        }
      };
      var pixelToGLTransform = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["spaceToSpaceTransform"])(pixelSpace, glSpace);
      var elementRect = this.element.getBoundingClientRect();
      var left = elementRect.left - parentRect.left;
      var right = left + elementRect.width;
      var top = elementRect.top - parentRect.top;
      var bottom = top + elementRect.height;
      var boundary = [];
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](left, top));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](right, top));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](right, bottom));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](left, bottom));
      return [boundary.map(function (p) {
        return p.transformBy(pixelToGLTransform.matrix());
      })];
    }
  }, {
    key: "glToPixelSpace",
    value: function glToPixelSpace(p) {
      var x = (p.x - -1) / 2 * this.parentDiv.offsetWidth;
      var y = (1 - p.y) / 2 * this.parentDiv.offsetHeight;
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](x, y);
    }
  }, {
    key: "change",
    value: function change(newHtml, lastDrawTransformMatrix) {
      var element = newHtml;

      if (typeof newHtml === 'string') {
        element = document.createElement('div');
        element.innerHTML = newHtml;
      }

      if (element instanceof HTMLElement) {
        this.element.innerHTML = '';
        this.element.appendChild(element);
        this.transformHtml(lastDrawTransformMatrix);
      }
    }
  }, {
    key: "transformHtml",
    value: function transformHtml(transformMatrix) {
      if (this.show) {
        var glLocation = this.location.transformBy(transformMatrix);
        var pixelLocation = this.glToPixelSpace(glLocation);
        var w = this.element.offsetWidth;
        var h = this.element.offsetHeight;
        var left = 0;
        var top = 0;

        if (this.alignH === 'center') {
          left = -w / 2;
        } else if (this.alignH === 'right') {
          left = -w;
        }

        if (this.alignV === 'middle') {
          top = -h / 2;
        } else if (this.alignV === 'bottom') {
          top = -h;
        }

        var x = pixelLocation.x + left;
        var y = pixelLocation.y + top;
        this.element.style.position = 'absolute';
        this.element.style.left = "".concat(x, "px");
        this.element.style.top = "".concat(y, "px");
      } else {
        this.element.style.position = 'absolute';
        this.element.style.left = '-10000px';
        this.element.style.top = '-10000px'; // console.trace()
      }
    }
  }, {
    key: "drawWithTransformMatrix",
    value: function drawWithTransformMatrix(transformMatrix) {
      this.transformHtml(transformMatrix);
    }
  }]);

  return HTMLObject;
}(_DrawingObject__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (HTMLObject); // Transform -1 to 1 space to 0 to width/height space

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/TextObject/TextObject.js":
/*!****************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/TextObject/TextObject.js ***!
  \****************************************************************/
/*! exports provided: TextObject, DiagramText, DiagramFont */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextObject", function() { return TextObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagramText", function() { return DiagramText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagramFont", function() { return DiagramFont; });
/* harmony import */ var _tools_m2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/m2 */ "./src/js/tools/m2.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _DrawingObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DrawingObject */ "./src/js/diagram/DrawingObjects/DrawingObject.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../DrawContext2D */ "./src/js/diagram/DrawContext2D.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }







function colorArrayToString(color) {
  return "rgba(".concat(Math.floor(color[0] * 255), ",").concat(Math.floor(color[1] * 255), ",").concat(Math.floor(color[2] * 255), ",").concat(color[3], ")");
} // DiagramFont defines the font properties to be used in a TextObject


var DiagramFont =
/*#__PURE__*/
function () {
  function DiagramFont() {
    var family = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Helvetica Neue';
    var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var weight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '200';
    var alignH = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'center';
    var alignV = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'middle';
    var color = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;

    _classCallCheck(this, DiagramFont);

    this.family = family;
    this.style = style;
    this.size = size;
    this.weight = weight;
    this.alignH = alignH;
    this.alignV = alignV;
    this.setColor(color); // if (Array.isArray(color)) {
    //   this.color = colorArrayToString(color);
    // } else {
    //   this.color = color;
    // }
  }

  _createClass(DiagramFont, [{
    key: "setColor",
    value: function setColor() {
      var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (Array.isArray(color)) {
        this.color = colorArrayToString(color);
      } else {
        this.color = color;
      }
    }
  }, {
    key: "set",
    value: function set(ctx) {
      var scalingFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      ctx.font = "".concat(this.style, " ").concat(this.weight, " ").concat(this.size * scalingFactor, "px ").concat(this.family);
      ctx.textAlign = this.alignH;
      ctx.textBaseline = this.alignV;
    }
  }, {
    key: "_dup",
    value: function _dup() {
      return new DiagramFont(this.family, this.style, this.size, this.weight, this.alignH, this.alignV, this.color);
    }
  }]);

  return DiagramFont;
}(); // DiagramText is a single text element of the diagram that is drawn at
// once and referenced to the same location


var DiagramText =
/*#__PURE__*/
function () {
  function DiagramText() {
    var location = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);
    var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var font = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new DiagramFont();

    _classCallCheck(this, DiagramText);

    this.location = location._dup();
    this.text = text.slice();
    this.font = font._dup();
  }

  _createClass(DiagramText, [{
    key: "_dup",
    value: function _dup() {
      return new DiagramText(this.location._dup(), this.text, this.font._dup());
    }
  }]);

  return DiagramText;
}(); // TextObject is the DrawingObject used in the DiagramElementPrimative.
// TextObject will draw an array of DiagramText objects.


var TextObject =
/*#__PURE__*/
function (_DrawingObject) {
  _inherits(TextObject, _DrawingObject);

  function TextObject(drawContext2D) {
    var _this;

    var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    _classCallCheck(this, TextObject);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TextObject).call(this));
    _this.drawContext2D = drawContext2D;
    _this.text = text;
    _this.scalingFactor = 1;
    _this.lastDraw = [];
    _this.lastDrawTransform = [];
    _this.glRect = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Rect"](-1, -1, 2, 2);

    if (text.length > 0) {
      var minSize = _this.text[0].font.size;

      _this.text.forEach(function (t) {
        if (t.font.size > 0 && t.font.size < minSize) {
          minSize = t.font.size;
        }
      });

      if (minSize < 20) {
        _this.scalingFactor = minSize * 50;
      }

      if (minSize < 1) {
        var power = -Math.log10(minSize) + 2;
        _this.scalingFactor = Math.pow(10, power);
      }
    }

    _this.setBorder();

    return _this;
  }

  _createClass(TextObject, [{
    key: "setText",
    value: function setText(text) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.text[index].text = text;
      this.setBorder();
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var c = new TextObject(this.drawContext2D, this.text);
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["duplicateFromTo"])(this, c);
      c.scalingFactor = this.scalingFactor;
      c.border = this.border.map(function (b) {
        return b.map(function (p) {
          return p._dup();
        });
      });
      return c;
    }
  }, {
    key: "setFont",
    value: function setFont(fontSize) {
      for (var i = 0; i < this.text.length; i += 1) {
        this.text[i].font.size = fontSize;
      }

      this.setBorder();
    }
  }, {
    key: "setColor",
    value: function setColor(color) {
      var c = colorArrayToString(color);

      for (var i = 0; i < this.text.length; i += 1) {
        this.text[i].font.color = c;
      }
    }
  }, {
    key: "draw",
    value: function draw(translation, rotation, scale, count, color) {
      var transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["identity"]();
      transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["translate"](transformation, translation.x, translation.y);
      transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["rotate"](transformation, rotation);
      transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["scale"](transformation, scale.x, scale.y);
      this.drawWithTransformMatrix(_tools_m2__WEBPACK_IMPORTED_MODULE_0__["t"](transformation), color);
    } // Text is drawn in pixel space which is 0, 0 in the left hand top corner on
    // a canvas of size canvas.offsetWidth x canvas.offsetHeight.
    //
    // Font size and text location is therefore defined in pixels.
    //
    // However, in a Diagram, the text canvas is overlaid on the diagram GL
    // canvas and we want to think about the size and location of text in
    // Diagram Space or Element Space (if the element has a specific transform).
    //
    // For example, if we have a diagram with limits: min: (0, 0), max(2, 1)
    // with a canvas of 1000 x 500 then:
    //    1) Transform pixel space (1000 x 500) to be GL Space (2 x 2). i.e.
    //         - Magnify pixel space by 500 so one unit in the 2D drawing
    //           context is equivalent to 1 unit in GL Space.
    //         - Translate pixel space so 0, 0 is in the middle of the canvas
    //    2) Transform GL Space to Element Space
    //         - The transform matrix in the input parameters includes the
    //           transform to Diagram Space and then Element Space.
    //         - Now one unit in the 2D drawing context is equivalent to 1 unit
    //           in Element Space - i.e. the canvas will have limits of min(0, 0)
    //           and max(2, 1).
    //    3) Plot out all text
    //
    // However, when font size is defined in Element Space, and ends up being
    // <1 Element Space units, we have a problem. This is because font size is
    // still in pixels (just now it's super scaled up). Therefore, a scaling
    // factor is needed to make sure the font size can stay well above 1. This
    // scaling factor scales the final space, so a larger font size can be used.
    // Then all locations definted in Element Space also need to be scaled by
    // this scaling factor.
    //
    // The scaling factor can be number that is large enough to make it so the
    // font size is >>1. In the TextObject constructor, the scaling factor is
    // designed to ensure drawn text always is >20px.

  }, {
    key: "drawWithTransformMatrix",
    value: function drawWithTransformMatrix(transformMatrix) {
      var _this2 = this;

      var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1, 1, 1, 1];
      var ctx = this.drawContext2D.ctx; // Arbitrary scaling factor used to ensure font size is >> 1 pixel
      // const scalingFactor = this.drawContext2D.canvas.offsetHeight /
      //                       (this.diagramLimits.height / 1000);

      var scalingFactor = this.scalingFactor; // Color used if color is not defined in each DiagramText element

      var parentColor = "rgba(\n      ".concat(Math.floor(color[0] * 255), ",\n      ").concat(Math.floor(color[1] * 255), ",\n      ").concat(Math.floor(color[2] * 255), ",\n      ").concat(Math.floor(color[3] * 255), ")");
      ctx.save(); // First convert pixel space to a zoomed in pixel space with the same
      // dimensions as gl clip space (-1 to 1 for x, y), but inverted y
      // like to pixel space.
      // When zoomed: 1 pixel = 1 GL unit.
      // Zoom in so limits betcome 0 to 2:

      var sx = this.drawContext2D.canvas.offsetWidth / 2 / scalingFactor;
      var sy = this.drawContext2D.canvas.offsetHeight / 2 / scalingFactor; // Translate so limits become -1 to 1

      var tx = this.drawContext2D.canvas.offsetWidth / 2;
      var ty = this.drawContext2D.canvas.offsetHeight / 2; // Modify the incoming transformMatrix to be compatible with zoomed
      // pixel space
      //   - Scale by the scaling factor
      //   - Flip the y translation
      //   - Reverse rotation

      var tm = transformMatrix;
      var t = [tm[0], -tm[1], tm[2] * scalingFactor, -tm[3], tm[4], tm[5] * -scalingFactor, 0, 0, 1]; // Combine the zoomed pixel space with the incoming transform matrix
      // and apply it to the drawing context.

      var totalT = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["mul"]([sx, 0, tx, 0, sy, ty, 0, 0, 1], t);
      ctx.transform(totalT[0], totalT[3], totalT[1], totalT[4], totalT[2], totalT[5]);
      this.lastDrawTransform = totalT.slice(); // Fill in all the text

      this.text.forEach(function (diagramText) {
        diagramText.font.set(ctx, scalingFactor);

        if (diagramText.font.color) {
          ctx.fillStyle = diagramText.font.color;
        } else {
          ctx.fillStyle = parentColor;
        } // const w = ctx.measureText(diagramText.text).width;
        // this.lastDraw.push({
        //   width: w * 2,
        //   height: w * 2,
        //   x: diagramText.location.x * scalingFactor - w,
        //   y: diagramText.location.y * -scalingFactor - w,
        // });


        _this2.recordLastDraw(ctx, diagramText, scalingFactor, diagramText.location.x * scalingFactor, diagramText.location.y * -scalingFactor);

        ctx.fillText(diagramText.text, diagramText.location.x * scalingFactor, diagramText.location.y * -scalingFactor);
      });
      ctx.restore();
    }
  }, {
    key: "recordLastDraw",
    value: function recordLastDraw(ctx, diagramText, scalingFactor, x, y) {
      var width = ctx.measureText(diagramText.text).width * 1.2;
      var height = diagramText.font.size * scalingFactor * 1.2;
      var bottom = y + height * 0.1;
      var left = x - width * 0.1;

      if (diagramText.font.alignV === 'baseline') {
        bottom = y + height * 0.2;
      } else if (diagramText.font.alignV === 'top') {
        bottom = y + height;
      } else if (diagramText.font.alignV === 'middle') {
        bottom = y + height / 2;
      }

      if (diagramText.font.alignH === 'center') {
        left -= width / 2;
      } else if (diagramText.font.alignH === 'right') {
        left -= width;
      }

      this.lastDraw.push({
        width: width,
        height: -height,
        x: left,
        y: bottom
      }); // console.log(this.lastDraw)
    }
  }, {
    key: "clear",
    value: function clear() {
      var lastDraw = this.lastDraw;

      if (lastDraw.length > 0) {
        var ctx = this.drawContext2D.ctx;
        var t = this.lastDrawTransform;
        ctx.save();
        ctx.transform(t[0], t[3], t[1], t[4], t[2], t[5]);
        lastDraw.forEach(function (draw) {
          ctx.clearRect(draw.x, draw.y, draw.width, draw.height);
        });
        ctx.restore();
      }

      this.lastDraw = [];
    }
  }, {
    key: "getGLBoundaries",
    value: function getGLBoundaries(lastDrawTransformMatrix) {
      var _this3 = this;

      var glBoundaries = [];
      this.text.forEach(function (t) {
        glBoundaries.push(_this3.getGLBoundaryOfText(t, lastDrawTransformMatrix));
      });
      return glBoundaries;
    }
  }, {
    key: "setBorder",
    value: function setBorder() {
      var _this4 = this;

      this.border = [];
      this.text.forEach(function (t) {
        _this4.border.push(_this4.getBoundaryOfText(t));
      }); // return glBoundaries;
    } // This method is used instead of the actual ctx.measureText because
    // Firefox and Chrome don't yet support it's advanced features.
    // Estimates are made for height based on width.
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "measureText",
    value: function measureText(ctx, text) {
      var aWidth = ctx.measureText('a').width; // Estimations of FONT ascent and descent for a baseline of "alphabetic"

      var ascent = aWidth * 1.4;
      var descent = aWidth * 0.08; // Uncomment below and change above consts to lets if more resolution on
      // actual text boundaries is needed
      // const maxAscentRe =
      //   /[ABCDEFGHIJKLMNOPRSTUVWXYZ1234567890!#%^&()@$Qbdtfhiklj]/g;

      var midAscentRe = /[acemnorsuvwxz*gyqp]/g;
      var midDecentRe = /[;,$]/g;
      var maxDescentRe = /[gjyqp@Q(){}[\]|]/g;
      var midAscentMatches = text.text.match(midAscentRe);

      if (Array.isArray(midAscentMatches)) {
        if (midAscentMatches.length === text.text.length) {
          ascent = aWidth * 0.95;
        }
      }

      var midDescentMatches = text.text.match(midDecentRe);

      if (Array.isArray(midDescentMatches)) {
        if (midDescentMatches.length > 0) {
          descent = aWidth * 0.2;
        }
      }

      var maxDescentMatches = text.text.match(maxDescentRe);

      if (Array.isArray(maxDescentMatches)) {
        if (maxDescentMatches.length > 0) {
          descent = aWidth * 0.5;
        }
      }

      var height = ascent + descent;

      var _ctx$measureText = ctx.measureText(text.text),
          width = _ctx$measureText.width;

      var asc = 0;
      var des = 0;
      var left = 0;
      var right = 0;

      if (text.font.alignH === 'left') {
        right = width;
      }

      if (text.font.alignH === 'center') {
        left = width / 2;
        right = width / 2;
      }

      if (text.font.alignH === 'right') {
        left = width;
      }

      if (text.font.alignV === 'alphabetic') {
        asc = ascent;
        des = descent;
      }

      if (text.font.alignV === 'top') {
        asc = 0;
        des = height;
      }

      if (text.font.alignV === 'bottom') {
        asc = height;
        des = 0;
      }

      if (text.font.alignV === 'middle') {
        asc = height / 2;
        des = height / 2;
      }

      return {
        actualBoundingBoxLeft: left,
        actualBoundingBoxRight: right,
        fontBoundingBoxAscent: asc,
        fontBoundingBoxDescent: des
      };
    }
  }, {
    key: "getBoundaryOfText",
    value: function getBoundaryOfText(text) {
      var boundary = [];
      var scalingFactor = this.scalingFactor; // Measure the text

      text.font.set(this.drawContext2D.ctx, scalingFactor); // const textMetrics = this.drawContext2D.ctx.measureText(text.text);

      var textMetrics = this.measureText(this.drawContext2D.ctx, text); // Create a box around the text

      var location = text.location;
      var box = [new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](-textMetrics.actualBoundingBoxLeft / scalingFactor, textMetrics.fontBoundingBoxAscent / scalingFactor).add(location), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](textMetrics.actualBoundingBoxRight / scalingFactor, textMetrics.fontBoundingBoxAscent / scalingFactor).add(location), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](textMetrics.actualBoundingBoxRight / scalingFactor, -textMetrics.fontBoundingBoxDescent / scalingFactor).add(location), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](-textMetrics.actualBoundingBoxLeft / scalingFactor, -textMetrics.fontBoundingBoxDescent / scalingFactor).add(location)];
      box.forEach(function (p) {
        boundary.push(p);
      }); // console.log('boundary', boundary.width, text.text)

      return boundary;
    }
  }, {
    key: "getGLBoundaryOfText",
    value: function getGLBoundaryOfText(text, lastDrawTransformMatrix) {
      var glBoundary = []; // const { scalingFactor } = this;
      // // Measure the text
      // text.font.set(this.drawContext2D.ctx, scalingFactor);
      // // const textMetrics = this.drawContext2D.ctx.measureText(text.text);
      // const textMetrics = this.measureText(this.drawContext2D.ctx, text);
      // // Create a box around the text
      // const { location } = text;
      // const box = [
      //   new Point(
      //     -textMetrics.actualBoundingBoxLeft / scalingFactor,
      //     textMetrics.fontBoundingBoxAscent / scalingFactor,
      //   ).add(location),
      //   new Point(
      //     textMetrics.actualBoundingBoxRight / scalingFactor,
      //     textMetrics.fontBoundingBoxAscent / scalingFactor,
      //   ).add(location),
      //   new Point(
      //     textMetrics.actualBoundingBoxRight / scalingFactor,
      //     -textMetrics.fontBoundingBoxDescent / scalingFactor,
      //   ).add(location),
      //   new Point(
      //     -textMetrics.actualBoundingBoxLeft / scalingFactor,
      //     -textMetrics.fontBoundingBoxDescent / scalingFactor,
      //   ).add(location),
      // ];

      var box = this.getBoundaryOfText(text);
      box.forEach(function (p) {
        glBoundary.push(p.transformBy(lastDrawTransformMatrix));
      });
      return glBoundary;
    }
  }]);

  return TextObject;
}(_DrawingObject__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/PolyLineTriangles.js":
/*!*************************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/PolyLineTriangles.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");


function simpleIntersect(p1, p2, q1, q2) {
  var lineP = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, p2);
  var lineQ = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](q1, q2);
  return lineP.intersectsWith(lineQ).intersect;
} // Generate a thick line assuming gl.TRIANGLES where corners are sharp.
// Input:
//   * coords: an array of points that will define the center of the line


function polyLineTriangles(coords, close, width) {
  var points = [];
  var innerBorder = [];
  var outerBorder = [];
  var line1Pairs = [];
  var line2Pairs = [];
  var halfWidth = width / 2;
  var p;
  var q;

  if (close) {
    coords.push(coords[0]);
  } // got through the points that define the center of the line, and generate
  // offset lines on either side of them (named Line1 and Line2).


  for (var i = 1; i < coords.length; i += 1) {
    p = coords[i - 1]; // center line point 1

    q = coords[i]; // center line point 2

    var angle = Math.atan2(q.y - p.y, q.x - p.x);
    var offset1 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](halfWidth * Math.cos(angle + Math.PI / 2), halfWidth * Math.sin(angle + Math.PI / 2));
    var offset2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](halfWidth * Math.cos(angle - Math.PI / 2), halfWidth * Math.sin(angle - Math.PI / 2));
    line1Pairs.push([p.add(offset1), q.add(offset1)]); // Offset line 1

    line2Pairs.push([p.add(offset2), q.add(offset2)]); // Offset line 2
  } // If the line closes on itself, then find the intersection point of
  // the first and last offset lines.
  // p and q will represent the first points of offset lines 1 and 2.


  if (close) {
    // intersection point of first and last offset 1 lines
    p = simpleIntersect(line1Pairs[0][0], line1Pairs[0][1], line1Pairs[line1Pairs.length - 1][0], line1Pairs[line1Pairs.length - 1][1]); // intersection point of first and last offset 2 lines

    q = simpleIntersect(line2Pairs[0][0], line2Pairs[0][1], line2Pairs[line1Pairs.length - 1][0], line2Pairs[line2Pairs.length - 1][1]);
  } else {
    // if not closing on itself, then the first point is simply the first
    // point of the offset lines.
    p = line1Pairs[0][0]; // eslint-disable-line prefer-destructuring

    q = line2Pairs[0][0]; // eslint-disable-line prefer-destructuring
  } // The line effectively has two borders (named an inside and outside border)
  // but the inner border isn't necessarily the INSIDE border, it is just a
  // name.
  // p and q are the first points of the borders.


  innerBorder.push(p._dup());
  outerBorder.push(q._dup()); // Go through all offset lines, calculate their intersection points
  // and from them calculate the triangle and border points.

  for (var _i = 1; _i < line1Pairs.length; _i += 1) {
    // First two points of the Triangle 1 are the two ending points
    // of the last line segment
    points.push(p.x);
    points.push(p.y);
    points.push(q.x);
    points.push(q.y); // Next points are the intersection between the first line and the second line

    p = simpleIntersect(line1Pairs[_i - 1][0], line1Pairs[_i - 1][1], line1Pairs[_i][0], line1Pairs[_i][1]);
    q = simpleIntersect(line2Pairs[_i - 1][0], line2Pairs[_i - 1][1], line2Pairs[_i][0], line2Pairs[_i][1]); // Push the next points to the border

    innerBorder.push(p._dup());
    outerBorder.push(q._dup()); // Finish triangle 1

    points.push(q.x);
    points.push(q.y); // Make triangle 2

    points.push(points[points.length - 6]);
    points.push(points[points.length - 6]);
    points.push(q.x);
    points.push(q.y);
    points.push(p.x);
    points.push(p.y);
  } // Calculate the last end points


  var endp;
  var endq; // In not closing the polyline, the end points are just the last offset
  // line points

  if (!close) {
    endp = line1Pairs[line1Pairs.length - 1][1]; // eslint-disable-line prefer-destructuring

    endq = line2Pairs[line2Pairs.length - 1][1]; // eslint-disable-line prefer-destructuring
    // If closing the polyline, then the end points are the start points
  } else {
    endp = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](points[0], points[1]);
    endq = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](points[2], points[3]);
  } // Close out the last two triangles


  points.push(p.x); // Last two points of last line segment

  points.push(p.y);
  points.push(q.x);
  points.push(q.y);
  points.push(endq.x);
  points.push(endq.y);
  points.push(p.x); // Last triangle

  points.push(p.y);
  points.push(endq.x);
  points.push(endq.y);
  points.push(endp.x);
  points.push(endp.y);
  innerBorder.push(endp._dup());
  outerBorder.push(endq._dup()); // If closing, then remove the last duplicate coord as it was added by this
  // function

  if (close) {
    coords.pop();
  } // Form the border array


  var border = []; // If the poly line is closed, only one of the offset lines is the outside
  // border. If open, then both are the border.

  if (close) {
    if (innerBorder[0].isInPolygon(outerBorder)) {
      border = outerBorder;
    } else {
      border = innerBorder;
    }
  } else {
    border.push(innerBorder[0]);

    for (var _i2 = 0; _i2 < outerBorder.length; _i2 += 1) {
      border.push(outerBorder[_i2]);
    }

    for (var _i3 = innerBorder.length - 1; _i3 >= 0; _i3 -= 1) {
      border.push(innerBorder[_i3]);
    }
  }

  return {
    points: points,
    border: border
  };
}

/* harmony default export */ __webpack_exports__["default"] = (polyLineTriangles);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/PolyLineTriangles3.js":
/*!**************************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/PolyLineTriangles3.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return polyLineTriangles3; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
 // function simpleIntersect(p1: Point, p2: Point, q1: Point, q2: Point) {
//   const lineP = new Line(p1, p2);
//   const lineQ = new Line(q1, q2);
//   return lineP.intersectsWith(lineQ).intersect;
// }

// Generate a thick line assuming gl.TRIANGLES where corners are sharp.
// Input:
//   * coords: an array of points that will define the center of the line
function polyLineTriangles3(coords, close, width, borderToPoint) {
  var points = [];
  var border1 = []; // outside (vertex) when anticlockwise

  var border2 = []; // outside (vertex) when clockwise
  // const angleDir = [];    // -1 is anti-clockwise, +1 clockwise
  // const vertices = [];
  // class Vertex {
  //   point: Point;
  //   pre: ?Vertex;
  //   post: ?Vertex;
  //   dir: number;
  //   preAngle: ?number;
  //   postAngle: ?number;
  //   preLength: ?number;
  //   postLength: ?number;
  //   innerAngle: ?number
  //   constructor(point) {
  //     this.point = point;
  //     this.pre = null;
  //     this.post = null;
  //     this.dir = 0;
  //     this.preAngle = null;
  //     this.postAngle = null;
  //     this.preLength = null;
  //     this.postLength = null;
  //     this.minAngle = null;
  //   }
  // }
  // function calcAngleDir(
  //   pre: Point,
  //   mid: Point,
  //   post: Point,
  // ) {
  //   const midPost = post.sub(mid).toPolar();
  //   const midPre = pre.sub(mid).toPolar();
  //   const midPostUnit = polarToRect(1, midPost.angle);
  //   const midPreUnit = polarToRect(1, midPre.angle);
  //   const minAngle = minAngleDiff(midPost.angle, midPre.angle);
  //   let direction = Math.sin(minAngle);
  //   if (direction < 0) {
  //     direction = -1;
  //   } else if (direction > 0) {
  //     direction = 1;
  //   }
  //   const vertex = new Vertex(mid);
  //   vertex.dir = direction;
  //   vertex.preAngle = midPre.angle;
  //   vertex.postAngle = midPost.angle;
  //   vertex.preLength = midPre.mag;
  //   vertex.postLength = midPost.mag;
  //   vertex.minAngle = minAngle;
  //   vertices.push(vertex);
  // }
  // if (close) {
  //   calcAngleDir(coords[coords.length - 1], coords[0], coords[1]);
  // } else {
  //   angleDir.push(0);
  // }
  // for (let i = 1; i < coords.length - 1; i += 1) {
  //   calcAngleDir(coords[i - 1], coords[i], coords[i + 1]);
  // }
  // if (close) {
  //   calcAngleDir(coords[coords.length - 2], coords[coords.length - 1], coords[0]);
  // } else {
  //   angleDir.push(0);
  // }
  // console.log("Direction", vertices.map(v => v.dir))
  // console.log("PreLine Angle", vertices.map(v => v.preAngle).map(a => a * 180 / Math.PI))
  // console.log("PostLine Angle", vertices.map(v => v.postAngle).map(a => a * 180 / Math.PI))
  // console.log("InnerAngle", cornerAngle.map(a => a * 180 / Math.PI))
  // console.log(preLineLength)
  // got through the points that define the outside border of the line, and generate
  // offset lines on one side of them (named Line1 and Line2).
  // function findBorderAnglesConstantCornerWidth(
  //   preIndex: Point | null,
  //   midIndex: Point,
  //   postIndex: Point | null,
  // ) {
  //   const post = coords[postIndex];
  //   const mid = coords[midIndex];
  //   const pre = coords[preIndex];
  //   let innerAngle = 0;
  //   let direction = 0;
  //   if (pre != null && post != null) {
  //     const midPost = post.sub(mid).toPolar();
  //     const midPre = pre.sub(mid).toPolar();
  //     const midPostUnit = polarToRect(1, midPost.angle);
  //     const midPreUnit = polarToRect(1, midPre.angle);
  //     innerAngle = midPostUnit.add(midPreUnit).toPolar().angle || 0.00001;
  //     direction = Math.sin(midPost.angle - midPre.angle);
  //   } else if (pre == null && post != null) {
  //     const midPost = post.sub(mid).toPolar();
  //     innerAngle = midPost.angle - Math.PI / 2;
  //     direction = -1;
  //   } else if (post == null && pre != null) {
  //     const midPre = pre.sub(mid).toPolar();
  //     innerAngle = midPre.angle - Math.PI / 2;
  //     direction = 1;
  //   }
  //   let corner1 = polarToRect(width / 2, innerAngle).add(mid);
  //   let corner2 = polarToRect(width / 2, innerAngle + Math.PI).add(mid);
  //   if (direction < 0) {
  //     corner2 = polarToRect(width / 2, innerAngle).add(mid);
  //     corner1 = polarToRect(width / 2, innerAngle + Math.PI).add(mid);
  //   }
  //   border1.push(corner1);
  //   border2.push(corner2);
  // }

  function findBorderAngles(preIndex, midIndex, postIndex) {
    var post = postIndex == null ? null : coords[postIndex];
    var mid = coords[midIndex];
    var pre = preIndex == null ? null : coords[preIndex];
    var innerAngle = 0;
    var cornerR = width / 2;
    var direction = 0;
    var minAngle = 0;

    if (pre != null && post != null) {
      var midPost = post.sub(mid).toPolar();
      var midPre = pre.sub(mid).toPolar();
      var midPostUnit = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(1, midPost.angle);
      var midPreUnit = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(1, midPre.angle);
      innerAngle = midPostUnit.add(midPreUnit).toPolar().angle || 0.00001;
      minAngle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["minAngleDiff"])(midPostUnit.toPolar().angle, midPreUnit.toPolar().angle);
      cornerR = Math.abs(width / 2 / Math.sin(innerAngle - midPost.angle));
      direction = Math.sin(midPost.angle - midPre.angle);
    } else if (pre == null && post != null) {
      var _midPost = post.sub(mid).toPolar();

      innerAngle = _midPost.angle - Math.PI / 2;
      cornerR = Math.abs(width / 2 / Math.sin(innerAngle - _midPost.angle));
      direction = 1;
    } else if (post == null && pre != null) {
      var _midPre = pre.sub(mid).toPolar();

      innerAngle = _midPre.angle - Math.PI / 2 + Math.PI;
      cornerR = Math.abs(width / 2 / Math.sin(innerAngle - _midPre.angle));
      direction = 1;
    } // cornerR = Math.min(cornerR, width * 2)


    var innerRadius = Math.min(cornerR, width * 6);
    var outerRadius = Math.min(cornerR, width * 2);
    var finalInnerRadius = innerRadius;
    var finalOuterRadius = outerRadius;

    if (borderToPoint === 'alwaysOn') {
      finalInnerRadius = innerRadius + outerRadius;
      finalOuterRadius = 0;
    }

    if (borderToPoint === 'onSharpAnglesOnly') {
      finalInnerRadius = innerRadius + outerRadius;
      finalOuterRadius = 0; // const minAngle = minAngleDiff(midPostUnit.angle, midPreUnit.angle);

      var sharpAngleThreshold = Math.PI * 0.9;

      if (Math.abs(minAngle) > sharpAngleThreshold) {
        var percent = Math.sin(Math.abs(minAngle)) / Math.sin(sharpAngleThreshold);
        finalInnerRadius = innerRadius + outerRadius * percent;
        finalOuterRadius = outerRadius * (1 - percent);
      }
    }

    var corner1 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(finalInnerRadius, innerAngle).add(mid);
    var corner2 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(finalOuterRadius, innerAngle + Math.PI).add(mid); // const delta = corner2.sub(mid);
    // // console.log(delta);
    // corner2 = corner2.sub(delta);
    // corner1 = corner1.sub(delta);

    if (direction < 0) {
      corner2 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(finalInnerRadius, innerAngle).add(mid);
      corner1 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(finalOuterRadius, innerAngle + Math.PI).add(mid);
    }

    border1.push(corner1);
    border2.push(corner2);
  } // function findBorderAnglesOutsideVertexFixed(
  //   preIndex: number | null,
  //   midIndex: number,
  //   postIndex: number | null,
  // ) {
  //   if (preIndex != null && postIndex != null) {
  //     const v = vertices[midIndex];
  //     v.pre = vertices[preIndex];
  //     v.post = vertices[postIndex];
  //     const { dir } = v;
  //     let vertex = v.point;
  //     const preDir = vertices[preIndex].dir;
  //     const postDir = vertices[postIndex].dir;
  //     let preBorderAngle = v.preAngle || 0;
  //     let postBorderAngle = v.postAngle || 0;
  //     if (preDir !== dir) {
  //       const midToBorderAngleDelta = Math.asin(width / v.preLength);
  //       preBorderAngle -= dir * midToBorderAngleDelta;
  //     }
  //     if (postDir !== dir) {
  //       const midToBorderAngleDelta = Math.asin(width / v.postLength);
  //       postBorderAngle += dir * midToBorderAngleDelta;
  //     }
  //     let angleDelta = Math.PI / 2;
  //     if (dir === -1) {
  //       angleDelta = -Math.PI / 2;
  //     }
  //     const pointOnPreInnerLine
  //       = vertex.add(polarToRect(width, preBorderAngle + angleDelta));
  //     const preInnerBorderLine = new Line(pointOnPreInnerLine, 1, preBorderAngle);
  //     const pointOnPostInnerLine
  //       = vertex.add(polarToRect(width, postBorderAngle - angleDelta));
  //     const postInnerBorderLine = new Line(pointOnPostInnerLine, 1, postBorderAngle);
  //     const intersection = postInnerBorderLine.intersectsWith(preInnerBorderLine);
  //     const intersectVector = intersection.intersect.sub(vertex).toPolar();
  //     const intersectMag = Math.min(intersectVector.mag, v.preLength, v.postLength);
  //     let innerCoord = vertex.add(polarToRect(intersectMag, intersectVector.angle));
  //     if (Math.abs(v.minAngle) > Math.PI / 2) {
  //       const offset = width / 2 * Math.cos(v.minAngle);
  //       vertex = vertex.add(polarToRect(offset, intersectVector.angle));
  //       innerCoord = innerCoord.add(polarToRect(offset, intersectVector.angle));
  //     }
  //     if (intersectMag < intersectVector.mag) {
  //       if (intersectMag === v.postLength) {
  //         const postBorderLine = new Line(vertex, 1, postBorderAngle);
  //         innerCoord = preInnerBorderLine.intersectsWith(postBorderLine).intersect;
  //       } else {
  //         const preBorderLine = new Line(vertex, 1, preBorderAngle);
  //         innerCoord = postInnerBorderLine.intersectsWith(preBorderLine).intersect;
  //       }
  //     }
  //     if (dir === -1) {
  //       border1.push(vertex);
  //       border2.push(innerCoord);
  //     } else {
  //       border1.push(innerCoord);
  //       border2.push(vertex);
  //     }
  //   }
  // }


  if (close) {
    findBorderAngles(coords.length - 1, 0, 1);
  } else {
    findBorderAngles(null, 0, 1);
  }

  for (var i = 1; i < coords.length - 1; i += 1) {
    findBorderAngles(i - 1, i, i + 1);
  }

  if (close) {
    findBorderAngles(coords.length - 2, coords.length - 1, 0);
  } else {
    findBorderAngles(coords.length - 2, coords.length - 1, null);
  } // for (let i = 0; i < vertices.length; i += 1) {
  //   findCornerPoints(i);
  // }


  var addTriangles = function addTriangles(i1, i2) {
    points.push(border1[i1].x);
    points.push(border1[i1].y);
    points.push(border2[i1].x);
    points.push(border2[i1].y);
    points.push(border2[i2].x);
    points.push(border2[i2].y);
    points.push(border1[i1].x);
    points.push(border1[i1].y);
    points.push(border2[i2].x);
    points.push(border2[i2].y);
    points.push(border1[i2].x);
    points.push(border1[i2].y);
  };

  for (var _i = 0; _i < coords.length - 1; _i += 1) {
    addTriangles(_i, _i + 1);
  }

  if (close) {
    addTriangles(coords.length - 1, 0);
  } // // If the line closes on itself, then find the intersection point of
  // // the first and last offset lines.
  // // p and q will represent the first points of offset lines 1 and 2.
  // if (close) {
  //   // intersection point of first and last offset 1 lines
  //   p = simpleIntersect(
  //     line1Pairs[0][0],
  //     line1Pairs[0][1],
  //     line1Pairs[line1Pairs.length - 1][0],
  //     line1Pairs[line1Pairs.length - 1][1],
  //   );
  //   // intersection point of first and last offset 2 lines
  //   q = simpleIntersect(
  //     line2Pairs[0][0],
  //     line2Pairs[0][1],
  //     line2Pairs[line1Pairs.length - 1][0],
  //     line2Pairs[line2Pairs.length - 1][1],
  //   );
  // } else {
  //   // if not closing on itself, then the first point is simply the first
  //   // point of the offset lines.
  //   p = line1Pairs[0][0];   // eslint-disable-line prefer-destructuring
  //   q = line2Pairs[0][0];   // eslint-disable-line prefer-destructuring
  // }
  // // The line effectively has two borders (named an inside and outside border)
  // // but the inner border isn't necessarily the INSIDE border, it is just a
  // // name.
  // // p and q are the first points of the borders.
  // innerBorder.push(p._dup());
  // outerBorder.push(q._dup());
  // // Go through all offset lines, calculate their intersection points
  // // and from them calculate the triangle and border points.
  // for (let i = 1; i < line1Pairs.length; i += 1) {
  //   // First two points of the Triangle 1 are the two ending points
  //   // of the last line segment
  //   points.push(p.x);
  //   points.push(p.y);
  //   points.push(q.x);
  //   points.push(q.y);
  //   // Next points are the intersection between the first line and the second line
  //   p = simpleIntersect(
  //     line1Pairs[i - 1][0],
  //     line1Pairs[i - 1][1],
  //     line1Pairs[i][0],
  //     line1Pairs[i][1],
  //   );
  //   q = simpleIntersect(
  //     line2Pairs[i - 1][0],
  //     line2Pairs[i - 1][1],
  //     line2Pairs[i][0],
  //     line2Pairs[i][1],
  //   );
  //   // Push the next points to the border
  //   innerBorder.push(p._dup());
  //   outerBorder.push(q._dup());
  //   // Finish triangle 1
  //   points.push(q.x);
  //   points.push(q.y);
  //   // Make triangle 2
  //   points.push(points[points.length - 6]);
  //   points.push(points[points.length - 6]);
  //   points.push(q.x);
  //   points.push(q.y);
  //   points.push(p.x);
  //   points.push(p.y);
  // }
  // // Calculate the last end points
  // let endp;
  // let endq;
  // // In not closing the polyline, the end points are just the last offset
  // // line points
  // if (!close) {
  //   endp = line1Pairs[line1Pairs.length - 1][1]; // eslint-disable-line prefer-destructuring
  //   endq = line2Pairs[line2Pairs.length - 1][1]; // eslint-disable-line prefer-destructuring
  // // If closing the polyline, then the end points are the start points
  // } else {
  //   endp = new Point(points[0], points[1]);
  //   endq = new Point(points[2], points[3]);
  // }
  // // Close out the last two triangles
  // points.push(p.x);             // Last two points of last line segment
  // points.push(p.y);
  // points.push(q.x);
  // points.push(q.y);
  // points.push(endq.x);
  // points.push(endq.y);
  // points.push(p.x);             // Last triangle
  // points.push(p.y);
  // points.push(endq.x);
  // points.push(endq.y);
  // points.push(endp.x);
  // points.push(endp.y);
  // innerBorder.push(endp._dup());
  // outerBorder.push(endq._dup());
  // // If closing, then remove the last duplicate coord as it was added by this
  // // function
  // if (close) {
  //   coords.pop();
  // }
  // function makeOuter(
  //   midPre: Point,
  //   mid: Point,
  //   midPost: Point,
  //   midIndex: number,
  // ) {
  //   const i = midIndex;
  //   const n = i * 12;
  //   const midAngle = threePointAngle(midPre, mid, midPost);
  //   const innerAngle = threePointAngle(midPre, innerBorder[i], midPost);
  //   const outerAngle = threePointAngle(midPre, outerBorder[i], midPost);
  //   const replace = (index, replacementPoint) => {
  //     let normIndex = index;
  //     if (index < 0) {
  //       normIndex += points.length;
  //     }
  //     if (index > points.length - 1) {
  //       normIndex -= points.length;
  //     }
  //     points[normIndex] = replacementPoint.x;
  //     points[normIndex + 1] = replacementPoint.y;
  //   };
  //   const minDistance = Math.min(distance(midPre, mid), distance(midPost, mid));
  //   let newInnerBorder;
  //   let newOuterBorder;
  //   if (innerAngle < midAngle || innerAngle === midAngle) {
  //     newInnerBorder = mid;
  //   }
  //   if (outerAngle < midAngle || outerAngle === midAngle) {
  //     newOuterBorder = mid;
  //   }
  //   if (newOuterBorder) {
  //     replace(n - 4 * 2, newOuterBorder);
  //     replace(n - 2 * 2, newOuterBorder);
  //     replace(n + 1 * 2, newOuterBorder);
  //     outerBorder[i] = newOuterBorder;
  //   }
  //   if (newInnerBorder) {
  //     replace(n - 1 * 2, newInnerBorder);
  //     replace(n, newInnerBorder);
  //     replace(n + 3 * 2, newInnerBorder);
  //     innerBorder[i] = newInnerBorder;
  //   }
  //   let midToBorderVector = innerBorder[i].sub(mid).toPolar();
  //   if (midToBorderVector.mag > minDistance) {
  //     newInnerBorder = mid.add(new Point(
  //       minDistance * Math.cos(midToBorderVector.angle),
  //       minDistance * Math.sin(midToBorderVector.angle),
  //     ));
  //   }
  //   midToBorderVector = outerBorder[i].sub(mid).toPolar();
  //   if (midToBorderVector.mag > minDistance) {
  //     newOuterBorder = mid.add(new Point(
  //       minDistance * Math.cos(midToBorderVector.angle),
  //       minDistance * Math.sin(midToBorderVector.angle),
  //     ));
  //   }
  //   if (newOuterBorder) {
  //     replace(n - 4 * 2, newOuterBorder);
  //     replace(n - 2 * 2, newOuterBorder);
  //     replace(n + 1 * 2, newOuterBorder);
  //     outerBorder[i] = newOuterBorder;
  //   }
  //   if (newInnerBorder) {
  //     replace(n - 1 * 2, newInnerBorder);
  //     replace(n, newInnerBorder);
  //     replace(n + 3 * 2, newInnerBorder);
  //     innerBorder[i] = newInnerBorder;
  //   }
  // }
  // for (let i = 1; i < coords.length - 1; i += 1) {
  //   makeOuter(coords[i - 1], coords[i], coords[i + 1], i);
  // }
  // if (close) {
  //   makeOuter(
  //     coords[line1Pairs.length - 2],
  //     coords[line1Pairs.length - 1],
  //     coords[0],
  //     line1Pairs.length - 1,
  //   );
  //   makeOuter(
  //     coords[line1Pairs.length - 1],
  //     coords[0],
  //     coords[1],
  //     0,
  //   );
  // }
  // // Form the border array


  var border = [];
  var holeBorder = []; // console.log(innerBorder)
  // console.log(outerBorder)
  // If the poly line is closed, only one of the offset lines is the outside
  // border. If open, then both are the border.

  if (close) {
    if (border1[0].isInPolygon(border2)) {
      border = border2;
      holeBorder = border1;
    } else {
      border = border1;
      holeBorder = border2;
    }
  } else {
    border.push(border1[0]);

    for (var _i2 = 0; _i2 < border2.length; _i2 += 1) {
      border.push(border2[_i2]);
    }

    for (var _i3 = border1.length - 1; _i3 >= 0; _i3 -= 1) {
      border.push(border1[_i3]);
    }
  }

  return {
    points: points,
    border: border,
    holeBorder: holeBorder
  };
} // export default polyLineTriangles;

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/Triangles/TRIHoriztonalLine.js":
/*!***********************************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/Triangles/TRIHoriztonalLine.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");


function TRIHorizontalLine() {
  var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;
  var rotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(rotation).translate(start.x, start.y);
  var cx = 0;
  var cy = 0;
  var pList = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx, cy - width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx + length, cy - width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx + length, cy + width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx, cy - width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx + length, cy + width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx, cy + width / 2)];
  var pListTransformed = pList.map(function (p) {
    return p.transformBy(t.matrix());
  });
  var points = [];
  pListTransformed.map(function (p) {
    points.push(p.x);
    points.push(p.y);
    return true;
  });
  var border = [pList[0], pList[1], pList[2], pList[5]];
  return {
    points: points,
    border: border
  };
}

/* harmony default export */ __webpack_exports__["default"] = (TRIHorizontalLine);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/Triangles/TRIParallelLines.js":
/*!**********************************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/Triangles/TRIParallelLines.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");


function TRIParallelLines() {
  var num = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
  var spacing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;
  var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
  var length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.1;
  var width = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.01;
  var logarithmic = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var flip = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  var points = [];
  var border = [];
  var sign = 1;

  if (flip) {
    sign = -1;
  }

  var cy = start.y;

  for (var i = 0; i < num; i += 1) {
    var cx = void 0;

    if (logarithmic) {
      cx = start.x + spacing * Math.floor(i / 10) + Math.log10(i % 10) * spacing;
    } else {
      cx = start.x + spacing * i;
    }

    cx -= width / 2;
    points.push(cx, sign * cy);
    points.push(cx + width, sign * cy);
    points.push(cx + width, sign * (cy + length));
    points.push(cx, cy);
    points.push(cx + width, sign * (cy + length));
    points.push(cx, sign * (cy + length));
    border.push([new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx, sign * cy), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx + width, sign * cy), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx + width, sign * (cy + length)), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx, sign * (cy + length))]);
  }

  return {
    points: points,
    border: border
  };
}

/* harmony default export */ __webpack_exports__["default"] = (TRIParallelLines);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexArrow.js":
/*!*******************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexArrow.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertexArrow =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexArrow, _VertexObject);

  function VertexArrow(webgl) {
    var _this;

    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var legWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var legHeight = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
    var tip = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    var rotation = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;

    _classCallCheck(this, VertexArrow);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexArrow).call(this, webgl));
    _this.glPrimative = _this.gl.TRIANGLE_FAN;
    _this.height = height;
    var arrowHeight = height - legHeight;
    var points = [];
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2, -arrowHeight));

    if (legHeight) {
      points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-legWidth / 2.0, -arrowHeight));
      points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-legWidth / 2.0, -height));
      points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](+legWidth / 2.0, -height));
      points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](+legWidth / 2.0, -arrowHeight));
    }

    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](+width / 2, -arrowHeight));
    var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(rotation).translate(tip);
    var transformedPoints = points.map(function (p) {
      return p.transformBy(t.matrix());
    }); // this.points = [
    //   0, 0,
    //   -width / 2, -arrowHeight,
    //   -legWidth / 2.0, -arrowHeight,
    //   -legWidth / 2.0, -height,
    //   +legWidth / 2.0, -height,
    //   +legWidth / 2.0, -arrowHeight,
    //   +width / 2, -arrowHeight,
    // ];

    transformedPoints.forEach(function (p) {
      _this.points.push(p.x);

      _this.points.push(p.y);

      _this.border[0].push(p);
    }); // for (let i = 0; i < this.points.length; i += 2) {
    //   // this.points[i] += tip.x;
    //   // this.points[i + 1] += tip.y;
    //   this.border[0].push(new Point(this.points[i], this.points[i + 1]));
    // }

    _this.border[0].push(_this.border[0][0]._dup());

    _this.setupBuffer();

    return _this;
  }

  return VertexArrow;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexArrow);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexDashedLine.js":
/*!************************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexDashedLine.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





function makeDash(start, length, width) {
  var p1 = start._dup();

  var p2 = start.add(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, width));
  var p3 = start.add(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](length, width));
  var p4 = start.add(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](length, 0));
  return [p1, p2, p3, p1, p3, p4];
}

var VertexDashedLine =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexDashedLine, _VertexObject);

  function VertexDashedLine(webgl) {
    var _this;

    var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    var maxLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.1;
    var rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var dashStyle = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1];

    _classCallCheck(this, VertexDashedLine);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexDashedLine).call(this, webgl));
    _this.glPrimative = _this.gl.TRIANGLES;
    _this.dashCumLength = [];
    _this.maxLength = maxLength;
    var cx = 0;
    var cy = 0 - width / 2.0;
    var points = [];
    var cumLength = 0;
    var startVertex = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx, cy);
    var isGap = false;

    while (cumLength < maxLength) {
      for (var i = 0; i < dashStyle.length && cumLength < maxLength; i += 1) {
        var length = dashStyle[i];

        if (length + cumLength > maxLength) {
          length = maxLength - cumLength;
        }

        if (!isGap) {
          var dash = makeDash(startVertex, length, width);
          dash.forEach(function (d) {
            points.push(d);
          });
        }

        cumLength += length;
        startVertex.x += length;
        isGap = !isGap;

        _this.dashCumLength.push(cumLength);
      }
    } // rotate points


    var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(rotation).translate(start.x, start.y);
    var transformedPoints = points.map(function (p) {
      return p.transformBy(t.matrix());
    });
    transformedPoints.forEach(function (p) {
      _this.points.push(p.x);

      _this.points.push(p.y);
    }); // const p = this.points;

    _this.border[0] = [transformedPoints[0], transformedPoints[1], transformedPoints[transformedPoints.length - 2], transformedPoints[transformedPoints.length - 1]];

    _this.border[0].push(_this.border[0][0]._dup());

    _this.setupBuffer();

    return _this;
  }

  _createClass(VertexDashedLine, [{
    key: "getPointCountForLength",
    value: function getPointCountForLength() {
      var drawLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.maxLength;

      if (drawLength >= this.maxLength) {
        return this.numPoints;
      }

      if (drawLength < this.dashCumLength[0]) {
        return 0;
      }

      for (var i = 0; i < this.dashCumLength.length; i += 1) {
        var _cumLength = this.dashCumLength[i];

        if (_cumLength > drawLength) {
          return (Math.floor((i - 1) / 2) + 1) * 6;
        }
      }

      return this.numPoints;
    }
  }]);

  return VertexDashedLine;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexDashedLine);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexFan.js":
/*!*****************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexFan.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertextFan =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertextFan, _VertexObject);

  // WebGL primitive used
  // radius from center to outside of polygon
  // center point
  // angle between adjacent verteces to center lines
  function VertextFan(webgl, points) {
    var _this;

    _classCallCheck(this, VertextFan);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertextFan).call(this, webgl));
    _this.glPrimative = webgl.gl.TRIANGLE_FAN;
    _this.points = [];
    points.forEach(function (p) {
      _this.points.push(p.x);

      _this.points.push(p.y);

      _this.border[0].push(p);
    });

    _this.setupBuffer();

    return _this;
  }

  return VertextFan;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertextFan);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexHorizontalLine.js":
/*!****************************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexHorizontalLine.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertexHorizontalLine =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexHorizontalLine, _VertexObject);

  function VertexHorizontalLine(webgl) {
    var _this;

    var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.1;
    var rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

    _classCallCheck(this, VertexHorizontalLine);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexHorizontalLine).call(this, webgl));
    var cx = 0;
    var cy = 0 - width / 2.0;
    var points = [];
    _this.glPrimative = _this.gl.TRIANGLE_STRIP;
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx, cy));
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx, cy + width));
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx + length, cy));
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx + length, cy + width)); // transform points

    var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(rotation).translate(start.x, start.y);
    var transformedPoints = points.map(function (p) {
      return p.transformBy(t.matrix());
    });
    transformedPoints.forEach(function (p) {
      _this.points.push(p.x);

      _this.points.push(p.y);
    });
    _this.border[0] = [transformedPoints[0], transformedPoints[1], transformedPoints[transformedPoints.length - 1], transformedPoints[transformedPoints.length - 2]];

    _this.border[0].push(_this.border[0][0]._dup());

    _this.setupBuffer();

    return _this;
  }

  return VertexHorizontalLine;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexHorizontalLine);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexLines.js":
/*!*******************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexLines.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertexLines =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexLines, _VertexObject);

  function VertexLines(webgl, linePairs) {
    var _this;

    var numLinesThick = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    _classCallCheck(this, VertexLines);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexLines).call(this, webgl));
    _this.glPrimative = _this.gl.LINES;
    _this.points = [];
    linePairs.forEach(function (line) {
      var _line = _slicedToArray(line, 2),
          p = _line[0],
          q = _line[1];

      var angle = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p, q).angle() + Math.PI / 2;
      var spacing = 0.003;
      var startMag = -spacing * (numLinesThick - 1) / 2;

      for (var i = 0; i < numLinesThick; i += 1) {
        var mag = startMag + i * spacing;

        _this.points.push(p.x + mag * Math.cos(angle));

        _this.points.push(p.y + mag * Math.sin(angle));

        _this.points.push(q.x + mag * Math.cos(angle));

        _this.points.push(q.y + mag * Math.sin(angle));
      } // this.points.push(p.x);
      // this.points.push(p.y);
      // this.points.push(q.x);
      // this.points.push(q.y);

    });
    _this.border = [];

    _this.setupBuffer();

    return _this;
  }

  return VertexLines;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexLines);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js":
/*!********************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_m2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/m2 */ "./src/js/tools/m2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _DrawingObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DrawingObject */ "./src/js/diagram/DrawingObjects/DrawingObject.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// import * as g2 from '../g2';



 // Base clase of all shape objects made from verteces for webgl.
// The job of a VertexObject is to:
//  - Have the points of a object/shape
//  - Have the shape's border (used to determine whether a location is
//    within the shape)
//  - Setup the webgl buffer
//  - Draw the shape

var VertexObject =
/*#__PURE__*/
function (_DrawingObject) {
  _inherits(VertexObject, _DrawingObject);

  // shortcut for the webgl context
  // webgl instance for a html canvas
  // primitive tyle (e.g. TRIANGLE_STRIP)
  // Vertex buffer
  // textureBuffer: WebGLBuffer;
  // Primative vertices of shape
  // Number of primative vertices
  // Border vertices
  function VertexObject(webgl) {
    var _this;

    var vertexShader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'simple';
    var fragmentShader = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'simple';

    _classCallCheck(this, VertexObject);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexObject).call(this));
    _this.numPoints = 0;
    _this.gl = webgl.gl;
    _this.webgl = webgl;
    _this.glPrimative = webgl.gl.TRIANGLES;
    _this.points = [];
    _this.z = 0; // this.textureLocation = '';
    // this.texturePoints = [];

    _this.texture = null;
    _this.programIndex = webgl.getProgram(vertexShader, fragmentShader);
    _this.type = 'vertexPrimative';
    return _this;
  }

  _createClass(VertexObject, [{
    key: "addTextureToBuffer",
    value: function addTextureToBuffer(glTexture, image) // image data
    {
      function isPowerOf2(value) {
        // eslint-disable-next-line no-bitwise
        return (value & value - 1) === 0;
      }

      var texture = this.texture;

      if (texture != null) {
        var index = this.webgl.textures[texture.id].index;
        this.gl.activeTexture(this.gl.TEXTURE0 + index);
        this.gl.bindTexture(this.gl.TEXTURE_2D, glTexture);
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, 1);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image); // Check if the image is a power of 2 in both dimensions.

        if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
          // Yes, it's a power of 2. Generate mips.
          this.gl.generateMipmap(this.gl.TEXTURE_2D);
        } else {
          // No, it's not a power of 2. Turn off mips and set wrapping to clamp to edge
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        }
      }
    }
  }, {
    key: "setupBuffer",
    value: function setupBuffer() {
      var _this2 = this;

      var numPoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (numPoints === 0) {
        this.numPoints = this.points.length / 2.0;
      } else {
        this.numPoints = numPoints;
      } // if (this.texture && this.texture.points == null) {
      //   this.texture.points = [];
      //   this.createTextureMap();
      // }


      var texture = this.texture;

      if (texture != null) {
        if (texture.points == null) {
          texture.points = [];
        }

        if (texture.points.length === 0) {
          this.createTextureMap();
        }

        texture.buffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, texture.buffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(texture.points), this.gl.STATIC_DRAW);

        if (!(texture.id in this.webgl.textures) || texture.id in this.webgl.textures && this.webgl.textures[texture.id].glTexture == null) {
          var glTexture = this.gl.createTexture();
          this.webgl.addTexture(texture.id, glTexture, texture.type);
          this.gl.activeTexture(this.gl.TEXTURE0 + this.webgl.textures[texture.id].index);
          this.gl.bindTexture(this.gl.TEXTURE_2D, glTexture);
          var src = texture.src;

          if (src) {
            // Fill the texture with a 1x1 blue pixel.
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 100]));
            var image = new Image();
            image.src = src;
            image.addEventListener('load', function () {
              // Now that the image has loaded make copy it to the texture.
              texture.data = image;

              _this2.addTextureToBuffer(glTexture, texture.data);

              if (_this2.onLoad != null) {
                _this2.onLoad();
              }
            });
          } else if (texture.data != null) {
            this.addTextureToBuffer(glTexture, texture.data);
          }
        }
      }

      this.buffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.points), this.gl.STATIC_DRAW);
    }
  }, {
    key: "resetBuffer",
    value: function resetBuffer() {
      var numPoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var texture = this.texture;

      if (texture) {
        // this.gl.activeTexture(this.gl.TEXTURE0 + texture.index);
        // this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        if (this.webgl.textures[texture.id].glTexture != null) {
          this.gl.deleteTexture(this.webgl.textures[texture.id].glTexture);
          this.webgl.textures[texture.id].glTexture = null;
        }

        this.gl.deleteBuffer(texture.buffer); // texture.glTexture = null;

        texture.buffer = null;
      } // this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);


      this.gl.deleteBuffer(this.buffer);
      this.setupBuffer(numPoints);
    } // eslint-disable-next-line no-unused-vars

  }, {
    key: "change",
    value: function change(coords) {
      this.resetBuffer();
    }
  }, {
    key: "changeVertices",
    value: function changeVertices(coords) {
      var _this3 = this;

      this.points = [];
      this.border = [];
      var minX = null;
      var minY = null;
      var maxX = null;
      var maxY = null;
      coords.forEach(function (p) {
        _this3.points.push(p.x);

        _this3.points.push(p.y);

        if (minX === null || p.x < minX) {
          minX = p.x;
        }

        if (minY === null || p.y < minY) {
          minY = p.y;
        }

        if (maxY === null || p.y > maxY) {
          maxY = p.y;
        }

        if (maxX === null || p.x > maxX) {
          maxX = p.x;
        }
      });

      if (minX != null && minY != null && maxX != null && maxY != null) {
        this.border[0] = [new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](minX, minY), new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](minX, maxY), new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](maxX, maxY), new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](maxX, minY)];
      }

      this.resetBuffer();
    } // Abstract method - should be reimplemented for any vertexObjects that

  }, {
    key: "getPointCountForAngle",
    value: function getPointCountForAngle() {
      var drawAngle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Math.PI * 2;
      return this.numPoints * drawAngle / (Math.PI * 2);
    } // Abstract method - should be reimplemented for any vertexObjects that
    // eslint-disable-next-line no-unused-vars

  }, {
    key: "getPointCountForLength",
    value: function getPointCountForLength(drawLength) {
      return this.numPoints;
    } // A texture map is a texture coords point that lines up with the texture
    // vertex point. So, if the vertex shape is rectangular, centered at the
    // origin and wants to incorporate the entire texture, then the map would
    // be:
    // vertex space            texture space
    // this.points         this.texture.points
    //    -1,  -1,                  0,  0
    //    -1,   1,                  0,  1
    //     1,   1,                  1,  1
    //     1,  -1,                  1,  0

  }, {
    key: "createTextureMap",
    value: function createTextureMap() {
      var xMinGL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      var xMaxGL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var yMinGL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      var yMaxGL = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var xMinTex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var xMaxTex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
      var yMinTex = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var yMaxTex = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1;
      var glWidth = xMaxGL - xMinGL;
      var glHeight = yMaxGL - yMinGL;
      var texWidth = xMaxTex - xMinTex;
      var texHeight = yMaxTex - yMinTex;
      var texture = this.texture;

      if (texture != null) {
        texture.points = [];

        for (var i = 0; i < this.points.length; i += 2) {
          var x = this.points[i];
          var y = this.points[i + 1];
          var texNormX = (x - xMinGL) / glWidth;
          var texNormY = (y - yMinGL) / glHeight;
          texture.points.push(texNormX * texWidth + xMinTex);
          texture.points.push(texNormY * texHeight + yMinTex);
        }
      }
    }
  }, {
    key: "draw",
    value: function draw(translation, rotation, scale, count, color) {
      var transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["identity"]();
      transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["translate"](transformation, translation.x, translation.y);
      transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["rotate"](transformation, rotation);
      transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["scale"](transformation, scale.x, scale.y);
      this.drawWithTransformMatrix(_tools_m2__WEBPACK_IMPORTED_MODULE_0__["t"](transformation), color, count);
    }
  }, {
    key: "drawWithTransformMatrix",
    value: function drawWithTransformMatrix(transformMatrix, color, count) {
      var size = 2; // 2 components per iteration

      var type = this.gl.FLOAT; // the data is 32bit floats

      var normalize = false; // don't normalize the data
      // 0 = move forward size * sizeof(type) each iteration to get
      // the next position

      var stride = 0;
      var offset = 0; // start at the beginning of the buffer

      var locations = this.webgl.useProgram(this.programIndex);

      if (this.texture && this.webgl.textures[this.texture.id].type === 'canvasText') {
        // this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        // this.gl.blendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
      } else {
        this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
      } // Turn on the attribute


      this.gl.enableVertexAttribArray(locations.a_position); // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)

      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer); // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)

      this.gl.vertexAttribPointer(locations.a_position, size, type, normalize, stride, offset);
      this.gl.uniformMatrix3fv(locations.u_matrix, false, _tools_m2__WEBPACK_IMPORTED_MODULE_0__["t"](transformMatrix)); // Translate

      this.gl.uniform1f(locations.u_z, this.z);
      this.gl.uniform4f(locations.u_color, color[0], color[1], color[2], color[3]); // Translate

      var texture = this.texture;

      if (texture != null) {
        // Textures
        // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
        var texSize = 2; // 2 components per iteration

        var texType = this.gl.FLOAT; // the data is 32bit floats

        var texNormalize = false; // don't normalize the data

        var texStride = 0; // 0 = move forward size * sizeof(type) each iteration to get
        // the next position

        var texOffset = 0; // start at the beginning of the buffer

        this.gl.enableVertexAttribArray(locations.a_texcoord);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, texture.buffer);
        this.gl.vertexAttribPointer(locations.a_texcoord, texSize, texType, texNormalize, texStride, texOffset);
      }

      if (texture) {
        this.gl.uniform1i(locations.u_use_texture, 1);
        var index = this.webgl.textures[texture.id].index; // console.log(texture.id, index, this.webgl.textures)

        this.gl.uniform1i(locations.u_texture, index);
      } else {
        this.gl.uniform1i(locations.u_use_texture, 0);
      }

      this.gl.drawArrays(this.glPrimative, offset, count);

      if (texture) {
        this.gl.disableVertexAttribArray(locations.a_texcoord);
      }
    }
  }, {
    key: "transform",
    value: function transform(transformMatrix) {
      for (var i = 0; i < this.points.length; i += 2) {
        var p = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](this.points[i], this.points[i + 1]);
        p = p.transformBy(transformMatrix);
        this.points[i] = p.x;
        this.points[i + 1] = p.y;
      }

      for (var b = 0; b < this.border.length; b += 1) {
        for (var _p = 0; _p < this.border[b].length; _p += 1) {
          this.border[b][_p] = this.border[b][_p].transformBy(transformMatrix);
        }
      }
    } // calcBorder(lastDrawTransformMatrix: Array<number>) {
    //   const glBorders = [];
    //   this.border.forEach(border => {
    //     const glBorder = [];
    //     border.forEach(p => {
    //       glBorder.push(p.transformBy(lastDrawTransformMatrix));
    //     })
    //     glBorders.push(glBorder);
    //   });
    //   return glBorders;
    // }

  }]);

  return VertexObject;
}(_DrawingObject__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexObject);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexPolyLine.js":
/*!**********************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexPolyLine.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
/* harmony import */ var _PolyLineTriangles3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PolyLineTriangles3 */ "./src/js/diagram/DrawingObjects/VertexObject/PolyLineTriangles3.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






var VertexPolyLine =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexPolyLine, _VertexObject);

  function VertexPolyLine(webgl, coords, close, width) {
    var _this;

    var borderToPoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'never';

    _classCallCheck(this, VertexPolyLine);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexPolyLine).call(this, webgl));
    _this.width = width;
    _this.close = close;
    _this.borderToPoint = borderToPoint;

    _this.setupPoints(coords);

    _this.setupBuffer();

    return _this;
  }

  _createClass(VertexPolyLine, [{
    key: "change",
    value: function change(coords) {
      this.setupPoints(coords);
      this.resetBuffer();
    }
  }, {
    key: "setupPoints",
    value: function setupPoints(coords) {
      var lineTriangles = Object(_PolyLineTriangles3__WEBPACK_IMPORTED_MODULE_3__["default"])(coords, this.close, this.width, this.borderToPoint);
      this.points = lineTriangles.points;
      this.border[0] = lineTriangles.border;
      this.holeBorder[0] = lineTriangles.holeBorder;
    }
  }]);

  return VertexPolyLine;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexPolyLine);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexPolyLineCorners.js":
/*!*****************************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexPolyLineCorners.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
/* harmony import */ var _PolyLineTriangles__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PolyLineTriangles */ "./src/js/diagram/DrawingObjects/VertexObject/PolyLineTriangles.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






function cornerLength(coords, length) {
  var forceLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var center = coords[1];
  var ends = [coords[0], coords[2]];
  var points = [];

  for (var i = 0; i < 2; i += 1) {
    var delta = ends[i].sub(center);
    var angle = Math.atan2(delta.y, delta.x);
    var endLength = Math.sqrt(delta.x * delta.x + delta.y * delta.y);

    if (length < endLength || forceLength) {
      endLength = length;
    }

    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](endLength * Math.cos(angle) + center.x, endLength * Math.sin(angle) + center.y));
  }

  points.push(points[1]._dup());
  points[1] = center._dup();
  return points;
}

var PolyLineCorners =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(PolyLineCorners, _VertexObject);

  function PolyLineCorners(webgl, coords, close, length, width) {
    var _this;

    _classCallCheck(this, PolyLineCorners);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PolyLineCorners).call(this, webgl));
    var newCoords = coords.slice();

    if (close) {
      newCoords.push(coords[0]);
      newCoords.push(coords[1]);
    }

    for (var i = 1, j = newCoords.length - 1; i < j; i += 1) {
      var cornerPoints = cornerLength([newCoords[i - 1], newCoords[i], newCoords[i + 1]], length, true);
      var cornerTriangles = Object(_PolyLineTriangles__WEBPACK_IMPORTED_MODULE_3__["default"])(cornerPoints, false, width);

      for (var k = 0, m = cornerTriangles.points.length; k < m; k += 1) {
        _this.points.push(cornerTriangles.points[k]);
      }

      _this.border[i - 1] = [];

      for (var _k = 0, _m = cornerTriangles.border.length; _k < _m; _k += 1) {
        _this.border[i - 1].push(cornerTriangles.border[_k]);
      }
    }

    _this.setupBuffer();

    return _this;
  }

  return PolyLineCorners;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (PolyLineCorners);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexPolygon.js":
/*!*********************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexPolygon.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertexPolygon =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexPolygon, _VertexObject);

  // radius from center to outside of polygon
  // WebGL primitive used
  // outRad: number;       // radius from center to polygon vertex + 1/2 linewidth
  // inRad: number;        // radius from center to polygon vertex - 1/2 linewidth
  // center point
  // angle between adjacent verteces to center lines
  function VertexPolygon(webgl, numSides, // Must be 3 or greater (def: 3 if smaller)
  radius, lineWidth) {
    var _this;

    var rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var center = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    var numSidesToDraw = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : numSides;
    var direction = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1;

    _classCallCheck(this, VertexPolygon);

    // setup webgl stuff
    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexPolygon).call(this, webgl));
    _this.glPrimative = webgl.gl.TRIANGLE_STRIP; // Check potential errors in constructor input

    var sides = numSides;
    var sidesToDraw = Math.floor(numSidesToDraw);

    if (sides < 3) {
      sides = 3;
    }

    if (sidesToDraw < 0) {
      sidesToDraw = 0;
    } else if (sidesToDraw > sides) {
      sidesToDraw = sides;
    } // setup shape geometry


    _this.radius = radius;
    var inRad = radius - lineWidth; // const outRad = radius + lineWidth / 2.0;
    // this.outRad = outRad;
    // this.inRad = inRad;

    _this.center = center;
    _this.dAngle = Math.PI * 2.0 / sides; // Setup shape primative vertices

    var i;
    var j = 0;

    for (i = 0; i <= sidesToDraw; i += 1) {
      _this.points[j] = center.x + inRad * Math.cos(i * _this.dAngle * direction + rotation * direction);
      _this.points[j + 1] = center.y + inRad * Math.sin(i * _this.dAngle * direction + rotation * direction);
      _this.points[j + 2] = center.x + radius * Math.cos(i * _this.dAngle * direction + rotation * direction);
      _this.points[j + 3] = center.y + radius * Math.sin(i * _this.dAngle * direction + rotation * direction);
      j += 4;
    } // Make the encapsulating border


    if (sidesToDraw < sides) {
      for (i = 0; i <= sidesToDraw; i += 1) {
        _this.border[0].push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](center.x + radius * Math.cos(i * _this.dAngle * direction + rotation * direction), center.y + radius * Math.sin(i * _this.dAngle * direction + rotation * direction)));
      }

      for (i = sidesToDraw; i >= 0; i -= 1) {
        _this.border[0].push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](center.x + inRad * Math.cos(i * _this.dAngle * direction + rotation * direction), center.y + inRad * Math.sin(i * _this.dAngle * direction + rotation * direction)));
      }

      _this.border[0].push(_this.border[0][0]._dup());
    } else {
      for (i = 0; i <= sidesToDraw; i += 1) {
        _this.border[0].push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](center.x + radius * Math.cos(i * _this.dAngle * direction + rotation * direction), center.y + radius * Math.sin(i * _this.dAngle * direction + rotation * direction)));
      }
    }

    _this.setupBuffer(); // console.log(this.numPoints);


    return _this;
  }

  _createClass(VertexPolygon, [{
    key: "drawToAngle",
    value: function drawToAngle(offset, rotate, scale, drawAngle, color) {
      var count = Math.floor(drawAngle / this.dAngle) * 2.0 + 2;

      if (drawAngle >= Math.PI * 2.0) {
        count = this.numPoints;
      }

      this.draw(offset, rotate, scale, count, color);
    }
  }, {
    key: "getPointCountForAngle",
    value: function getPointCountForAngle() {
      var drawAngle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Math.PI * 2;
      var count = Math.floor(drawAngle / this.dAngle) * 2.0 + 2;

      if (drawAngle >= Math.PI * 2.0) {
        count = this.numPoints;
      }

      return count;
    }
  }]);

  return VertexPolygon;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexPolygon);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexPolygonFilled.js":
/*!***************************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexPolygonFilled.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var PolygonFilled =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(PolygonFilled, _VertexObject);

  // WebGL primitive used
  // radius from center to outside of polygon
  // center point
  // angle between adjacent verteces to center lines
  function PolygonFilled(webgl, numSides, radius) {
    var _this;

    var rotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var center = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    var numSidesToDraw = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : numSides;
    var textureLocation = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : '';
    var textureCoords = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](0, 0, 1, 1);

    _classCallCheck(this, PolygonFilled);

    if (textureLocation !== '') {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(PolygonFilled).call(this, webgl, 'withTexture', 'withTexture'));
    } else {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(PolygonFilled).call(this, webgl));
    }

    _this.glPrimative = webgl.gl.TRIANGLE_FAN; // Check potential errors in constructor input

    var sides = numSides;
    var sidesToDraw = numSidesToDraw;

    if (sides < 3) {
      sides = 3;
    }

    if (numSidesToDraw < 0) {
      sidesToDraw = 0;
    } else if (numSidesToDraw > sides) {
      sidesToDraw = sides;
    }

    _this.points = [center.x, center.y];
    _this.dAngle = 0;
    _this.radius = radius;
    _this.center = center;
    _this.dAngle = Math.PI * 2.0 / sides;
    var i;
    var j = 2; // let b = 0;
    // Make the encapsulating border

    if (sidesToDraw < sides) {
      _this.border[0].push(center._dup()); // b = 1;

    }

    for (i = 0; i < sidesToDraw + 1; i += 1) {
      _this.points[j] = center.x + radius * Math.cos(i * _this.dAngle + rotation);
      _this.points[j + 1] = center.y + radius * Math.sin(i * _this.dAngle + rotation);

      _this.border[0].push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](_this.points[j], _this.points[j + 1])); // b += 1;


      j += 2;
    }

    if (sidesToDraw < sides) {
      _this.border[0].push(center._dup());
    }

    if (textureLocation) {
      _this.texture = {
        id: textureLocation,
        src: textureLocation,
        type: 'image',
        points: []
      };

      _this.createTextureMap(-_this.radius * 1.01 + center.x, _this.radius * 1.01 + center.x, -_this.radius * 1.01 + center.y, _this.radius * 1.01 + center.y, textureCoords.left, textureCoords.right, textureCoords.bottom, textureCoords.top);
    }

    _this.setupBuffer();

    return _possibleConstructorReturn(_this);
  }

  _createClass(PolygonFilled, [{
    key: "drawToAngle",
    value: function drawToAngle(offset, rotate, scale, drawAngle, color) {
      var count = Math.floor(drawAngle / this.dAngle) * 2.0 + 2;

      if (drawAngle >= Math.PI * 2.0) {
        count = this.numPoints;
      }

      this.draw(offset, rotate, scale, count, color);
    }
  }, {
    key: "getPointCountForAngle",
    value: function getPointCountForAngle() {
      var drawAngle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Math.PI * 2;
      var count = Math.floor(drawAngle / this.dAngle) + 1;

      if (drawAngle >= Math.PI * 2.0) {
        count = this.numPoints;
      }

      return count;
    }
  }]);

  return PolygonFilled;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (PolygonFilled);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexPolygonLine.js":
/*!*************************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexPolygonLine.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertexPolygonLine =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexPolygonLine, _VertexObject);

  // radius from center to outside of polygon
  // WebGL primitive used
  // center point
  // angle between adjacent verteces to center lines
  function VertexPolygonLine(webgl, numSides, // Must be 3 or greater (def: 3 if smaller)
  radius) {
    var _this;

    var rotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var center = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    var numSidesToDraw = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : numSides;
    var direction = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;
    var thickness = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1;

    _classCallCheck(this, VertexPolygonLine);

    // setup webgl stuff
    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexPolygonLine).call(this, webgl));
    _this.glPrimative = webgl.gl.LINES; // Check potential errors in constructor input

    var sides = numSides;
    var sidesToDraw = Math.floor(numSidesToDraw);

    if (sides < 3) {
      sides = 3;
    }

    if (sidesToDraw < 0) {
      sidesToDraw = 0;
    } else if (sidesToDraw > sides) {
      sidesToDraw = sides;
    } // setup shape geometry


    _this.radius = radius; // const inRad = radius - lineWidth;

    _this.center = center;
    _this.dAngle = Math.PI * 2.0 / sides; // const lines = [];

    var points = [];
    var thickPoints = [];

    for (var j = 1; j < thickness; j += 1) {
      thickPoints.push([]);
    }

    for (var i = 0; i <= sidesToDraw; i += 1) {
      var angle = i * _this.dAngle * direction + rotation * direction;
      points.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(radius, angle));

      for (var _j = 1; _j < thickness; _j += 1) {
        thickPoints[_j - 1].push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(radius * (1 - _j * 0.003), angle));
      }
    }

    for (var _i = 1; _i <= sidesToDraw; _i += 1) {
      // lines.push([points[i - 1], points[i]]);
      _this.points.push(points[_i - 1].x);

      _this.points.push(points[_i - 1].y);

      _this.points.push(points[_i].x);

      _this.points.push(points[_i].y);

      for (var _j2 = 1; _j2 < thickness; _j2 += 1) {
        _this.points.push(thickPoints[_j2 - 1][_i - 1].x);

        _this.points.push(thickPoints[_j2 - 1][_i - 1].y);

        _this.points.push(thickPoints[_j2 - 1][_i].x);

        _this.points.push(thickPoints[_j2 - 1][_i].y);
      }
    }

    _this.border[0] = points;

    if (sidesToDraw < sides) {
      _this.border[0].push(center);
    } // for (let i = 1; i <= sidesToDraw; i += 1) {
    //   const lastAngle = (i - 1) * angleStep;
    //   const angle = i * angleStep;
    //   lines.push([polarToRect(1, lastAngle), polarToRect(1, angle)]);
    // }
    // // Setup shape primative vertices
    // let i;
    // let j = 0;
    // for (i = 0; i <= sidesToDraw; i += 1) {
    //   this.points[j] = polarToRect
    //   this.points[j] =
    //     center.x + inRad * Math.cos(i * this.dAngle * direction + rotation * direction);
    //   this.points[j + 1] =
    //     center.y + inRad * Math.sin(i * this.dAngle * direction + rotation * direction);
    //   this.points[j + 2] =
    //     center.x + radius * Math.cos(i * this.dAngle * direction + rotation * direction);
    //   this.points[j + 3] =
    //     center.y + radius * Math.sin(i * this.dAngle * direction + rotation * direction);
    //   j += 4;
    // }
    // // Make the encapsulating border
    // if (sidesToDraw < sides) {
    //   for (i = 0; i <= sidesToDraw; i += 1) {
    //     this.border[0].push(new Point(
    //       center.x + radius * Math.cos(i * this.dAngle * direction + rotation * direction),
    //       center.y + radius * Math.sin(i * this.dAngle * direction + rotation * direction),
    //     ));
    //   }
    //   for (i = sidesToDraw; i >= 0; i -= 1) {
    //     this.border[0].push(new Point(
    //       center.x + inRad * Math.cos(i * this.dAngle * direction + rotation * direction),
    //       center.y + inRad * Math.sin(i * this.dAngle * direction + rotation * direction),
    //     ));
    //   }
    //   this.border[0].push(this.border[0][0]._dup());
    // } else {
    //   for (i = 0; i <= sidesToDraw; i += 1) {
    //     this.border[0].push(new Point(
    //       center.x + radius * Math.cos(i * this.dAngle * direction + rotation * direction),
    //       center.y + radius * Math.sin(i * this.dAngle * direction + rotation * direction),
    //     ));
    //   }
    // }


    _this.setupBuffer(); // console.log(this.numPoints);


    return _this;
  }

  _createClass(VertexPolygonLine, [{
    key: "drawToAngle",
    value: function drawToAngle(offset, rotate, scale, drawAngle, color) {
      var count = Math.floor(drawAngle / this.dAngle) * 2.0 + 2;

      if (drawAngle >= Math.PI * 2.0) {
        count = this.numPoints;
      }

      this.draw(offset, rotate, scale, count, color);
    }
  }, {
    key: "getPointCountForAngle",
    value: function getPointCountForAngle() {
      var drawAngle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Math.PI * 2;
      var numSidesToDraw = Math.floor(drawAngle / this.dAngle) * 2.0;
      var pointCount = numSidesToDraw * 2;

      if (pointCount > this.numPoints) {
        pointCount = this.numPoints;
      } // let count = Math.floor(drawAngle / this.dAngle) * 2.0;
      // if (drawAngle >= Math.PI * 2.0) {
      //   count = this.numPoints;
      // }


      return pointCount;
    }
  }]);

  return VertexPolygonLine;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexPolygonLine);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexRadialLines.js":
/*!*************************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexRadialLines.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertexRadialLines =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexRadialLines, _VertexObject);

  function VertexRadialLines(webgl) {
    var _this;

    var innerRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var outerRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.05;
    var dAngle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Math.PI / 4;
    var maxAngle = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Math.PI * 2;

    _classCallCheck(this, VertexRadialLines);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexRadialLines).call(this, webgl));
    _this.innerRadius = innerRadius;
    _this.outerRadius = outerRadius;
    _this.dAngle = dAngle;
    _this.maxAngle = maxAngle;
    var currentAngle = 0;
    var j = -1;
    var b = -1;
    var referenceLine = [innerRadius, -width / 2.0, outerRadius, -width / 2.0, outerRadius, width / 2.0, innerRadius, -width / 2.0, outerRadius, width / 2.0, innerRadius, width / 2.0];

    while (currentAngle <= maxAngle) {
      for (var i = 0; i < 6; i += 1) {
        var newPoint = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](referenceLine[i * 2], referenceLine[i * 2 + 1]).rotate(currentAngle); // let newPoint = rotate(new coord(referenceLine[i*2],referenceLine[i*2+1]), currentAngle);

        _this.points[j += 1] = newPoint.x;
        _this.points[j += 1] = newPoint.y;
      }

      var radialLineBorder = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](_this.points[j - 11], _this.points[j - 10]), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](_this.points[j - 9], _this.points[j - 8]), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](_this.points[j - 7], _this.points[j - 6]), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](_this.points[j - 1], _this.points[j - 0]), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](_this.points[j - 11], _this.points[j - 10])];
      _this.border[b += 1] = radialLineBorder;
      currentAngle += dAngle;
    }

    _this.setupBuffer();

    return _this;
  }

  _createClass(VertexRadialLines, [{
    key: "drawToAngle",
    value: function drawToAngle(offset, rotate, scale, drawAngle, color) {
      var count = Math.floor(drawAngle / this.dAngle) * 6.0 + 6.0;

      if (drawAngle >= this.maxAngle) {
        count = this.numPoints;
      }

      this.draw(offset, rotate, scale, count, color);
    }
  }, {
    key: "getPointCountForAngle",
    value: function getPointCountForAngle() {
      var drawAngle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Math.PI * 2;
      var count = Math.floor(drawAngle / this.dAngle) * 6.0 + 6;

      if (drawAngle >= Math.PI * 2.0) {
        count = this.numPoints;
      }

      return count;
    }
  }]);

  return VertexRadialLines;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexRadialLines);

/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexRectangleFilled.js":
/*!*****************************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexRectangleFilled.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VertexRectangleFilled; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var VertexRectangleFilled =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexRectangleFilled, _VertexObject);

  function VertexRectangleFilled(webgl, reference) {
    var _this;

    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var cornerRadius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var cornerSides = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 20;

    _classCallCheck(this, VertexRectangleFilled);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexRectangleFilled).call(this, webgl));
    _this.glPrimative = _this.gl.TRIANGLE_FAN;
    var points = [];
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));

    var makeCorner = function makeCorner(radius, sides, rotation, offset) {
      var cornerPoints = [];

      if (radius === 0 || sides <= 1) {
        cornerPoints.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
      } else {
        var step = Math.PI / 2 / sides;

        for (var i = 0; i < sides + 1; i += 1) {
          cornerPoints.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](radius * Math.cos(i * step + rotation) + offset.x, radius * Math.sin(i * step + rotation) + offset.y));
        }
      }

      return cornerPoints;
    };

    var rad = cornerRadius;
    var sides = cornerSides;
    points = [].concat(_toConsumableArray(points), _toConsumableArray(makeCorner(rad, sides, 0, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2 - rad, height / 2 - rad))));
    points = [].concat(_toConsumableArray(points), _toConsumableArray(makeCorner(rad, sides, Math.PI / 2, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2 + rad, height / 2 - rad))));
    points = [].concat(_toConsumableArray(points), _toConsumableArray(makeCorner(rad, sides, Math.PI, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-width / 2 + rad, -height / 2 + rad))));
    points = [].concat(_toConsumableArray(points), _toConsumableArray(makeCorner(rad, sides, Math.PI / 2 * 3, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2 - rad, -height / 2 + rad))));

    if (reference === 'topLeft') {
      points = points.map(function (p) {
        return p.add(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2, -height / 2));
      });
    }

    points.forEach(function (p) {
      _this.points.push(p.x);

      _this.points.push(p.y);
    });

    _this.points.push(_this.points[2]);

    _this.points.push(_this.points[3]);

    _this.border[0] = points.slice(1);

    _this.setupBuffer();

    return _this;
  }

  return VertexRectangleFilled;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/diagram/DrawingObjects/VertexObject/VertexText.js":
/*!******************************************************************!*\
  !*** ./src/js/diagram/DrawingObjects/VertexObject/VertexText.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/diagram/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../tools/math */ "./src/js/tools/math.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





 // import { identity } from '../../../tools/m2';

// type TypeTextOptions = {
//   text: string;
//   size: number;
//   family: string;
//   weight: number;
//   style: 'normal' | 'italic',
//   alignH: 'left' | 'center' | 'right',
//   alignV: 'top' | 'bottom' | 'middle' | 'baseline',
// };
var VertexText =
/*#__PURE__*/
function (_VertexObject) {
  _inherits(VertexText, _VertexObject);

  // WebGL primitive used
  // radius from center to outside of polygon
  // center point
  // angle between adjacent verteces to center lines
  function VertexText(webgl, textOptions) {
    var _this;

    _classCallCheck(this, VertexText);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexText).call(this, webgl, 'withTexture', 'text'));
    _this.glPrimative = webgl.gl.TRIANGLE_FAN;
    var defaultTextOptions = {
      text: 'DEFAULT_TEXT',
      size: '20px',
      // Text in pixels, or in vertex space units.
      family: 'Helvetica',
      style: 'normal',
      weight: 400,
      alignH: 'center',
      alignV: 'alphabetic',
      id: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["generateUniqueId"])('vertexText')
    };
    var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, defaultTextOptions, textOptions);
    _this.size = options.size;
    _this.text = options.text;
    _this.family = options.family;
    _this.alignH = options.alignH;
    _this.alignV = options.alignV;
    _this.style = options.style;
    _this.weight = options.weight;
    _this.canvas = document.createElement('canvas');
    _this.canvas.id = options.id;
    _this.ctx = _this.canvas.getContext('2d');
    _this.texture = {
      id: options.id,
      points: [],
      type: 'canvasText'
    };
    _this.type = 'vertexText';

    _this.drawTextIntoBuffer();

    return _this;
  } // Text is positioned such that the text baseline will be at
  // vertex space y = 0.
  // The border will then cover the ascent and descent of the text.


  _createClass(VertexText, [{
    key: "resizeText",
    value: function resizeText() {
      var _this2 = this;

      var pixelToVertexSpaceScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1, 1);
      var width = this.canvas.width * pixelToVertexSpaceScale.x;
      var height = this.canvas.height * pixelToVertexSpaceScale.y;
      var start = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

      if (this.alignH === 'center') {
        start.x = -width / 2;
      } else if (this.alignH === 'right') {
        start.x = -width;
      }

      if (this.alignV === 'baseline') {
        start.y = -height * 0.25;
      } else if (this.alignV === 'top') {
        start.y = -height;
      } else if (this.alignV === 'middle') {
        start.y = -height / 2;
      }

      var points = [start, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x, start.y + height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x + width, start.y + height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x + width, start.y)];
      this.width = width;
      this.height = height;
      this.calcAscentDescent();
      this.points = [];
      points.forEach(function (point) {
        _this2.points.push(point.x);

        _this2.points.push(point.y);
      });
      this.border = [[new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x, -this.descent), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x, this.ascent), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x + width, this.ascent), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x + width, -this.descent)]];
      var texture = this.texture;

      if (texture != null) {
        texture.points = [0, 0, 0, 1, 1, 1, 1, 0];
        texture.data = this.ctx.canvas;

        if (texture.buffer) {
          this.resetBuffer();
        } else {
          this.setupBuffer();
        }
      }
    }
  }, {
    key: "calcAscentDescent",
    value: function calcAscentDescent() {
      // const aWidth = this.ctx.measureText('a').width;
      // Estimations of FONT ascent and descent for a baseline of "alphabetic"
      var ascent = 0.75;
      var descent = 0;
      var lowAscentRe = /[,.]/g;
      var midAscentRe = /[acemnorsuvwxz*gyq:><;p=]/g;
      var midDecentRe = /[;,$]/g;
      var maxDescentRe = /[gjyqp@Q(){}[\]|]/g;
      var lowAscentMatches = this.text.match(lowAscentRe);

      if (Array.isArray(lowAscentMatches)) {
        if (lowAscentMatches.length === this.text.length) {
          ascent = 0.1;
        }
      }

      var midAscentMatches = this.text.match(midAscentRe);

      if (Array.isArray(midAscentMatches)) {
        if (midAscentMatches.length === this.text.length) {
          ascent = 0.5;
        }
      }

      var midDescentMatches = this.text.match(midDecentRe);

      if (Array.isArray(midDescentMatches)) {
        if (midDescentMatches.length > 0) {
          descent = 0.1;
        }
      }

      var maxDescentMatches = this.text.match(maxDescentRe);

      if (Array.isArray(maxDescentMatches)) {
        if (maxDescentMatches.length > 0) {
          descent = 0.25;
        }
      }

      this.ascent = ascent * this.height;
      this.descent = descent * this.height;
    } // If font size is defined in pixels, then the size will always be the size
    // in pixels independent of how the diagram window or scaling changes
    // If the font size is defined in vertex space units, then the font size
    // will always be scaled to look like the vertex space size, but a new canvas
    // will be drawn each time to minimize aliasing.

  }, {
    key: "drawTextIntoBuffer",
    value: function drawTextIntoBuffer() {
      var pixelToVertexSpaceScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1, 1);
      var pixelFontSize = 20;

      if (typeof this.size === 'string' && this.size.endsWith('px')) {
        pixelFontSize = parseInt(this.size, 10);
      } else {
        var diagramFontSize;

        if (typeof this.size === 'string') {
          diagramFontSize = parseFloat(this.size);
        } else {
          diagramFontSize = this.size;
        }

        pixelFontSize = Object(_tools_math__WEBPACK_IMPORTED_MODULE_4__["round"])(diagramFontSize / pixelToVertexSpaceScale.x, 0);
      }

      if (pixelFontSize < 1) {
        pixelFontSize = 1;
      }

      this.ctx.font = "".concat(this.style, " ").concat(this.weight, " ").concat(pixelFontSize, "px ").concat(this.family);
      var hBuffer = 0.3;
      var width = this.ctx.measureText(this.text).width + pixelFontSize * hBuffer;
      var height = pixelFontSize * 1.15;
      this.canvas.width = Math.max(width, 1);
      this.canvas.height = Math.max(height, 1);
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // need to reset font after a canvas resize

      this.ctx.font = "".concat(this.style, " ").concat(this.weight, " ").concat(pixelFontSize, "px ").concat(this.family);
      this.ctx.textAlign = 'left';
      this.ctx.textBaseline = 'alphabetic'; // this.ctx.fillStyle = 'white';

      this.ctx.fillStyle = 'white'; // this.ctx.fillStyle = 'rgba(200,200,200,255)';   // debug only
      // this.ctx.fillStyle = 'blue';

      var startX = pixelFontSize * hBuffer / 2;
      var baselineHeightFromBottom = 0.25;
      var startY = this.canvas.height * (1 - baselineHeightFromBottom);
      this.ctx.fillText(this.text, startX, startY);
      this.resizeText(pixelToVertexSpaceScale);
    }
  }]);

  return VertexText;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexText);

/***/ }),

/***/ "./src/js/diagram/Element.js":
/*!***********************************!*\
  !*** ./src/js/diagram/Element.js ***!
  \***********************************/
/*! exports provided: DiagramElementPrimative, DiagramElementCollection, DiagramElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagramElementPrimative", function() { return DiagramElementPrimative; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagramElementCollection", function() { return DiagramElementCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagramElement", function() { return DiagramElement; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_m2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/m2 */ "./src/js/tools/m2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DrawingObjects/HTMLObject/HTMLObject */ "./src/js/diagram/DrawingObjects/HTMLObject/HTMLObject.js");
/* harmony import */ var _DrawingObjects_DrawingObject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DrawingObjects/DrawingObject */ "./src/js/diagram/DrawingObjects/DrawingObject.js");
/* harmony import */ var _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DrawingObjects/VertexObject/VertexObject */ "./src/js/diagram/DrawingObjects/VertexObject/VertexObject.js");
/* harmony import */ var _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DrawingObjects/TextObject/TextObject */ "./src/js/diagram/DrawingObjects/TextObject/TextObject.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _tools_color__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tools/color */ "./src/js/tools/color.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./DrawContext2D */ "./src/js/diagram/DrawContext2D.js");
/* harmony import */ var _Animation_Animation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Animation/Animation */ "./src/js/diagram/Animation/Animation.js");
/* harmony import */ var _AnimationPhase__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./AnimationPhase */ "./src/js/diagram/AnimationPhase.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }









 // import GlobalAnimation from './webgl/GlobalAnimation';


 // eslint-disable-next-line import/no-cycle



function checkCallback(callback) {
  var callbackToUse = function callbackToUse() {};

  if (typeof callback === 'function') {
    callbackToUse = callback;
  }

  return callbackToUse;
}

// A diagram is composed of multiple diagram elements.
//
// A diagram element can either be a:
//  - Primative: a basic element that has the webGL vertices, color
//  - Collection: a group of elements (either primatives or collections)
//
// A diagram element can be:
//  - transformed (resized, offset, rotated)
//  - animated (planned transform over time)
//  - moved with control (like dragging)
//  - moving freely (dragged then let go with an initial velocity)
//  - Pulsed
//
// This class manages:
//  - The diagram element
//  - Its current transformation
//  - Its animation plan, animation control and animation state
//  - Its movement state
//  - Its pulsing parameters
//
// A diagram element has an associated persistant transform that describes how
// to draw it. The transform includes any translation, rotation and/or scaling
// the element should be transformed by before drawing.
//
// If the diagram element is a collection of elements, then this transform is
// applied to all the child elements. Each child element will have it's own
// transform as well, and it will be multiplied by the parent transform.
//
// Whenever an element animated or moved, it's persistant transform is updated.
//
// Pulsing does not update an element's persistant transform, but does alter
// the element's current transform used for drawing itself and any children
// elements it has.
//
var DiagramElement =
/*#__PURE__*/
function () {
  // Transform of diagram element
  // presetTransforms: Object;       // Convenience dict of transform presets
  // Transform matrix used in last draw
  // lastDrawParentTransform: Transform;
  // lastDrawElementTransform: Transform;
  // lastDrawPulseTransform: Transform;
  // True if should be shown in diagram
  // Used to reference element in a collection
  // Element is able to be moved
  // Element can be touched
  // Touch event is not processed by Diagram
  // Callbacks
  // element.transform is updated
  // For the future when collections use color
  // this is in vertex space
  // Current animation/movement state of element
  // Pulse animation state
  // Rename to animate in future
  // This will scale and position this element such that the center of the
  // diagram limits will will look like it is centered on a html element
  // when this figurone element is drawn.
  // Scale can be:
  //  1em: diagram units will be scaled so 0.2 diagram units (default
  //       font size) looks like 1em of the element font size in pixels
  //  100px: diagram units will be scaled so that the max diagram limit
  //         with be the pixel count
  //  stretch: diagram units be stretched so diagram limits extend to
  //           element dimensions independently in x and y
  //  max: -1 to 1 diagram units will be scaled to max dimension of element
  //  fit: diagram units will be scaled so that diagram limits aspect ratio
  //       fits within the element aspect ratio
  //  '': defaults to fit keeping aspect ratio.
  // tieToHTMLElement: string | null | HTMLElement;
  // // Can be:
  // //  1em: diagram units will be scaled so 0.2 diagram units (default
  // //       font size) looks like 1em of the element font size in pixels
  // //  100px: diagram units will be scaled so that the max diagram limit
  // //         with be the pixel count
  // //  stretch: diagram units be stretched so diagram limits extend to
  // //           element dimensions independently in x and y
  // //  max: -1 to 1 diagram units will be scaled to max dimension of element
  // //  fit: diagram units will be scaled so that diagram limits aspect ratio
  // //       fits within the element aspect ratio
  // //  '': defaults to fit
  // // keeping aspect ratio.
  // tieToHTMLElementScale: string;
  // tieToHTMLElementScaleLimits: Rect;
  function DiagramElement() {
    var _this = this;

    var transform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
    var diagramLimits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2);
    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, DiagramElement);

    this.name = ''; // This is updated when an element is added to a collection

    this.uid = (Math.random() * 1e18).toString(36);
    this.isShown = true;
    this.transform = transform._dup();
    this.isMovable = false;
    this.isTouchable = false;
    this.isInteractive = false;
    this.hasTouchableElements = false;
    this.color = [1, 1, 1, 1];

    this.setTransformCallback = function () {};

    this.lastDrawTransform = this.transform._dup();
    this.onClick = null;
    this.lastDrawElementTransformPosition = {
      parentCount: 0,
      elementCount: 0
    };
    this.parent = parent;
    this.drawPriority = 1;
    this.noRotationFromParent = false; // Rename to animate in future

    this.anim = {
      rotation: function rotation() {
        for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
          optionsIn[_key] = arguments[_key];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_10__["RotationAnimationStep"](options);
      },
      scale: function scale() {
        for (var _len2 = arguments.length, optionsIn = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          optionsIn[_key2] = arguments[_key2];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_10__["ScaleAnimationStep"](options);
      },
      position: function position() {
        for (var _len3 = arguments.length, optionsIn = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          optionsIn[_key3] = arguments[_key3];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_10__["PositionAnimationStep"](options);
      },
      color: function color() {
        for (var _len4 = arguments.length, optionsIn = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          optionsIn[_key4] = arguments[_key4];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, {
          elements: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_10__["ColorAnimationStep"](options);
      },
      opacity: function opacity() {
        for (var _len5 = arguments.length, optionsIn = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          optionsIn[_key5] = arguments[_key5];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, {
          elements: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_10__["OpacityAnimationStep"](options);
      },
      transform: function transform() {
        for (var _len6 = arguments.length, optionsIn = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          optionsIn[_key6] = arguments[_key6];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_10__["TransformAnimationStep"](options);
      },
      pulse: function pulse() {
        for (var _len7 = arguments.length, optionsIn = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          optionsIn[_key7] = arguments[_key7];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, {
          element: this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_10__["PulseAnimationStep"](options);
      },
      // eslint-disable-next-line max-len
      dissolveIn: function dissolveIn() {
        var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var defaultOptions = {
          element: _this
        };
        var options;

        for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
          args[_key8 - 1] = arguments[_key8];
        }

        if (typeof timeOrOptionsIn === 'number') {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, defaultOptions, {
            duration: timeOrOptionsIn
          }].concat(args));
        } else {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
        }

        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_10__["DissolveInAnimationStep"](options);
      },
      // eslint-disable-next-line max-len
      dissolveOut: function dissolveOut() {
        var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var defaultOptions = {
          element: _this
        };
        var options;

        for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
          args[_key9 - 1] = arguments[_key9];
        }

        if (typeof timeOrOptionsIn === 'number') {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, defaultOptions, {
            duration: timeOrOptionsIn
          }].concat(args));
        } else {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
        }

        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_10__["DissolveOutAnimationStep"](options);
      },
      // eslint-disable-next-line max-len
      builder: function builder() {
        for (var _len10 = arguments.length, optionsIn = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
          optionsIn[_key10] = arguments[_key10];
        }

        return _construct(_Animation_Animation__WEBPACK_IMPORTED_MODULE_10__["AnimationBuilder"], [_this].concat(optionsIn));
      },
      // eslint-disable-next-line max-len
      scenario: function scenario() {
        var defaultOptions = {
          element: _this
        };

        for (var _len11 = arguments.length, optionsIn = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
          optionsIn[_key11] = arguments[_key11];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));

        if (options.target != null && options.target in options.element.scenarios) {
          var target = options.element.getScenarioTarget(options.target);
          options.target = target;
        }

        if (options.start != null && options.start in options.element.scenarios) {
          var start = options.element.getScenarioTarget(options.start);
          options.start = start;
        }

        if (options.delta != null && options.delta in options.element.scenarios) {
          var delta = options.element.getScenarioTarget(options.delta);
          options.delta = delta;
        }

        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_10__["TransformAnimationStep"](options);
      }
    };
    this.animate = {
      color: {
        plan: [],
        toDisolve: '',
        callback: null
      },
      transform: {
        plan: [],
        translation: {
          style: 'linear',
          options: {
            rot: 1,
            magnitude: 0.5,
            offset: 0.5,
            controlPoint: null,
            direction: ''
          }
        },
        callback: null
      },
      custom: {
        plan: [],
        callback: null
      }
    };
    this.diagramLimits = diagramLimits;
    this.move = {
      maxTransform: this.transform.constant(1000),
      minTransform: this.transform.constant(-1000),
      limitToDiagram: false,
      maxVelocity: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["TransformLimit"](5, 5, 5),
      freely: {
        zeroVelocityThreshold: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["TransformLimit"](0.001, 0.001, 0.001),
        deceleration: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["TransformLimit"](5, 5, 5)
      },
      bounce: true,
      canBeMovedAfterLoosingTouch: false,
      type: 'translation',
      element: null,
      limitLine: null
    };
    this.scenarios = {};
    this.pulse = {
      time: 1,
      frequency: 0.5,
      A: 1,
      B: 0.5,
      C: 0,
      style: _tools_math__WEBPACK_IMPORTED_MODULE_2__["sinusoid"],
      num: 1,
      transformMethod: function transformMethod(s) {
        return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(s, s);
      },
      callback: function callback() {}
    };
    this.state = {
      isAnimating: false,
      isAnimatingColor: false,
      isAnimatingCustom: false,
      disolving: '',
      animation: {
        currentPhaseIndex: 0,
        // current animation phase index in plan
        currentPhase: new _AnimationPhase__WEBPACK_IMPORTED_MODULE_11__["AnimationPhase"]() // current animation phase

      },
      colorAnimation: {
        currentPhaseIndex: 0,
        // current animation phase index in plan
        currentPhase: new _AnimationPhase__WEBPACK_IMPORTED_MODULE_11__["ColorAnimationPhase"]() // current animation phase

      },
      customAnimation: {
        currentPhaseIndex: 0,
        // current animation phase index in plan
        currentPhase: new _AnimationPhase__WEBPACK_IMPORTED_MODULE_11__["CustomAnimationPhase"](function () {}) // current animation phase

      },
      isBeingMoved: false,
      isMovingFreely: false,
      movement: {
        previousTime: -1,
        previousTransform: this.transform._dup(),
        velocity: this.transform.zero()
      },
      isPulsing: false,
      pulse: {
        startTime: -1
      }
    };
    this.interactiveLocation = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    this.animations = new _Animation_Animation__WEBPACK_IMPORTED_MODULE_10__["AnimationManager"](this);
    this.tieToHTML = {
      element: null,
      scale: 'fit',
      window: this.diagramLimits
    }; // this.tieToHTMLElement = null;
    // this.tieToHTMLElementScale = 'fit';
    // this.tieToHTMLElementScaleLimits = this.diagramLimits;
    // this.presetTransforms = {};
  }

  _createClass(DiagramElement, [{
    key: "setProperties",
    value: function setProperties(properties) {
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_7__["joinObjects"])(this, properties);
    } // copyFrom(element: Object) {
    //   const copyValue = (value) => {
    //     if (typeof value === 'number'
    //         || typeof value === 'boolean'
    //         || typeof value === 'string'
    //         || value == null
    //         || typeof value === 'function') {
    //       return value;
    //     }
    //     if (typeof value._dup === 'function') {
    //       return value._dup();
    //     }
    //     // if (value instanceof AnimationPhase
    //     //     || value instanceof ColorAnimationPhase
    //     //     || value instanceof CustomAnimationPhase
    //     //     // eslint-disable-next-line no-use-before-define
    //     //     || value instanceof DiagramElementCollection
    //     //     // eslint-disable-next-line no-use-before-define
    //     //     || value instanceof DiagramElementPrimative
    //     //     || value instanceof DrawingObject
    //     //     || value instanceof Transform
    //     //     || value instanceof Point
    //     //     || value instanceof Rect
    //     //     || value instanceof TransformLimit) {
    //     //   return value._dup();
    //     // }
    //     if (Array.isArray(value)) {
    //       const arrayCopy = [];
    //       value.forEach(arrayElement => arrayCopy.push(copyValue(arrayElement)));
    //       return arrayCopy;
    //     }
    //     if (typeof value === 'object') {
    //       const objectCopy = {};
    //       Object.keys(value).forEach((key) => {
    //         const v = copyValue(value[key]);
    //         objectCopy[key] = v;
    //       });
    //       return objectCopy;
    //     }
    //     return value;
    //   };
    //   Object.keys(element).forEach((key) => {
    //     // $FlowFixMe
    //     this[key] = copyValue(element[key]);
    //   });
    // }
    // Space definition:
    //   * Pixel space: css pixels
    //   * GL Space: x,y = -1 to 1
    //   * Diagram Space: x,y = diagram limits
    //   * Element space: Combination of element transform and its
    //     parent transform's
    // A diagram element primative vertex object lives in GL SPACE.
    //
    // A diagram element has its own DIAGRAM ELEMENT SPACE, which is
    // the GL space transformed by `this.transform`.
    //
    // A diagram element is drawn in the DIAGRAM SPACE, by transforming
    // the DIAGRAM ELEMENT SPACE by an incoming transformation matrix in the draw
    // method. This incoming transformation matrix originates in the diagram
    // and waterfalls through each parent diagram collection element to the
    // current diagram element.
    //
    // this.lastDrawTransformationMatrix captures how a vertex was drawn in
    // the last frame, in DIAGRAM space as:
    //   vertex
    //     transformed by: DIAGRAM ELEMENT SPACE
    //     transfromed by: DIAGRAM SPACE transform
    //
    // By default, webgl clip space is a unit space from (-1, 1) to (1, 1)
    // independent of the aspect ratio of the canvas it is drawn on.
    //
    // A diagram object can have its own clip space with arbitrary limits. e.g.:
    //    * (-1, -1) to (1, 1)    similar to gl clip space
    //    * (0, 0) to (2, 2)      similar to gl clip space but offset
    //    * (0, 0) to (4, 2)      for rectangular aspect ratio diagram
    //
    // The diagram object clip space definition is stored in this.diagramLimits.
    //
    // To therefore transform a vertex (from GL SPACE) to DIAGRAM CLIP SPACE:
    //   * Take the vertex
    //   * Transform it to DIAGRAM SPACE (by transforming it with the
    //     lastDrawTransformMatrix)
    //   * Transform it to DIAGRAM CLIP SPACE by scaling and offsetting it
    //     to the clip space.
    //
    // Each diagram element holds a DIAGRAM ELMENT CLIP space
    // vertexToClip(vertex: Point) {
    //   const scaleX = this.diagramLimits.width / 2;
    //   const scaleY = this.diagramLimits.height / 2;
    //   const biasX = -(-this.diagramLimits.width / 2 - this.diagramLimits.left);
    //   const biasY = -(this.diagramLimits.height / 2 - this.diagramLimits.top);
    //   const transform = new Transform().scale(scaleX, scaleY).translate(biasX, biasY);
    //   return vertex.transformBy(this.lastDrawTransformMatrix)
    //     .transformBy(transform.matrix());
    // }
    // textVertexToClip(vertex: Point) {
    //   const scaleX = this.diagramLimits.width / 2;
    //   const scaleY = this.diagramLimits.height / 2;
    //   const biasX = -(-this.diagramLimits.width / 2 - this.diagramLimits.left);
    //   const biasY = -(this.diagramLimits.height / 2 - this.diagramLimits.top);
    //   const transform = new Transform().scale(scaleX, scaleY).translate(biasX, biasY);
    //   return vertex.transformBy(transform.matrix());
    // }

  }, {
    key: "updateHTMLElementTie",
    value: function updateHTMLElementTie(diagramCanvas) {
      // First get the HTML element
      var tieToElement;

      if (typeof this.tieToHTML.element === 'string') {
        tieToElement = document.getElementById(this.tieToHTML.element);
      } else if (this.tieToHTML.element instanceof HTMLElement) {
        tieToElement = this.tieToHTML.element;
      }

      if (tieToElement != null) {
        var tie = tieToElement.getBoundingClientRect();
        var canvas = diagramCanvas.getBoundingClientRect();
        var diagram = this.diagramLimits;
        var dWindow = this.tieToHTML.window;
        var cAspectRatio = canvas.width / canvas.height;
        var dAspectRatio = diagram.width / diagram.height;
        var tAspectRatio = tie.width / tie.height;
        var wAspectRatio = dWindow.width / dWindow.height;
        var topLeftPixels = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tie.left - canvas.left, tie.top - canvas.top);
        var bottomRightPixels = topLeftPixels.add(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tie.width, tie.height));
        var pixelToDiagram = this.diagramTransforms.pixelToDiagram;
        var topLeft = topLeftPixels.transformBy(pixelToDiagram.m());
        var bottomRight = bottomRightPixels.transformBy(pixelToDiagram.m());
        var width = bottomRight.x - topLeft.x;
        var height = topLeft.y - bottomRight.y;
        var center = topLeft.add(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2, -height / 2));
        var scaleString = this.tieToHTML.scale.trim().toLowerCase();
        var scaleX = 1;
        var scaleY = 1;
        var diagramToWindowScaleX = diagram.width / dWindow.width;
        var diagramToWindowScaleY = diagram.height / dWindow.height; // Window has no scaling impact on em, it only has impact on translation

        if (scaleString.endsWith('em')) {
          var scale = parseFloat(scaleString);
          var em = parseFloat(getComputedStyle(tieToElement).fontSize); // 0.2 is default font size in diagram units

          var defaultFontScale = diagram.width / 0.2;
          scaleX = scale * em * defaultFontScale / canvas.width;
          scaleY = scale * em * defaultFontScale / dAspectRatio / canvas.height;
        } // Scale the maximum dimension of the window to the pixel value


        if (scaleString.endsWith('px')) {
          var maxPixels = parseFloat(scaleString);

          if (wAspectRatio > 1) {
            var _scale = maxPixels / canvas.width;

            scaleX = _scale * diagramToWindowScaleX;
            scaleY = _scale * cAspectRatio / dAspectRatio * diagramToWindowScaleX;
          } else {
            var _scale2 = maxPixels / canvas.height;

            scaleX = _scale2 / cAspectRatio * dAspectRatio * diagramToWindowScaleY;
            scaleY = _scale2 * diagramToWindowScaleY;
          }
        } // Scale the window x to tie x, and window y to tie y


        if (scaleString === 'stretch') {
          scaleX = tie.width / canvas.width * diagramToWindowScaleX;
          scaleY = tie.height / canvas.height * diagramToWindowScaleY;
        } // Scale so window either fits within the tie element, or fits only
        // within the max dimension of the tie element


        if (scaleString === 'max' || scaleString === 'fit') {
          var fitHeightScale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tie.height / canvas.height / cAspectRatio * dAspectRatio * diagramToWindowScaleY, tie.height / canvas.height * diagramToWindowScaleY);
          var fitWidthScale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tie.width / canvas.width * diagramToWindowScaleX, tie.width / canvas.width * cAspectRatio / dAspectRatio * diagramToWindowScaleX);

          if (scaleString === 'max' && tAspectRatio > wAspectRatio || scaleString === 'fit' && tAspectRatio < wAspectRatio) {
            scaleX = fitWidthScale.x;
            scaleY = fitWidthScale.y;
          } else {
            scaleX = fitHeightScale.x;
            scaleY = fitHeightScale.y;
          }
        }

        this.setScale(scaleX, scaleY); // Offset the element relative to the tie

        this.setPosition(center.x - scaleX * (this.tieToHTML.window.left + this.tieToHTML.window.width / 2), center.y - scaleY * (this.tieToHTML.window.bottom + this.tieToHTML.window.height / 2));
        this.setFirstTransform(this.getParentLastDrawTransform());
      }
    } // eslint-disable-next-line no-unused-vars, class-methods-use-this

  }, {
    key: "setFirstTransform",
    value: function setFirstTransform(parentTransform) {} // Calculate the next transform due to a progressing animation

  }, {
    key: "calcNextAnimationTransform",
    value: function calcNextAnimationTransform(elapsedTime) {
      var phase = this.state.animation.currentPhase; // This flow error cannot happen as start is un-nulled in the phase start
      // $FlowFixMe

      var start = phase.startTransform._dup();

      var delta = phase.deltaTransform._dup();

      var percentTime = elapsedTime / phase.time;
      var percentComplete = phase.animationStyle(percentTime);
      var p = percentComplete; // let next = delta._dup().constant(p);
      // next = start.add(delta.mul(next));

      var next = start.toDelta(delta, p, phase.translationStyle, phase.translationOptions);
      return next;
    }
  }, {
    key: "calcNextAnimationColor",
    value: function calcNextAnimationColor(elapsedTime) {
      var phase = this.state.colorAnimation.currentPhase;
      var start = phase.startColor;
      var delta = phase.deltaColor;
      var percentTime = elapsedTime / phase.time;
      var percentComplete = phase.animationStyle(percentTime);
      var p = percentComplete;
      var next = [0, 0, 0, 1];

      if (start != null) {
        next = start.map(function (c, index) {
          return c + delta[index] * p;
        });
      }

      return next;
    }
  }, {
    key: "calcNextCustomAnimationPercentComplete",
    value: function calcNextCustomAnimationPercentComplete(elapsedTime) {
      var phase = this.state.customAnimation.currentPhase;
      var percentTime = elapsedTime / phase.time;
      var percentComplete = phase.animationStyle(percentTime);
      return percentComplete;
    }
  }, {
    key: "setPosition",
    value: function setPosition(pointOrX) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var position = pointOrX;

      if (typeof pointOrX === 'number') {
        position = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](pointOrX, y);
      }

      var currentTransform = this.transform._dup();

      currentTransform.updateTranslation(position);
      this.setTransform(currentTransform);
    }
  }, {
    key: "setRotation",
    value: function setRotation(rotation) {
      var currentTransform = this.transform._dup();

      currentTransform.updateRotation(rotation);
      this.setTransform(currentTransform);
    }
  }, {
    key: "setScale",
    value: function setScale(scaleOrX) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var scale = scaleOrX;

      if (typeof scaleOrX === 'number') {
        if (y == null) {
          scale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](scaleOrX, scaleOrX);
        } else {
          scale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](scaleOrX, y);
        }
      }

      var currentTransform = this.transform._dup();

      currentTransform.updateScale(scale);
      this.setTransform(currentTransform);
    } // Use this method to set the element's transform in case a callback has been
    // connected that is tied to an update of the transform.

  }, {
    key: "setTransform",
    value: function setTransform(transform) {
      this.transform = transform._dup().clip(this.move.minTransform, this.move.maxTransform, this.move.limitLine);

      if (this.setTransformCallback) {
        this.setTransformCallback(this.transform);
      }
    } // Deprecate
    // Set the next transform (and velocity if moving freely) for the next
    // animation frame.
    //
    // If animating, this transform will be the next frame determined by
    // the currently executing animation phase. If time exceeds the current
    // phase, then either the next phase will be started, or if there are no
    // more phases, the animation will complete.
    //
    // If moving freely, this method will set the next velocity and transform
    // based on the current velocity, current transform, elapsed time,
    // deceleration (in freelyProperties) and zeroVelocityThreshold.
    // Once the velocity goes to zero, this metho will stop the element moving
    // freely.

  }, {
    key: "setNextTransform",
    value: function setNextTransform(now) {
      // If animation is happening
      if (this.state.isAnimating) {
        var phase = this.state.animation.currentPhase; // If an animation hasn't yet started, the start time will be -1.
        // If this is so, then set the start time to the current time and
        // return the current transform.

        if (phase.startTime < 0) {
          phase.startTime = now;
          return;
        } // If we have got here, that means the animation has already started,
        // so calculate the time delta between now and the startTime


        var deltaTime = now - phase.startTime; // If this time delta is larger than the phase's planned time, then
        // either progress to the next animation phase, or end animation.

        if (deltaTime > phase.time) {
          // If there are more animation phases in the plan:
          //   - set the current transform to be the end of the current phase
          //   - start the next phase
          if (this.state.animation.currentPhaseIndex < this.animate.transform.plan.length - 1) {
            // Set current transform to the end of the current phase
            phase.finish(this); // this.setTransform(this.calcNextAnimationTransform(phase.time));
            // Get the amount of time that has elapsed in the next phase

            var nextPhaseDeltaTime = deltaTime - phase.time; // Start the next animation phase

            this.state.animation.currentPhaseIndex += 1;
            this.animatePhase(this.state.animation.currentPhaseIndex);
            this.state.animation.currentPhase.startTime = now - nextPhaseDeltaTime;
            this.setNextTransform(now);
            return;
          } // Note, stopAnimating will finish the last phase


          this.stopAnimating(false);
          return;
        } // If we are here, that means the time elapsed is not more than the
        // current animation phase plan time, so calculate the next transform.


        this.setTransform(this.calcNextAnimationTransform(deltaTime));
        return;
      } // If the element is moving freely, then calc it's next velocity and
      // transform. Save the new velocity into state.movement and return the
      // transform.


      if (this.state.isMovingFreely) {
        // If this is the first frame of moving freely, then record the current
        // time so can calculate velocity on next frame
        if (this.state.movement.previousTime < 0) {
          this.state.movement.previousTime = now;
          return;
        } // If got here, then we are now after the first frame, so calculate
        // the delta time from this frame to the previous


        var _deltaTime = now - this.state.movement.previousTime; // Calculate the new velocity and position


        var next = this.decelerate(_deltaTime);
        this.state.movement.velocity = next.velocity;
        this.state.movement.previousTime = now; // If the velocity is 0, then stop moving freely and return the current
        // transform

        if (this.state.movement.velocity.isZero()) {
          this.state.movement.velocity = this.state.movement.velocity.zero();
          this.stopMovingFreely(false);
        }

        this.setTransform(next.transform);
      }
    } // Deprecate

  }, {
    key: "setNextCustomAnimation",
    value: function setNextCustomAnimation(now) {
      // If animation is happening
      // if (this.name === 'diameterDimension') {
      //   console.log("0", this.state.isAnimatingCustom)
      // }
      if (this.state.isAnimatingCustom) {
        var phase = this.state.customAnimation.currentPhase; // console.log("0.5", phase.startTime)
        // If an animation hasn't yet started, the start time will be -1.
        // If this is so, then set the start time to the current time and
        // return the current transform.

        if (phase.startTime < 0) {
          phase.startTime = now - phase.plannedStartTime;
          return;
        } // const percent = calcNextCustomAnimationPercentComplete(now);
        // If we have got here, that means the animation has already started,
        // so calculate the time delta between now and the startTime


        var deltaTime = now - phase.startTime; // If this time delta is larger than the phase's planned time, then
        // either progress to the next animation phase, or end animation.

        if (deltaTime > phase.time) {
          // console.log("1")
          // If there are more animation phases in the plan:
          //   - set the current transform to be the end of the current phase
          //   - start the next phase
          if (this.state.customAnimation.currentPhaseIndex < this.animate.custom.plan.length - 1) {
            // Set current transform to the end of the current phase
            // phase.animationCallback(1);
            phase.finish(); // Get the amount of time that has elapsed in the next phase

            var nextPhaseDeltaTime = deltaTime - phase.time; // Start the next animation phase

            this.state.customAnimation.currentPhaseIndex += 1;
            this.animateCustomPhase(this.state.customAnimation.currentPhaseIndex);
            this.state.customAnimation.currentPhase.startTime = now - nextPhaseDeltaTime;
            this.setNextCustomAnimation(now);
            return;
          } // This needs to go before StopAnimating, as stopAnimating clears
          // the animation plan (incase a callback is used to start another
          // animation)
          // const endColor = this.calcNextAnimationColor(phase.time);
          // this.setColor(endColor);
          // console.log("2")
          // phase.animationCallback(1);


          this.stopAnimatingCustom(true); // console.log("3")

          return;
        } // If we are here, that means the time elapsed is not more than the
        // current animation phase plan time, so calculate the next transform.
        // console.log("4", this.state.isAnimatingCustom)


        var percent = this.calcNextCustomAnimationPercentComplete(deltaTime); // console.log(phase.animationCallback)

        phase.animationCallback(percent); // console.log("5", this.state.isAnimatingCustom)
        // this.setColor(this.calcNextAnimationColor(deltaTime));
      } // if (this.name === 'diameterDimension') {
      //   console.log("6", this.state.isAnimatingCustom)
      // }

    } // Deprecate

  }, {
    key: "setNextColor",
    value: function setNextColor(now) {
      // If animation is happening
      if (this.state.isAnimatingColor) {
        var phase = this.state.colorAnimation.currentPhase; // If an animation hasn't yet started, the start time will be -1.
        // If this is so, then set the start time to the current time and
        // return the current transform.

        if (phase.startTime < 0) {
          phase.startTime = now;
          return;
        } // If we have got here, that means the animation has already started,
        // so calculate the time delta between now and the startTime


        var deltaTime = now - phase.startTime; // If this time delta is larger than the phase's planned time, then
        // either progress to the next animation phase, or end animation.

        if (deltaTime > phase.time) {
          // If there are more animation phases in the plan:
          //   - set the current transform to be the end of the current phase
          //   - start the next phase
          if (this.state.colorAnimation.currentPhaseIndex < this.animate.color.plan.length - 1) {
            // Set current transform to the end of the current phase
            // this.setColor(this.calcNextAnimationColor(phase.time));
            // Phase callback
            phase.finish(this); // Get the amount of time that has elapsed in the next phase

            var nextPhaseDeltaTime = deltaTime - phase.time; // Start the next animation phase

            this.state.colorAnimation.currentPhaseIndex += 1;
            this.animateColorPhase(this.state.colorAnimation.currentPhaseIndex);
            this.state.colorAnimation.currentPhase.startTime = now - nextPhaseDeltaTime;
            this.setNextColor(now);
            return;
          } // This needs to go before StopAnimating, as stopAnimating clears
          // the animation plan (incase a callback is used to start another
          // animation)
          // const endColor = this.calcNextAnimationColor(phase.time);
          // this.setColor(endColor);
          // phase.finish(this);


          this.stopAnimatingColor(false);
          return;
        } // If we are here, that means the time elapsed is not more than the
        // current animation phase plan time, so calculate the next transform.


        this.setColor(this.calcNextAnimationColor(deltaTime)); // if(this.name === 'times') {
        //   console.log(now, this.color[3])
        // }
      }
    } // ///////////////// Deprecate Start
    // rotateTo(...optionsIn: Array<TypeRotationAnimationStepInputOptions>) {
    //   const options = joinObjects({}, { element: this }, ...optionsIn);
    //   return new animations.RotationAnimationStep(options);
    // }
    // scaleTo(...optionsIn: Array<TypeScaleAnimationStepInputOptions>) {
    //   const options = joinObjects({}, { element: this }, ...optionsIn);
    //   return new animations.ScaleAnimationStep(options);
    // }
    // moveTo(...optionsIn: Array<TypePositionAnimationStepInputOptions>) {
    //   return this.moveToPosition(...optionsIn);
    // }
    // moveToPosition(...optionsIn: Array<TypePositionAnimationStepInputOptions>) {
    //   const options = joinObjects({}, { element: this }, ...optionsIn);
    //   return new animations.PositionAnimationStep(options);
    // }
    // moveToTransform(...optionsIn: Array<TypeTransformAnimationStepInputOptions>) {
    //   const options = joinObjects({}, { element: this }, ...optionsIn);
    //   return new animations.TransformAnimationStep(options);
    // }
    // dissolveIn(
    //   timeOrOptionsIn: number | TypeColorAnimationStepInputOptions = {},
    //   ...args: Array<TypeColorAnimationStepInputOptions>
    // ) {
    //   const defaultOptions = { element: this };
    //   let options;
    //   if (typeof timeOrOptionsIn === 'number') {
    //     options = joinObjects({}, defaultOptions, { duration: timeOrOptionsIn }, ...args);
    //   } else {
    //     options = joinObjects({}, defaultOptions, timeOrOptionsIn, ...args);
    //   }
    //   return new animations.DissolveInAnimationStep(options);
    // }
    // dissolveOut(
    //   timeOrOptionsIn: number | TypeColorAnimationStepInputOptions = {},
    //   ...args: Array<TypeColorAnimationStepInputOptions>
    // ) {
    //   const defaultOptions = { element: this };
    //   let options;
    //   if (typeof timeOrOptionsIn === 'number') {
    //     options = joinObjects({}, defaultOptions, { duration: timeOrOptionsIn }, ...args);
    //   } else {
    //     options = joinObjects({}, defaultOptions, timeOrOptionsIn, ...args);
    //   }
    //   return new animations.DissolveOutAnimationStep(options);
    // }
    // animationBuilder(...optionsIn: Array<TypeAnimationBuilderInputOptions>) {
    //   return new animations.AnimationBuilder(this, ...optionsIn);
    // }
    // Deprecate
    // moveToScenario(
    //   ...optionsIn: Array<TypeTransformAnimationStepInputOptions & { scenario: string }>
    // ) {
    //   const defaultOptions = { element: this };
    //   const options = joinObjects({}, defaultOptions, ...optionsIn);
    //   if (options.target != null
    //     && options.target in options.element.scenarios
    //   ) {
    //     const target = options.element.getScenarioTarget(options.target);
    //     options.target = target;
    //   }
    //   if (options.start != null
    //     && options.start in options.element.scenarios
    //   ) {
    //     const start = options.element.getScenarioTarget(options.start);
    //     options.start = start;
    //   }
    //   if (options.delta != null
    //     && options.delta in options.element.scenarios
    //   ) {
    //     const delta = options.element.getScenarioTarget(options.delta);
    //     options.delta = delta;
    //   }
    //   return new animations.TransformAnimationStep(options);
    // }
    // //////////// Deprecate End
    // moveToScenario_old(
    //   scenarioName: string,
    //   animationTimeOrVelocity: ?number = null,    // null uses velocity
    //   callback: ?() => void = null,
    //   rotDirection: -1 | 1 | 0 | 2 = 0,
    // ) {
    //   this.stop();
    //   const target = this.getScenarioTarget(scenarioName);
    //   let time = 1;
    //   const estimatedTime = this.getTimeToMoveToScenario(scenarioName, rotDirection);
    //   if (animationTimeOrVelocity == null) {
    //     time = estimatedTime;
    //   } else {
    //     time = animationTimeOrVelocity;
    //   }
    //   if (time > 0 && estimatedTime !== 0) {
    //     this.animateTo(target, time, 0, rotDirection, callback);
    //   } else if (callback != null) {
    //     callback();
    //   }
    //   return time;
    // }
    // Used only to clear 2D context

  }, {
    key: "clear",
    value: function clear() {}
  }, {
    key: "setColor",
    value: function setColor(color) {
      this.color = color.slice();
    }
  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      this.color[3] = opacity;
    }
  }, {
    key: "getScenarioTarget",
    value: function getScenarioTarget(scenarioName) {
      var target = this.transform._dup();

      if (scenarioName in this.scenarios) {
        var scenario = this.scenarios[scenarioName];

        if (scenario.position != null) {
          target.updateTranslation(scenario.position);
        }

        if (scenario.rotation != null) {
          target.updateRotation(scenario.rotation);
        }

        if (scenario.scale != null) {
          if (scenario.scale instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
            target.updateScale(scenario.scale);
          } else {
            target.updateScale(scenario.scale, scenario.scale);
          }
        }
      }

      return target;
    }
  }, {
    key: "setScenario",
    value: function setScenario(scenarioName) {
      var target = this.getScenarioTarget(scenarioName);
      this.setTransform(target._dup());
    }
  }, {
    key: "getTimeToMoveToScenario",
    value: function getTimeToMoveToScenario(scenarioName) {
      var rotDirection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var target = this.getScenarioTarget(scenarioName);
      var velocity = this.transform.constant(0);
      velocity.updateTranslation(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1 / 2, 1 / 2));
      velocity.updateRotation(2 * Math.PI / 6);
      velocity.updateScale(1, 1);
      var time = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(this.transform._dup(), target, velocity, rotDirection);
      return time;
    } // Decelerate over some time when moving freely to get a new element
    // transform and movement velocity

  }, {
    key: "decelerate",
    value: function decelerate(deltaTime) {
      var next = this.transform.decelerate(this.state.movement.velocity, this.move.freely.deceleration, deltaTime, this.move.freely.zeroVelocityThreshold);

      if (deltaTime > 0) {
        for (var i = 0; i < next.t.order.length; i += 1) {
          var t = next.t.order[i];
          var min = this.move.minTransform.order[i];
          var max = this.move.maxTransform.order[i];
          var v = next.v.order[i];

          if (t instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Translation"] && v instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Translation"] && max instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Translation"] && min instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Translation"] || t instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Scale"] && v instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Scale"] && max instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Scale"] && min instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Scale"]) {
            var onLine = true;

            if (this.move.limitLine != null) {
              onLine = t.shaddowIsOnLine(this.move.limitLine, 4);
            }

            if (min.x >= t.x || max.x <= t.x || !onLine) {
              if (this.move.bounce) {
                v.x = -v.x * 0.5;
              } else {
                v.x = 0;
              }
            }

            if (min.y >= t.y || max.y <= t.y || !onLine) {
              if (this.move.bounce) {
                v.y = -v.y * 0.5;
              } else {
                v.y = 0;
              }
            }

            next.v.order[i] = v;
          }

          if (t instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"] && v instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"] && max instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"] && min instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"]) {
            if (min.r >= t.r || max.r <= t.r) {
              if (this.move.bounce) {
                v.r = -v.r * 0.5;
              } else {
                v.r = 0;
              }
            }

            next.v.order[i] = v;
          }
        }

        next.v.calcMatrix();
      }

      return {
        velocity: next.v,
        transform: next.t
      };
    }
  }, {
    key: "updateLastDrawTransform",
    value: function updateLastDrawTransform() {
      var _this2 = this;

      var parentCount = this.lastDrawElementTransformPosition.parentCount;
      var pLength = this.lastDrawTransform.order.length;
      this.transform.order.forEach(function (t, index) {
        _this2.lastDrawTransform.order[pLength - parentCount - index - 1] = t._dup();
      });
      this.lastDrawTransform.calcMatrix();
    }
  }, {
    key: "getParentLastDrawTransform",
    value: function getParentLastDrawTransform() {
      var parentCount = this.lastDrawElementTransformPosition.parentCount;
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"](this.lastDrawTransform.order.slice(-parentCount));
    } // Start an animation plan of phases ending in a callback

  }, {
    key: "animatePlan",
    value: function animatePlan(phases) {
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.stopAnimating();
      this.stopMovingFreely();
      this.stopBeingMoved();
      this.animate.transform.plan = [];

      for (var i = 0, j = phases.length; i < j; i += 1) {
        this.animate.transform.plan.push(phases[i]);
      }

      if (this.animate.transform.plan.length > 0) {
        if (callback) {
          this.animate.transform.callback = callback;
        }

        this.state.isAnimating = true;
        this.state.animation.currentPhaseIndex = 0;
        this.animatePhase(this.state.animation.currentPhaseIndex);
      }
    }
  }, {
    key: "animateColorPlan",
    value: function animateColorPlan(phases) {
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.stopAnimatingColor();
      this.animate.color.plan = [];

      for (var i = 0, j = phases.length; i < j; i += 1) {
        this.animate.color.plan.push(phases[i]);
      }

      if (this.animate.color.plan.length > 0) {
        if (callback) {
          this.animate.color.callback = callback;
        } // console.log(this.animate.color.toDisolve, this.name)
        // this.state.disolving = this.animate.color.toDisolve;
        // this.animate.color.toDisolve = '';


        this.state.isAnimatingColor = true;
        this.state.colorAnimation.currentPhaseIndex = 0;
        this.animateColorPhase(this.state.colorAnimation.currentPhaseIndex);
      }
    }
  }, {
    key: "animateCustomPlan",
    value: function animateCustomPlan(phases) {
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.stopAnimatingCustom();
      this.animate.custom.plan = [];

      for (var i = 0, j = phases.length; i < j; i += 1) {
        this.animate.custom.plan.push(phases[i]);
      }

      if (this.animate.custom.plan.length > 0) {
        if (callback) {
          this.animate.custom.callback = callback;
        }

        this.state.isAnimatingCustom = true;
        this.state.customAnimation.currentPhaseIndex = 0;
        this.animateCustomPhase(this.state.customAnimation.currentPhaseIndex);
      }
    } // Start the animation of a phase - this should only be called by methods
    // internal to this class.

  }, {
    key: "animatePhase",
    value: function animatePhase(index) {
      this.state.animation.currentPhase = this.animate.transform.plan[index];
      this.state.animation.currentPhase.start(this.transform._dup());
    }
  }, {
    key: "animateColorPhase",
    value: function animateColorPhase(index) {
      this.state.colorAnimation.currentPhase = this.animate.color.plan[index];
      this.state.colorAnimation.currentPhase.start(this);
    }
  }, {
    key: "animateCustomPhase",
    value: function animateCustomPhase(index) {
      this.state.customAnimation.currentPhase = this.animate.custom.plan[index];
      this.state.customAnimation.currentPhase.start();
    }
  }, {
    key: "stopAnimatingGeneric",
    value: function stopAnimatingGeneric(cancelled, forceSetToEnd, currentPhaseIndex, animateString, isState) {
      // Animation state needs to be cleaned up before calling callbacks
      // as the last phase callback may trigger more animations which need
      // to start from scratch (and not use the existing callback for example).
      // Therefore, make some temporary variables to store the animation state.
      var runRemainingPhases = false; // const currentIndex = currentPhaseIndex;

      var runLastPhase = false;
      var _this$animate$animate = this.animate[animateString],
          plan = _this$animate$animate.plan,
          callback = _this$animate$animate.callback; // If the animation was cancelled, then run finish on all unfinished
      // phases.

      if (plan.length > 0 && this.state[isState] && cancelled) {
        runRemainingPhases = true;
      } // If the animation finished without being cancelled, then just call
      // the finish routine on the last phase as it hasn't been called yet
      // by setNextTransform


      if (!cancelled) {
        runLastPhase = true;
      } // Reset the animation state, plan and callback


      this.state[isState] = false; // $FlowFixMe

      this.animate[animateString].plan = [];
      this.animate[animateString].callback = null; // Finish remaining phases if required.

      if (runRemainingPhases) {
        var endIndex = plan.length - 1;

        for (var i = currentPhaseIndex; i <= endIndex; i += 1) {
          var phase = plan[i];

          if (phase instanceof _AnimationPhase__WEBPACK_IMPORTED_MODULE_11__["CustomAnimationPhase"]) {
            phase.finish(cancelled, forceSetToEnd);
          } else {
            phase.finish(this, cancelled, forceSetToEnd);
          }
        }
      } // Finish last phases if required.


      if (runLastPhase) {
        if (plan.length > 0) {
          var _phase = plan.slice(-1)[0];

          if (_phase instanceof _AnimationPhase__WEBPACK_IMPORTED_MODULE_11__["CustomAnimationPhase"]) {
            _phase.finish(cancelled, forceSetToEnd);
          } else {
            _phase.finish(this, cancelled, forceSetToEnd);
          }
        }
      } // Run animation plan callback if it exists.


      if (callback != null) {
        callback(cancelled);
      }
    } // When animation is stopped, any callback associated with the animation
    // needs to be called, with whatever is passed to stopAnimating.

  }, {
    key: "stopAnimating",
    value: function stopAnimating() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var forceSetToEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.stopAnimatingGeneric(cancelled, forceSetToEnd, this.state.animation.currentPhaseIndex, 'transform', 'isAnimating');
    }
  }, {
    key: "stopAnimatingColor",
    value: function stopAnimatingColor() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var forceSetToEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.stopAnimatingGeneric(cancelled, forceSetToEnd, this.state.colorAnimation.currentPhaseIndex, 'color', 'isAnimatingColor');
    }
  }, {
    key: "stopAnimatingCustom",
    value: function stopAnimatingCustom() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var forceSetToEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.stopAnimatingGeneric(cancelled, forceSetToEnd, this.state.colorAnimation.currentPhaseIndex, 'custom', 'isAnimatingCustom');
    } // **************************************************************
    // **************************************************************
    // Helper functions for quicker animation plans
    // Deprecate

  }, {
    key: "animateTo",
    value: function animateTo(transform) {
      var timeOrVelocity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var rotDirection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var easeFunction = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _tools_math__WEBPACK_IMPORTED_MODULE_2__["easeinout"];
      this.animateTransformToWithDelay(transform, delay, timeOrVelocity, rotDirection, callback, true, easeFunction);
    } // Deprecate

  }, {
    key: "animateFrom",
    value: function animateFrom(transform) {
      var timeOrVelocity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var rotDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var easeFunction = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _tools_math__WEBPACK_IMPORTED_MODULE_2__["easeinout"];

      var target = this.transform._dup();

      this.animateTransformToWithDelay(target, 0, timeOrVelocity, rotDirection, callback, true, easeFunction);
    } // Deprecate

  }, {
    key: "animateColorTo",
    value: function animateColorTo(color) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var finishOnCancel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var easeFunction = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _tools_math__WEBPACK_IMPORTED_MODULE_2__["linear"];
      this.animateColorToWithDelay(color, 0, time, null, callback, finishOnCancel, easeFunction);
    } // Deprecate

  }, {
    key: "animateTransformToWithDelay",
    value: function animateTransformToWithDelay(targetTransform) {
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var timeOrVelocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var rotDirection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var finishOnCancel = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
      var easeFunction = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : _tools_math__WEBPACK_IMPORTED_MODULE_2__["easeinout"];
      var addToExistingPlan = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;
      var callbackToUse = checkCallback(callback);
      var moveTime = 0;

      if (timeOrVelocity instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]) {
        moveTime = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(this.transform, targetTransform, timeOrVelocity, rotDirection);
      } else {
        moveTime = timeOrVelocity;
      }

      if (delay === 0 && moveTime === 0) {
        this.setTransform(targetTransform);
        callbackToUse(false);
        return;
      }

      var phaseDelay = null;
      var phaseMove = null;
      var phases = [];
      var delayCallback = null;
      var moveCallback = callbackToUse;

      if (moveTime === 0) {
        delayCallback = function delayCallback(cancelled) {
          callbackToUse(cancelled);
        };

        moveCallback = null;
      }

      if (delay > 0) {
        var delayTransform = this.transform._dup();

        if (addToExistingPlan && this.animate.transform.plan.length > 0) {
          delayTransform = this.animate.transform.plan.slice(-1)[0].targetTransform._dup();
        }

        phaseDelay = new _AnimationPhase__WEBPACK_IMPORTED_MODULE_11__["AnimationPhase"](delayTransform, delayTransform, delay, rotDirection, delayCallback, finishOnCancel, _tools_math__WEBPACK_IMPORTED_MODULE_2__["linear"], this.animate.transform.translation.style, this.animate.transform.translation.options);
        phases.push(phaseDelay);
      }

      if (moveTime > 0) {
        phaseMove = new _AnimationPhase__WEBPACK_IMPORTED_MODULE_11__["AnimationPhase"](null, targetTransform, timeOrVelocity, rotDirection, moveCallback, finishOnCancel, easeFunction, this.animate.transform.translation.style, this.animate.transform.translation.options);
        phases.push(phaseMove);
      }

      if (phases.length > 0) {
        if (addToExistingPlan && this.state.isAnimating) {
          this.animate.transform.plan = [].concat(_toConsumableArray(this.animate.transform.plan), phases);
        } else {
          this.animatePlan(phases);
        }
      }
    } // Deprecate

  }, {
    key: "animateColorToWithDelay",
    value: function animateColorToWithDelay(color, delay) {
      var _this3 = this;

      var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var disolve = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var finishOnCancel = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
      var easeFunction = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : _tools_math__WEBPACK_IMPORTED_MODULE_2__["linear"];
      var addToExistingPlan = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;
      var callbackToUse = checkCallback(callback);

      if (delay === 0 && time === 0) {
        this.setColor(color);
        callbackToUse(false);
        return;
      }

      var phaseDelay = null;
      var phaseColor = null;
      var phases = [];
      var delayCallback = null;
      var colorCallback = callbackToUse;

      if (time === 0) {
        delayCallback = function delayCallback(cancelled) {
          if (!cancelled && finishOnCancel) {
            _this3.setColor(color);
          }

          callbackToUse(cancelled);
        };

        colorCallback = null;
      }

      if (delay > 0) {
        var delayColor = this.color.slice();

        if (addToExistingPlan && this.animate.color.plan.length > 0) {
          delayColor = this.animate.color.plan.slice(-1)[0].targetColor.slice();
        }

        var delayDisolve = null;

        if (disolve === 'in') {
          delayColor[3] = 0.01;
          delayDisolve = 'in';
        }

        phaseDelay = new _AnimationPhase__WEBPACK_IMPORTED_MODULE_11__["ColorAnimationPhase"](delayColor, delayColor, delay, delayDisolve, delayCallback, finishOnCancel, _tools_math__WEBPACK_IMPORTED_MODULE_2__["linear"]);
        phases.push(phaseDelay);
      }

      if (time > 0) {
        phaseColor = new _AnimationPhase__WEBPACK_IMPORTED_MODULE_11__["ColorAnimationPhase"](null, color, time, disolve, colorCallback, finishOnCancel, easeFunction);
        phases.push(phaseColor);
      }

      if (phases.length > 0) {
        if (addToExistingPlan && this.state.isAnimatingColor) {
          this.animate.color.plan = [].concat(_toConsumableArray(this.animate.color.plan), phases);
        } else {
          this.animateColorPlan(phases);
        }
      }
    } // Deprecate

  }, {
    key: "disolveOutWithDelay",
    value: function disolveOutWithDelay() {
      var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      this.animateColorToWithDelay(this.color, delay, time, 'out', callback);
    } // Deprecate

  }, {
    key: "disolveInWithDelay",
    value: function disolveInWithDelay() {
      var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      this.animateColorToWithDelay(this.color, delay, time, 'in', callback);
    } // Deprecate

  }, {
    key: "disolveWithDelay",
    value: function disolveWithDelay() {
      var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var disolve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'in';
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var finishOnCancel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      this.animateColorToWithDelay(this.color, delay, time, disolve, callback, finishOnCancel);
    } // Deprecate

  }, {
    key: "animateCustomTo",
    value: function animateCustomTo(phaseCallback) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var startPercent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var easeFunction = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _tools_math__WEBPACK_IMPORTED_MODULE_2__["linear"];
      this.animateCustomToWithDelay(0, phaseCallback, time, startPercent, callback, true, easeFunction, true);
    } // Deprecate

  }, {
    key: "animateCustomToWithDelay",
    value: function animateCustomToWithDelay(delay, phaseCallback) {
      var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var startPercent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var finishOnCancel = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
      var easeFunction = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : _tools_math__WEBPACK_IMPORTED_MODULE_2__["easeinout"];
      var addToExistingPlan = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;
      var callbackToUse = checkCallback(callback);

      if (delay === 0 && time === 0) {
        phaseCallback(1);
        callbackToUse(false);
        return;
      }

      var phaseDelay = null;
      var phaseCustom = null;
      var phases = [];
      var delayCallback = null;
      var customCallback = callbackToUse;

      if (time === 0) {
        delayCallback = function delayCallback(cancelled) {
          callbackToUse(cancelled);
        };

        customCallback = null;
      }

      if (delay > 0) {
        phaseDelay = new _AnimationPhase__WEBPACK_IMPORTED_MODULE_11__["CustomAnimationPhase"](function () {}, delay, 0, delayCallback, finishOnCancel, _tools_math__WEBPACK_IMPORTED_MODULE_2__["linear"]);
        phases.push(phaseDelay);
      }

      if (time > 0) {
        phaseCustom = new _AnimationPhase__WEBPACK_IMPORTED_MODULE_11__["CustomAnimationPhase"](phaseCallback, time, startPercent, customCallback, finishOnCancel, easeFunction);
        phases.push(phaseCustom);
      }

      if (phases.length > 0) {
        if (addToExistingPlan && this.state.isAnimating) {
          this.animate.custom.plan = [].concat(_toConsumableArray(this.animate.custom.plan), phases);
        } else {
          this.animateCustomPlan(phases);
        }
      }
    } // Deprecate

  }, {
    key: "disolveIn",
    value: function disolveIn() {
      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.disolveInWithDelay(0, time, callback);
    } // Deprecate

  }, {
    key: "disolveOut",
    value: function disolveOut() {
      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.disolveOutWithDelay(0, time, callback);
    } // With update only first instace of translation in the transform order
    // Deprecate

  }, {
    key: "animateTranslationTo",
    value: function animateTranslationTo(translation) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var easeFunction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _tools_math__WEBPACK_IMPORTED_MODULE_2__["easeinout"];

      var transform = this.transform._dup();

      transform.updateTranslation(translation);
      this.animateTransformToWithDelay(transform, 0, time, 0, callback, true, easeFunction);
    } // With update only first instace of translation in the transform order
    // Deprecate

  }, {
    key: "animateScaleTo",
    value: function animateScaleTo(scale) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var easeFunction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _tools_math__WEBPACK_IMPORTED_MODULE_2__["easeinout"];

      var transform = this.transform._dup();

      transform.updateScale(scale);
      this.animateTransformToWithDelay(transform, 0, time, 0, callback, true, easeFunction);
    } // Will update only first instace of translation in the transform order
    // Deprecate

  }, {
    key: "animateTranslationFrom",
    value: function animateTranslationFrom(translation) {
      var timeOrVelocity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var easeFunction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _tools_math__WEBPACK_IMPORTED_MODULE_2__["easeinout"];

      var target = this.transform._dup();

      this.transform.updateTranslation(translation);
      this.animateTransformToWithDelay(target, 0, timeOrVelocity, 0, callback, true, easeFunction); // this.animateTo(target, timeOrVelocity, 0, 0, callback, easeFunction);
    } // Deprecate

  }, {
    key: "animateTranslationToWithDelay",
    value: function animateTranslationToWithDelay(translation) {
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var easeFunction = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _tools_math__WEBPACK_IMPORTED_MODULE_2__["easeinout"];

      var transform = this.transform._dup();

      transform.updateTranslation(translation);
      this.animateTransformToWithDelay(transform, delay, time, 0, callback, true, easeFunction);
    } // With update only first instace of rotation in the transform order
    // Deprecate

  }, {
    key: "animateRotationTo",
    value: function animateRotationTo(rotation, rotDirection) {
      var timeOrVelocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var easeFunction = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _tools_math__WEBPACK_IMPORTED_MODULE_2__["easeinout"];

      var transform = this.transform._dup();

      transform.updateRotation(rotation);
      this.animateTransformToWithDelay(transform, 0, timeOrVelocity, rotDirection, callback, true, easeFunction);
    } // With update only first instace of rotation in the transform order
    // Deprecate

  }, {
    key: "animateTranslationAndRotationTo",
    value: function animateTranslationAndRotationTo(translation, rotation, rotDirection) {
      var time = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var easeFunction = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _tools_math__WEBPACK_IMPORTED_MODULE_2__["easeinout"];

      var transform = this.transform._dup();

      transform.updateRotation(rotation);
      transform.updateTranslation(translation._dup());
      this.animateTransformToWithDelay(transform, 0, time, rotDirection, callback, true, easeFunction);
    } // Deprecate

  }, {
    key: "animateTranslationAndScaleTo",
    value: function animateTranslationAndScaleTo(translation, scale) {
      var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var easeFunction = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _tools_math__WEBPACK_IMPORTED_MODULE_2__["easeinout"];

      var transform = this.transform._dup();

      if (typeof scale === 'number') {
        transform.updateScale(scale, scale);
      } else {
        transform.updateScale(scale._dup());
      }

      transform.updateTranslation(translation._dup());
      this.animateTransformToWithDelay(transform, 0, time, 0, callback, true, easeFunction);
    } // **************************************************************
    // **************************************************************
    // Being Moved

  }, {
    key: "startBeingMoved",
    value: function startBeingMoved() {
      this.stopAnimating();
      this.stopMovingFreely();
      this.state.movement.velocity = this.transform.zero();
      this.state.movement.previousTransform = this.transform._dup();
      this.state.movement.previousTime = Date.now() / 1000;
      this.state.isBeingMoved = true;
    }
  }, {
    key: "moved",
    value: function moved(newTransform) {
      this.calcVelocity(newTransform);
      this.setTransform(newTransform._dup());
    }
  }, {
    key: "stopBeingMoved",
    value: function stopBeingMoved() {
      var currentTime = Date.now() / 1000; // Check wether last movement was a long time ago, if it was, then make
      // velocity 0 as the user has stopped moving before releasing touch/click

      if (this.state.movement.previousTime !== -1) {
        if (currentTime - this.state.movement.previousTime > 0.05) {
          this.state.movement.velocity = this.transform.zero();
        }
      }

      this.state.isBeingMoved = false;
      this.state.movement.previousTime = -1;
    }
  }, {
    key: "calcVelocity",
    value: function calcVelocity(newTransform) {
      var currentTime = Date.now() / 1000;

      if (this.state.movement.previousTime < 0) {
        this.state.movement.previousTime = currentTime;
        return;
      }

      var deltaTime = currentTime - this.state.movement.previousTime; // If the time is too small, weird calculations may happen

      if (deltaTime < 0.0001) {
        return;
      }

      this.state.movement.velocity = newTransform.velocity(this.transform, deltaTime, this.move.freely.zeroVelocityThreshold, this.move.maxVelocity);
      this.state.movement.previousTime = currentTime;
    } // Moving Freely

  }, {
    key: "startMovingFreely",
    value: function startMovingFreely() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.stopAnimating();
      this.stopBeingMoved();

      if (callback) {
        this.animate.transform.callback = callback;
      }

      this.state.isMovingFreely = true;
      this.state.movement.previousTime = -1;
      this.state.movement.velocity = this.state.movement.velocity.clipMag(this.move.freely.zeroVelocityThreshold, this.move.maxVelocity);
    }
  }, {
    key: "stopMovingFreely",
    value: function stopMovingFreely() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.state.isMovingFreely = false;
      this.state.movement.previousTime = -1;

      if (this.animate.transform.callback) {
        this.animate.transform.callback(result); // if (result !== null && result !== undefined) {
        //   this.animate.transform.callback(result);
        // } else {
        //   this.animate.transform.callback();
        // }

        this.animate.transform.callback = null;
      }
    } // Take an input transform matrix, and output a list of transform matrices
    // that have been transformed by a pulse. The first matrix in the list
    // will be the largest, so when saving lastDrawTransformMatrix it can be
    // used to determine if a touch has occured in the object.
    //
    // When an object is animated or moved, it's new transform is saved as the
    // new transform of the object. In contrast, pulsing is not saved as the
    // current transform of the object, and is used only in the current draw
    // of the element.

  }, {
    key: "transformWithPulse",
    value: function transformWithPulse(now, transform) {
      var pulseTransforms = []; // To output list of transform matrices
      // If the diagram element is currently pulsing, the calculate the current
      // pulse magnitude, and transform the input matrix by the pulse

      if (this.state.isPulsing) {
        // If this is the first pulse frame, then set the startTime
        if (this.state.pulse.startTime === -1) {
          this.state.pulse.startTime = now;
        } // Calculate how much time has elapsed between this frame and the first
        // pulse frame


        var deltaTime = now - this.state.pulse.startTime; // If the elapsed time is larger than the planned pulse time, then
        // clip the elapsed time to the pulse time, and end pulsing (after this
        // draw). If the pulse time is 0, that means pulsing will loop
        // indefinitely.

        if (deltaTime > this.pulse.time && this.pulse.time !== 0) {
          // this.state.isPulsing = false;
          this.stopPulsing(true);
          deltaTime = this.pulse.time;
        } // Go through each pulse matrix planned, and transform the input matrix
        // with the pulse.


        for (var i = 0; i < this.pulse.num; i += 1) {
          // Get the current pulse magnitude
          var pulseMag = this.pulse.style(deltaTime, this.pulse.frequency, this.pulse.A instanceof Array ? this.pulse.A[i] : this.pulse.A, this.pulse.B instanceof Array ? this.pulse.B[i] : this.pulse.B, this.pulse.C instanceof Array ? this.pulse.C[i] : this.pulse.C); // Use the pulse magnitude to get the current pulse transform

          var pTransform = this.pulse.transformMethod(pulseMag); // if(this.name === '_radius') {
          // }
          // Transform the current transformMatrix by the pulse transform matrix
          // const pMatrix = m2.mul(m2.copy(transform), pTransform.matrix());
          // Push the pulse transformed matrix to the array of pulse matrices

          pulseTransforms.push(transform.transform(pTransform));
        } // If not pulsing, then make no changes to the transformMatrix.

      } else {
        pulseTransforms.push(transform._dup());
      }

      return pulseTransforms;
    }
  }, {
    key: "pulseScaleNow",
    value: function pulseScaleNow(time, scale) {
      var frequency = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      this.pulse.time = time;

      if (frequency === 0 && time === 0) {
        this.pulse.frequency = 1;
      }

      if (frequency !== 0) {
        this.pulse.frequency = frequency;
      }

      if (time !== 0 && frequency === 0) {
        this.pulse.frequency = 1 / (time * 2);
      }

      this.pulse.A = 1;
      this.pulse.B = scale - 1;
      this.pulse.C = 0;
      this.pulse.num = 1;
      this.pulse.callback = callback;
      this.pulseNow();
    }
  }, {
    key: "pulseThickNow",
    value: function pulseThickNow(time, scale) {
      var num = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var bArray = [scale];
      this.pulse.num = num;

      if (this.pulse.num > 1) {
        var b = Math.abs(1 - scale);
        var bMax = b;
        var bMin = -b;
        var range = bMax - bMin;
        var bStep = range / (this.pulse.num - 1);
        bArray = [];

        for (var i = 0; i < this.pulse.num; i += 1) {
          bArray.push(bMax - i * bStep);
        }
      }

      this.pulse.time = time;
      this.pulse.frequency = 1 / (time * 2);
      this.pulse.A = 1;
      this.pulse.B = bArray;
      this.pulse.C = 0;
      this.pulse.callback = callback;
      this.pulseNow();
    }
  }, {
    key: "pulseNow",
    value: function pulseNow() {
      this.state.isPulsing = true;
      this.state.pulse.startTime = -1;
    }
  }, {
    key: "stopPulsing",
    value: function stopPulsing(result) {
      this.state.isPulsing = false;

      if (this.pulse.callback) {
        var callback = this.pulse.callback;
        this.pulse.callback = null;
        callback(result);
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var forceSetToEndOfPlan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (forceSetToEndOfPlan === true) {
        this.animations.cancelAll('complete');
      } else if (forceSetToEndOfPlan === false) {
        this.animations.cancelAll('noComplete');
      } else {
        this.animations.cancelAll(null);
      } // Deprecate


      this.stopAnimating(cancelled, forceSetToEndOfPlan); // Deprecate

      this.stopAnimatingColor(cancelled, forceSetToEndOfPlan); // Deprecate

      this.stopAnimatingCustom(cancelled, forceSetToEndOfPlan);
      this.stopMovingFreely(cancelled);
      this.stopBeingMoved();
      this.stopPulsing(cancelled);
    }
  }, {
    key: "updateLimits",
    value: function updateLimits(limits, transforms) {
      this.diagramLimits = limits;
      this.diagramTransforms = transforms;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getGLBoundingRect",
    value: function getGLBoundingRect() {
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](0, 0, 1, 1);
    }
  }, {
    key: "getDiagramBoundingRect",
    value: function getDiagramBoundingRect() {
      var gl = this.getGLBoundingRect();
      var glToDiagramScale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.diagramLimits.width / 2, this.diagramLimits.height / 2);
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](gl.left * glToDiagramScale.x, gl.bottom * glToDiagramScale.y, gl.width * glToDiagramScale.x, gl.height * glToDiagramScale.y);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getRelativeGLBoundingRect",
    value: function getRelativeGLBoundingRect() {
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](0, 0, 1, 1);
    }
  }, {
    key: "getRelativeDiagramBoundingRect",
    value: function getRelativeDiagramBoundingRect() {
      var gl = this.getRelativeGLBoundingRect();
      var glToDiagramScale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.diagramLimits.width / 2, this.diagramLimits.height / 2);
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](gl.left * glToDiagramScale.x, gl.bottom * glToDiagramScale.y, gl.width * glToDiagramScale.x, gl.height * glToDiagramScale.y);
    }
  }, {
    key: "getCenterDiagramPosition",
    value: function getCenterDiagramPosition() {
      var rect = this.getDiagramBoundingRect();
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](rect.left + rect.width / 2, rect.bottom + rect.height / 2);
    }
  }, {
    key: "getPosition",
    value: function getPosition() {
      var t = this.transform.t();
      var position = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

      if (t != null) {
        position = t._dup();
      }

      return position;
    }
  }, {
    key: "getScale",
    value: function getScale() {
      var s = this.transform.s();
      var scale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

      if (s != null) {
        scale = s._dup();
      }

      return scale;
    }
  }, {
    key: "getRotation",
    value: function getRotation() {
      var r = this.transform.r();
      var rotation = 0;

      if (r != null) {
        rotation = r;
      }

      return rotation;
    }
  }, {
    key: "getVertexSpaceDiagramPosition",
    value: function getVertexSpaceDiagramPosition(vertexSpacePoint) {
      var location = vertexSpacePoint.transformBy(this.lastDrawTransform.matrix());
      var glSpace = {
        x: {
          bottomLeft: -1,
          width: 2
        },
        y: {
          bottomLeft: -1,
          height: 2
        }
      };
      var diagramSpace = {
        x: {
          bottomLeft: this.diagramLimits.left,
          width: this.diagramLimits.width
        },
        y: {
          bottomLeft: this.diagramLimits.bottom,
          height: this.diagramLimits.height
        }
      };
      var glToDiagramSpace = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["spaceToSpaceTransform"])(glSpace, diagramSpace);
      return location.transformBy(glToDiagramSpace.matrix());
    }
  }, {
    key: "getDiagramPosition",
    value: function getDiagramPosition() {
      // console.log(this.name, this.getVertexSpaceDiagramPosition(new Point(0, 0)))
      // console.log(this.transform, this.lastDrawTransform)
      return this.getVertexSpaceDiagramPosition(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0)); // const location = new Point(0, 0).transformBy(this.lastDrawTransform.matrix());
      // const glSpace = {
      //   x: { bottomLeft: -1, width: 2 },
      //   y: { bottomLeft: -1, height: 2 },
      // };
      // const diagramSpace = {
      //   x: {
      //     bottomLeft: this.diagramLimits.left,
      //     width: this.diagramLimits.width,
      //   },
      //   y: {
      //     bottomLeft: this.diagramLimits.bottom,
      //     height: this.diagramLimits.height,
      //   },
      // };
      // const glToDiagramSpace = spaceToSpaceTransform(glSpace, diagramSpace);
      // return location.transformBy(glToDiagramSpace.matrix());
    }
  }, {
    key: "getPixelToVertexSpaceScale",
    value: function getPixelToVertexSpaceScale() {
      var pixelToDiagram = this.diagramTransforms.pixelToDiagram.matrix();
      var diagramToVertex = this.diagramSpaceToVertexSpaceTransformMatrix();
      var scaleX = pixelToDiagram[0] * diagramToVertex[0];
      var scaleY = pixelToDiagram[4] * diagramToVertex[4];
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](scaleX, scaleY);
    }
  }, {
    key: "getVertexToPixelSpaceScale",
    value: function getVertexToPixelSpaceScale() {
      var pixelToVertexSpaceScale = this.getPixelToVertexSpaceScale();
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1 / pixelToVertexSpaceScale.x, 1 / pixelToVertexSpaceScale.y);
    }
  }, {
    key: "getDiagramPositionInVertexSpace",
    value: function getDiagramPositionInVertexSpace(diagramPosition) {
      return diagramPosition.transformBy(this.diagramSpaceToVertexSpaceTransformMatrix());
    }
  }, {
    key: "diagramSpaceToVertexSpaceTransformMatrix",
    value: function diagramSpaceToVertexSpaceTransformMatrix() {
      // Diagram transform will always be two
      var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"](this.lastDrawTransform.order.slice(this.lastDrawElementTransformPosition.elementCount, this.lastDrawTransform.order.length - 2));
      return _tools_m2__WEBPACK_IMPORTED_MODULE_1__["inverse"](t.matrix());
    }
  }, {
    key: "vertexToDiagramSpaceTransformMatrix",
    value: function vertexToDiagramSpaceTransformMatrix() {
      var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"](this.lastDrawTransform.order.slice(0, this.lastDrawTransform.order.length - 2));
      return t.matrix();
    }
  }, {
    key: "setDiagramPosition",
    value: function setDiagramPosition(diagramPosition) {
      var glSpace = {
        x: {
          bottomLeft: -1,
          width: 2
        },
        y: {
          bottomLeft: -1,
          height: 2
        }
      };
      var diagramSpace = {
        x: {
          bottomLeft: this.diagramLimits.left,
          width: this.diagramLimits.width
        },
        y: {
          bottomLeft: this.diagramLimits.bottom,
          height: this.diagramLimits.height
        }
      };
      var diagramToGLSpace = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["spaceToSpaceTransform"])(diagramSpace, glSpace);
      var glLocation = diagramPosition.transformBy(diagramToGLSpace.matrix());
      var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"](this.lastDrawTransform.order.slice(2));
      var newLocation = glLocation.transformBy(_tools_m2__WEBPACK_IMPORTED_MODULE_1__["inverse"](t.matrix()));
      this.setPosition(newLocation._dup());
    }
  }, {
    key: "setDiagramPositionToElement",
    value: function setDiagramPositionToElement(element) {
      var p = element.getDiagramPosition();
      this.setDiagramPosition(p._dup());
    }
  }, {
    key: "setPositionToElement",
    value: function setPositionToElement(element) {
      var p = element.transform.t();

      if (p != null) {
        this.setPosition(p._dup());
      }
    }
  }, {
    key: "setMoveBoundaryToDiagram",
    value: function setMoveBoundaryToDiagram() {
      var boundary = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [this.diagramLimits.left, this.diagramLimits.top - this.diagramLimits.height, this.diagramLimits.left + this.diagramLimits.width, this.diagramLimits.top];
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1, 1);

      if (!this.isMovable) {
        return;
      }

      if (!this.move.limitToDiagram) {
        return;
      }

      var glSpace = {
        x: {
          bottomLeft: -1,
          width: 2
        },
        y: {
          bottomLeft: -1,
          height: 2
        }
      };
      var diagramSpace = {
        x: {
          bottomLeft: this.diagramLimits.left,
          width: this.diagramLimits.width
        },
        y: {
          bottomLeft: this.diagramLimits.bottom,
          height: this.diagramLimits.height
        }
      };
      var glToDiagramSpace = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["spaceToSpaceTransform"])(glSpace, diagramSpace);
      var rect = this.getRelativeGLBoundingRect();
      var glToDiagramScaleMatrix = [glToDiagramSpace.matrix()[0], 0, 0, 0, glToDiagramSpace.matrix()[4], 0, 0, 0, 1];
      var minPoint = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](rect.left, rect.bottom).transformBy(glToDiagramScaleMatrix);
      var maxPoint = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](rect.right, rect.top).transformBy(glToDiagramScaleMatrix);
      var min = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var max = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      min.x = boundary[0] - minPoint.x * scale.x;
      min.y = boundary[1] - minPoint.y * scale.y;
      max.x = boundary[2] - maxPoint.x * scale.x;
      max.y = boundary[3] - maxPoint.y * scale.y;
      this.move.maxTransform.updateTranslation(max.x, max.y);
      this.move.minTransform.updateTranslation(min.x, min.y);
    }
  }, {
    key: "show",
    value: function show() {
      this.isShown = true;

      if (this.parent != null) {
        if (!this.parent.isShown) {
          this.parent.show();
        }
      }
    }
  }, {
    key: "showAll",
    value: function showAll() {
      this.show();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.isShown = false;
    }
  }, {
    key: "hideAll",
    value: function hideAll() {
      this.hide();
    }
  }, {
    key: "toggleShow",
    value: function toggleShow() {
      if (this.isShown) {
        this.hide();
      } else {
        this.show();
      }
    }
  }, {
    key: "click",
    value: function click() {
      if (this.onClick !== null && this.onClick !== undefined) {
        this.onClick(this);
      }
    }
  }, {
    key: "setMovable",
    value: function setMovable() {
      var movable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (movable) {
        this.isTouchable = true;
        this.isMovable = true;
      }
    } // processParentTransform(parentTransform: Transform): Transform {
    //   let newTransform;
    //   if (this.noRotationFromParent) {
    //     const finalParentTransform = parentTransform._dup();
    //     let r = 0;
    //     for (let i = 0; i < finalParentTransform.order.length; i += 1) {
    //       const t = finalParentTransform.order[i];
    //       if (t instanceof Rotation) {
    //         r += t.r;
    //       }
    //     }
    //     const m = parentTransform.matrix();
    //     const translation = new Point(m[2], m[5]);
    //     const scale = new Point(
    //       new Point(m[0], m[3]).distance(),
    //       new Point(m[1], m[4]).distance(),
    //     );
    //     newTransform = new Transform()
    //       .scale(scale)
    //       // .rotate(r)
    //       .translate(translation);
    //   } else {
    //     newTransform = parentTransform;
    //   }
    //   return newTransform;
    // }

  }]);

  return DiagramElement;
}(); // ***************************************************************
// Geometry Object
// ***************************************************************


var DiagramElementPrimative =
/*#__PURE__*/
function (_DiagramElement) {
  _inherits(DiagramElementPrimative, _DiagramElement);

  function DiagramElementPrimative(drawingObject) {
    var _this4;

    var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
    var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0.5, 0.5, 0.5, 1];
    var diagramLimits = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2);
    var parent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

    _classCallCheck(this, DiagramElementPrimative);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(DiagramElementPrimative).call(this, transform, diagramLimits, parent));
    _this4.drawingObject = drawingObject;
    _this4.color = color.slice();
    _this4.pointsToDraw = -1;
    _this4.angleToDraw = -1;
    _this4.lengthToDraw = -1;
    _this4.cannotTouchHole = false; // this.setMoveBoundaryToDiagram();

    return _this4;
  }

  _createClass(DiagramElementPrimative, [{
    key: "isBeingTouched",
    value: function isBeingTouched(glLocation) {
      if (!this.isTouchable) {
        return false;
      }

      var boundaries = this.drawingObject.getGLBoundaries(this.lastDrawTransform.matrix());
      var holeBoundaries = this.drawingObject.getGLBoundaryHoles(this.lastDrawTransform.matrix());

      for (var i = 0; i < boundaries.length; i += 1) {
        var boundary = boundaries[i];

        if (glLocation.isInPolygon(boundary)) {
          var isTouched = true;

          if (this.cannotTouchHole) {
            for (var j = 0; j < holeBoundaries.length; j += 1) {
              var holeBoundary = holeBoundaries[j];

              if (glLocation.isInPolygon(holeBoundary)) {
                isTouched = false;
                j = holeBoundaries.length;
              }
            }
          }

          if (isTouched) {
            return true;
          }
        }
      }

      return false;
    }
  }, {
    key: "updateContext",
    value: function updateContext(context) {
      if (this.drawingObject instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["TextObject"]) {
        this.drawingObject.drawContext2D = context;
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var transform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      // const vertices = this.drawingObject._dup();
      var primative = new DiagramElementPrimative(this.drawingObject._dup()); // const primative = new DiagramElementPrimative(
      //   vertices,
      //   transform,
      //   color,
      //   this.diagramLimits._dup(),
      // );
      // primative.pointsToDraw = this.pointsToDraw;
      // primative.angleToDraw = this.angleToDraw;
      // primative.copyFrom(this);

      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_7__["duplicateFromTo"])(this, primative, ['parent']);

      if (transform != null) {
        primative.transform = transform._dup();
      }

      return primative;
    }
  }, {
    key: "clear",
    value: function clear() {
      if (this.drawingObject instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["TextObject"]) {
        this.drawingObject.clear();
      }
    } // use this for any gl canvas resize events

  }, {
    key: "resize",
    value: function resize() {
      // If gl canvas is resized, webgl text will need to be updated.
      if (this.drawingObject.type === 'vertexText') {
        var pixelToVertexScale = this.getPixelToVertexSpaceScale(); // $FlowFixMe

        this.drawingObject.drawTextIntoBuffer(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](pixelToVertexScale.x, Math.abs(pixelToVertexScale.y)));
      }
    }
  }, {
    key: "setColor",
    value: function setColor(color) {
      this.color = color.slice();

      if (this instanceof DiagramElementPrimative) {
        if (this.drawingObject instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["TextObject"]) {
          this.drawingObject.setColor(this.color);
        }

        if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_3__["default"]) {
          // $FlowFixMe
          this.drawingObject.element.style.color = Object(_tools_color__WEBPACK_IMPORTED_MODULE_8__["colorArrayToRGBA"])(this.color);
        }
      }
    }
  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      this.color[3] = opacity;

      if (this instanceof DiagramElementPrimative) {
        if (this.drawingObject instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["TextObject"]) {
          this.drawingObject.setColor(this.color);
        }

        if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_3__["default"]) {
          // $FlowFixMe
          this.drawingObject.element.style.color = Object(_tools_color__WEBPACK_IMPORTED_MODULE_8__["colorArrayToRGBA"])([].concat(_toConsumableArray(this.color.slice(0, 2)), [opacity]));
        }
      }
    }
  }, {
    key: "show",
    value: function show() {
      _get(_getPrototypeOf(DiagramElementPrimative.prototype), "show", this).call(this);

      if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_3__["default"]) {
        this.drawingObject.show = true;
        this.drawingObject.transformHtml(this.lastDrawTransform.matrix());
      }
    } // showAll() {
    //   this.show();
    // }

  }, {
    key: "hide",
    value: function hide() {
      _get(_getPrototypeOf(DiagramElementPrimative.prototype), "hide", this).call(this);

      if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_3__["default"]) {
        this.drawingObject.show = false;
        this.drawingObject.transformHtml(this.lastDrawTransform.matrix());
      }
    } // hideAll() {
    //   this.hide();
    // }

  }, {
    key: "getTouched",
    value: function getTouched(glLocation) {
      if (!this.isTouchable) {
        return [];
      }

      if (this.isBeingTouched(glLocation)) {
        return [this];
      }

      return [];
    }
  }, {
    key: "setFont",
    value: function setFont(fontSize) {
      if (this.drawingObject instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_6__["TextObject"]) {
        this.drawingObject.setFont(fontSize);
      }
    }
  }, {
    key: "resizeHtmlObject",
    value: function resizeHtmlObject() {
      if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_3__["default"]) {
        this.drawingObject.transformHtml(this.lastDrawTransform.matrix());
      }
    }
  }, {
    key: "draw",
    value: function draw() {
      var _this5 = this;

      var parentTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      var now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (this.isShown) {
        this.animations.nextFrame(now); // Deprecate

        this.setNextTransform(now); // Deprecate

        this.setNextColor(now); // set next color can end up hiding an element when disolving out

        if (!this.isShown) {
          return;
        } // Deprecate


        this.setNextCustomAnimation(now); // this.lastDrawParentTransform = parentTransform._dup();

        this.lastDrawElementTransformPosition = {
          parentCount: parentTransform.order.length,
          elementCount: this.transform.order.length
        }; // const finalParentTransform = this.processParentTransform(parentTransform);

        var newTransform = parentTransform.transform(this.transform);
        var pulseTransforms = this.transformWithPulse(now, newTransform); // let matrix = m2.mul(transformMatrix, this.transform.matrix());
        // matrix = this.transformWithPulse(now, matrix);
        // eslint-disable-next-line prefer-destructuring

        this.lastDrawTransform = pulseTransforms[0]; // this.lastDrawPulseTransform = pulseTransforms[0]._dup();

        var pointCount = -1;

        if (this.drawingObject instanceof _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_5__["default"]) {
          pointCount = this.drawingObject.numPoints;

          if (this.angleToDraw !== -1) {
            pointCount = this.drawingObject.getPointCountForAngle(this.angleToDraw);
          }

          if (this.lengthToDraw !== -1) {
            pointCount = this.drawingObject.getPointCountForLength(this.lengthToDraw);
          }

          if (this.pointsToDraw !== -1) {
            pointCount = this.pointsToDraw;
          }
        }

        pulseTransforms.forEach(function (t) {
          _this5.drawingObject.drawWithTransformMatrix(t.matrix(), _this5.color, pointCount);
        });
      }
    }
  }, {
    key: "setFirstTransform",
    value: function setFirstTransform() {
      var parentTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      this.lastDrawElementTransformPosition = {
        parentCount: parentTransform.order.length,
        elementCount: this.transform.order.length
      }; // const finalParentTransform = this.processParentTransform(parentTransform);

      var firstTransform = parentTransform.transform(this.transform);
      this.lastDrawTransform = firstTransform;

      if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_3__["default"]) {
        this.drawingObject.transformHtml(firstTransform.matrix());
      }

      this.setMoveBoundaryToDiagram();
    }
  }, {
    key: "isMoving",
    value: function isMoving() {
      if (this.state.isAnimating || this.state.isMovingFreely || this.state.isBeingMoved || this.state.isPulsing || this.state.isAnimatingColor || this.state.isAnimatingCustom || this.animations.state === 'animating') {
        return true;
      }

      return false;
    } // // Update the translation move boundary for the element's transform.
    // // This will limit the first translation part of the transform to only
    // // translations within the max/min limit.
    // updateMoveTranslationBoundary(
    //   bounday: Array<number> = [
    //     this.diagramLimits.left,
    //     this.diagramLimits.top - this.diagramLimits.height,
    //     this.diagramLimits.left + this.diagramLimits.width,
    //     this.diagramLimits.top],
    //   scale: Point = new Point(1, 1),
    // ): void {
    //   const glSpace = {
    //     x: { bottomLeft: -1, width: 2 },
    //     y: { bottomLeft: -1, height: 2 },
    //   };
    //   const diagramSpace = {
    //     x: {
    //       bottomLeft: this.diagramLimits.left,
    //       width: this.diagramLimits.width,
    //     },
    //     y: {
    //       bottomLeft: this.diagramLimits.bottom,
    //       height: this.diagramLimits.height,
    //     },
    //   };
    //   const glToDiagramSpace = spaceToSpaceTransform(glSpace, diagramSpace);
    //   const rect = this.drawingObject.getRelativeGLBoundingRect(this.lastDrawTransform.matrix());
    //   const minPoint = new Point(rect.left, rect.bottom).transformBy(glToDiagramSpace.matrix());
    //   const maxPoint = new Point(rect.right, rect.top).transformBy(glToDiagramSpace.matrix());
    //   const min = new Point(0, 0);
    //   const max = new Point(0, 0);
    //   min.x = bounday[0] - minPoint.x * scale.x;
    //   min.y = bounday[1] - minPoint.y * scale.y;
    //   max.x = bounday[2] - maxPoint.x * scale.x;
    //   max.y = bounday[3] - maxPoint.y * scale.y;
    //   this.move.maxTransform.updateTranslation(
    //     max.x,
    //     max.y,
    //   );
    //   this.move.minTransform.updateTranslation(
    //     min.x,
    //     min.y,
    //   );
    // }

  }, {
    key: "getGLBoundaries",
    value: function getGLBoundaries() {
      return this.drawingObject.getGLBoundaries(this.lastDrawTransform.matrix());
    }
  }, {
    key: "getVertexSpaceBoundaries",
    value: function getVertexSpaceBoundaries() {
      return this.drawingObject.border;
    }
  }, {
    key: "getGLBoundingRect",
    value: function getGLBoundingRect() {
      return this.drawingObject.getGLBoundingRect(this.lastDrawTransform.matrix());
    }
  }, {
    key: "getVertexSpaceBoundingRect",
    value: function getVertexSpaceBoundingRect() {
      return this.drawingObject.getVertexSpaceBoundingRect();
    }
  }, {
    key: "getRelativeGLBoundingRect",
    value: function getRelativeGLBoundingRect() {
      return this.drawingObject.getRelativeGLBoundingRect(this.lastDrawTransform.matrix());
    }
  }, {
    key: "getRelativeVertexSpaceBoundingRect",
    value: function getRelativeVertexSpaceBoundingRect() {
      return this.drawingObject.getRelativeVertexSpaceBoundingRect();
    }
  }, {
    key: "increaseBorderSize",
    value: function increaseBorderSize() {
      var xMultiplierOrPoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var yMultiplier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var xMulToUse;
      var yMulToUse;

      if (xMultiplierOrPoint instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        xMulToUse = xMultiplierOrPoint.x;
        yMulToUse = xMultiplierOrPoint.y;
      } else {
        xMulToUse = xMultiplierOrPoint;

        if (yMultiplier == null) {
          yMulToUse = xMulToUse;
        } else {
          yMulToUse = yMultiplier;
        }
      }

      if (this.drawingObject instanceof _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_5__["default"]) {
        for (var i = 0; i < this.drawingObject.border[0].length; i += 1) {
          this.drawingObject.border[0][i].x *= xMulToUse;
          this.drawingObject.border[0][i].y *= yMulToUse;
        }
      }
    }
  }]);

  return DiagramElementPrimative;
}(DiagramElement); // ***************************************************************
// Collection of Geometry Objects or Collections
// ***************************************************************


var DiagramElementCollection =
/*#__PURE__*/
function (_DiagramElement2) {
  _inherits(DiagramElementCollection, _DiagramElement2);

  // biasTransform: Array<number>;
  function DiagramElementCollection() {
    var _this6;

    var transform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
    var diagramLimits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, 1, 2, 2);
    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, DiagramElementCollection);

    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(DiagramElementCollection).call(this, transform, diagramLimits, parent));
    _this6.elements = {};
    _this6.drawOrder = [];
    _this6.touchInBoundingRect = false;
    _this6.eqns = {};
    return _this6;
  }

  _createClass(DiagramElementCollection, [{
    key: "_dup",
    value: function _dup() {
      var collection = new DiagramElementCollection(); // collection.touchInBoundingRect = this.touchInBoundingRect;
      // collection.copyFrom(this);

      var doNotDuplicate = this.drawOrder.map(function (e) {
        return "_".concat(e);
      });
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_7__["duplicateFromTo"])(this, collection, ['elements', 'drawOrder', 'parent'].concat(_toConsumableArray(doNotDuplicate)));

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var name = this.drawOrder[i];
        collection.add(name, this.elements[name]._dup());
      }

      return collection;
    }
  }, {
    key: "isMoving",
    value: function isMoving() {
      if (this.isShown === false) {
        return false;
      }

      if (this.state.isAnimating || this.state.isAnimatingCustom || this.state.isAnimatingColor || this.state.isMovingFreely || this.state.isBeingMoved || this.state.isPulsing || this.animations.state === 'animating') {
        return true;
      }

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element instanceof DiagramElementCollection) {
          if (element.isMoving()) {
            return true;
          }
        } else if (element.isShown && element.color[3] > 0 && element.isMoving()) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "add",
    value: function add(name, diagramElement) {
      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      // eslint-disable-next-line no-param-reassign
      diagramElement.parent = this;
      this.elements[name] = diagramElement;
      this.elements[name].name = name; // $FlowFixMe

      this["_".concat(name)] = this.elements[name];

      if (index !== -1) {
        this.drawOrder = [].concat(_toConsumableArray(this.drawOrder.slice(0, index)), [name], _toConsumableArray(this.drawOrder.slice(index)));
      } else {
        this.drawOrder.push(name);
      }
    }
  }, {
    key: "draw",
    value: function draw() {
      var parentTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      var now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      // console.log('draw collection', now, this.name)
      // if (this.name === 'fig3') {
      //   const ga = new GlobalAnimation();
      //   const deltaTime = new Date().getTime() - ga.diagramDrawStart;
      //   // console.log(this.name, deltaTime)
      // }
      // if (this.name === 'circumference') {
      //   const ga = new GlobalAnimation();
      //   const deltaTime = new Date().getTime() - ga.diagramDrawStart;
      //   // console.log(this.name, deltaTime)
      // }
      if (this.isShown) {
        this.animations.nextFrame(now); // Deprecate

        this.setNextTransform(now); // Deprecate

        this.setNextColor(now); // set next color can end up hiding an element when disolving out

        if (!this.isShown) {
          return;
        } // Deprecate


        this.setNextCustomAnimation(now); // this.lastDrawParentTransform = parentTransform._dup();
        // this.lastDrawElementTransform = this.transform._dup();

        this.lastDrawElementTransformPosition = {
          parentCount: parentTransform.order.length,
          elementCount: this.transform.order.length
        }; // const finalParentTransform = this.processParentTransform(parentTransform);

        var newTransform = parentTransform.transform(this.transform);
        var pulseTransforms = this.transformWithPulse(now, newTransform); // eslint-disable-next-line prefer-destructuring

        this.lastDrawTransform = pulseTransforms[0]; // this.lastDrawPulseTransform = pulseTransforms[0]._dup();

        for (var k = 0; k < pulseTransforms.length; k += 1) {
          for (var i = 0, j = this.drawOrder.length; i < j; i += 1) {
            this.elements[this.drawOrder[i]].draw(pulseTransforms[k], now);
          }
        }
      }
    }
  }, {
    key: "show",
    value: function show() {
      var listToShow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      _get(_getPrototypeOf(DiagramElementCollection.prototype), "show", this).call(this);

      listToShow.forEach(function (element) {
        if (element instanceof DiagramElementCollection) {
          element.showAll();
        } else {
          element.show();
        }
      });
    }
  }, {
    key: "hide",
    value: function hide() {
      var listToShow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      _get(_getPrototypeOf(DiagramElementCollection.prototype), "hide", this).call(this);

      listToShow.forEach(function (element) {
        if (element instanceof DiagramElementCollection) {
          element.hideAll();
        } else {
          element.show();
        }
      });
    }
  }, {
    key: "showAll",
    value: function showAll() {
      this.show();

      for (var i = 0, j = this.drawOrder.length; i < j; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.show();

        if (typeof element.hideAll === 'function') {
          element.showAll();
        }
      }
    }
  }, {
    key: "hideAll",
    value: function hideAll() {
      this.hide();

      for (var i = 0, j = this.drawOrder.length; i < j; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.hide();

        if (typeof element.hideAll === 'function') {
          element.hideAll();
        }
      }
    }
  }, {
    key: "showOnly",
    value: function showOnly(listToShow) {
      this.hideAll();
      this.show();

      for (var i = 0, j = listToShow.length; i < j; i += 1) {
        var element = listToShow[i];

        if (element) {
          element.show();
        } else {
          throw Error("Diagram Element Error: Element does not exist at position ".concat(i));
        }
      }
    }
  }, {
    key: "hideOnly",
    value: function hideOnly(listToHide) {
      this.showAll();

      for (var i = 0, j = listToHide.length; i < j; i += 1) {
        var element = listToHide[i];
        element.hide();
      }
    } // This will only search elements within the collection for a touch
    // if the collection is touchable. Note, the elements can be queried
    // directly still, and will return if they are touched if they themselves
    // are touchable.

  }, {
    key: "isBeingTouched",
    value: function isBeingTouched(glLocation) {
      if (!this.isTouchable) {
        return false;
      }

      if (this.touchInBoundingRect) {
        var boundingRect = this.getGLBoundingRect();

        if (glLocation.x >= boundingRect.left && glLocation.x <= boundingRect.right && glLocation.y <= boundingRect.top && glLocation.y >= boundingRect.bottom) {
          return true;
        }
      }

      for (var i = 0, j = this.drawOrder.length; i < j; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.isShown === true) {
          if (element.isBeingTouched(glLocation)) {
            return true;
          }
        }
      }

      return false;
    }
  }, {
    key: "resizeHtmlObject",
    value: function resizeHtmlObject() {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.resizeHtmlObject();
      }
    }
  }, {
    key: "resize",
    value: function resize() {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.resize();
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.clear();
      }
    }
  }, {
    key: "setFirstTransform",
    value: function setFirstTransform() {
      var parentTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      // const finalParentTransform = this.processParentTransform(parentTransform);
      var firstTransform = parentTransform.transform(this.transform);
      this.lastDrawTransform = firstTransform;

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.setFirstTransform(firstTransform);
      }

      this.setMoveBoundaryToDiagram();
    }
  }, {
    key: "getGLBoundaries",
    value: function getGLBoundaries() {
      var boundaries = [];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.isShown) {
          var elementBoundaries = element.getGLBoundaries();
          boundaries = boundaries.concat(elementBoundaries);
        }
      }

      return boundaries;
    }
  }, {
    key: "getVertexSpaceBoundaries",
    value: function getVertexSpaceBoundaries() {
      var boundaries = [];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.isShown) {
          var elementBoundaries = element.getVertexSpaceBoundaries();
          boundaries = boundaries.concat(elementBoundaries);
        }
      }

      return boundaries;
    }
  }, {
    key: "getGLBoundingRect",
    value: function getGLBoundingRect() {
      var glAbsoluteBoundaries = this.getGLBoundaries();
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(glAbsoluteBoundaries);
    }
  }, {
    key: "getVertexSpaceBoundingRect",
    value: function getVertexSpaceBoundingRect() {
      var boundaries = this.getVertexSpaceBoundaries();
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(boundaries);
    }
  }, {
    key: "getRelativeGLBoundingRect",
    value: function getRelativeGLBoundingRect() {
      var boundingRect = this.getGLBoundingRect();
      var location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0).transformBy(this.lastDrawTransform.matrix());
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](boundingRect.left - location.x, boundingRect.bottom - location.y, boundingRect.width, boundingRect.height);
    }
  }, {
    key: "getRelativeVertexSpaceBoundingRect",
    value: function getRelativeVertexSpaceBoundingRect() {
      var boundingRect = this.getVertexSpaceBoundingRect();
      var location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](boundingRect.left - location.x, boundingRect.bottom - location.y, boundingRect.width, boundingRect.height);
    }
  }, {
    key: "updateLimits",
    value: function updateLimits(limits, transforms) {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.updateLimits(limits, transforms);
      }

      this.diagramLimits = limits;
      this.diagramTransforms = transforms;
    }
  }, {
    key: "updateHTMLElementTie",
    value: function updateHTMLElementTie( // pixelSpaceToDiagramSpaceTransform: Transform,
    // diagramToPixelSpaceScale: Point,
    container) {
      _get(_getPrototypeOf(DiagramElementCollection.prototype), "updateHTMLElementTie", this).call(this, // pixelSpaceToDiagramSpaceTransform,
      // diagramToPixelSpaceScale,
      // diagramToGLSpaceTransformMatrix,
      container);

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.updateHTMLElementTie( // pixelSpaceToDiagramSpaceTransform,
        // diagramToPixelSpaceScale,
        // diagramToGLSpaceTransformMatrix,
        container);
      }
    } // Returns an array of touched elements.
    // In a collection, elements defined later in the collection.order
    // array are on top of earlier elements. The touched array
    // is sorted to have elements on top first, where the collection containing
    // the elements will be before it's elements. For example, the array
    // would be ordered as:
    //  0: top collection
    //  1 to n: n top elements in collection
    //  n+1: second top collection
    //  n+2 to m: top elements in second top colleciton.

  }, {
    key: "getTouched",
    value: function getTouched(glLocation) {
      if (!this.isTouchable && !this.hasTouchableElements) {
        return [];
      }

      var touched = [];

      if (this.touchInBoundingRect || this.isTouchable) {
        if (this.isBeingTouched(glLocation)) {
          touched.push(this);
        }
      }

      for (var i = this.drawOrder.length - 1; i >= 0; i -= 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.isShown === true) {
          touched = touched.concat(element.getTouched(glLocation));
        } // If there is an element that is touched, then this collection should
        // also be touched.
        // if (touched.length > 0 && this.isTouchable) {
        //   touched = [this].concat(touched);
        // }

      }

      return touched;
    }
  }, {
    key: "stop",
    value: function stop() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var forceSetToEndOfPlan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      _get(_getPrototypeOf(DiagramElementCollection.prototype), "stop", this).call(this, cancelled, forceSetToEndOfPlan);

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.stop(cancelled, forceSetToEndOfPlan); // element.cancel(forceSetToEndOfPlan);
      }
    }
  }, {
    key: "setFont",
    value: function setFont(fontSize) {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.setFont(fontSize);
      }
    }
  }, {
    key: "setColor",
    value: function setColor(color) {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.setColor(color);
      }

      this.color = color.slice();
    }
  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.setOpacity(opacity);
      }

      this.color[3] = opacity;
    }
  }, {
    key: "getElementTransforms",
    value: function getElementTransforms() {
      var out = {};

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        out[element.name] = element.transform._dup();
      }

      return out;
    }
  }, {
    key: "setElementTransforms",
    value: function setElementTransforms(elementTransforms) {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.name in elementTransforms) {
          element.transform = elementTransforms[element.name];
        }
      }
    }
  }, {
    key: "reorder",
    value: function reorder() {
      var _this7 = this;

      this.drawOrder.sort(function (a, b) {
        var elemA = _this7.elements[a];
        var elemB = _this7.elements[b];
        return elemB.drawPriority - elemA.drawPriority;
      }); // this.elements.sort((a, b) => {
      //   const elemA
      //   b.z - a.z});

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element instanceof DiagramElementCollection) {
          element.reorder();
        }
      }
    }
  }, {
    key: "animateToTransforms",
    value: function animateToTransforms(elementTransforms) // translationPath: (Point, Point, number) => Point = linearPath,
    {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var rotDirection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var easeFunction = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _tools_math__WEBPACK_IMPORTED_MODULE_2__["easeinout"];
      var callbackMethod = callback;
      var timeToAnimate = 0;

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.name in elementTransforms) {
          if (element.isShown) {
            if (!elementTransforms[element.name].isEqualTo(element.transform)) {
              element.animations.new().delay(delay).transform({
                target: elementTransforms[element.name],
                duration: time,
                rotDirection: rotDirection,
                progression: easeFunction,
                onFinish: callbackMethod
              }).start(); // only want to send callback once

              callbackMethod = null;
              timeToAnimate = time + delay;
            }
          } else {
            element.transform = elementTransforms[element.name]._dup();
          }
        }
      }

      if (timeToAnimate === 0 && callbackMethod != null) {
        callbackMethod(true);
      }

      return timeToAnimate;
    }
  }, {
    key: "getAllPrimatives",
    value: function getAllPrimatives() {
      var elements = [];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element instanceof DiagramElementCollection) {
          elements = [].concat(_toConsumableArray(elements), _toConsumableArray(element.getAllElements()));
        } else {
          elements.push(element);
        }
      }

      return elements;
    }
  }, {
    key: "getAllElements",
    value: function getAllElements() {
      var elements = [];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        elements.push(element);
      }

      return elements;
    } // Get all ineractive elemnts, but only go as deep as a
    // DiagramElementColleciton if it is touchable or movable

  }, {
    key: "getAllCurrentlyInteractiveElements",
    value: function getAllCurrentlyInteractiveElements() {
      var elements = [];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]]; // if (element.isShown) {

        if (element instanceof DiagramElementCollection) {
          if (!element.isTouchable && !element.isMovable && element.hasTouchableElements && !element.isInteractive) {
            elements = [].concat(_toConsumableArray(elements), _toConsumableArray(element.getAllCurrentlyInteractiveElements()));
          }
        }

        if (element.isTouchable || element.isMovable || element.isInteractive) {
          elements.push(element);
        } // }

      }

      return elements;
    } // disolveWithDelay(
    //   delay: number = 1,
    //   time: number = 1,
    //   disolve: 'in' | 'out' = 'in',
    //   callback: ?(boolean) => void = null,
    // ): void {
    //   for (let i = 0; i < this.order.length; i += 1) {
    //     const element = this.elements[this.order[i]];
    //     console.log(element.name)
    //     element.disolveWithDelay(delay, time, disolve, callback);
    //   }
    // }
    // // deprecate
    // disolveElementsOut(
    //   time: number = 1,
    //   callback: ?(boolean) => void = null,
    // ): void {
    //   for (let i = 0; i < this.order.length; i += 1) {
    //     const element = this.elements[this.order[i]];
    //     if (element instanceof DiagramElementCollection) {
    //       element.disolveElementsOut(time, callback);
    //     } else {
    //       element.disolveOut(time, callback);
    //     }
    //   }
    // }
    // // deprecate
    // disolveElementsIn(
    //   time: number = 1,
    //   callback: ?(boolean) => void = null,
    // ): void {
    //   for (let i = 0; i < this.order.length; i += 1) {
    //     const element = this.elements[this.order[i]];
    //     if (element instanceof DiagramElementCollection) {
    //       element.disolveElementsIn(time, callback);
    //     } else {
    //       element.disolveIn(time, callback);
    //     }
    //   }
    // }
    // This method is here as a convenience method for content item selectors
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "goToStep",
    value: function goToStep(step) {
      var elem = document.getElementById('id__lesson_item_selector_0');
      var elems = [];

      if (elem != null) {
        if (elem.children.length > 0) {
          for (var i = 0; i < elem.children.length; i += 1) {
            elems.push(elem.children[i]);
          }
        }
      }

      elems.forEach(function (e, index) {
        if (index === step) {
          e.classList.add('lesson__item_selector_selected');
        } else {
          e.classList.remove('lesson__item_selector_selected');
        }
      });
    }
  }, {
    key: "setMovable",
    value: function setMovable() {
      var movable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (movable) {
        this.hasTouchableElements = true;
        this.isMovable = true;
      }
    }
  }, {
    key: "updateContext",
    value: function updateContext(context) {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.updateContext(context);
      }
    }
  }]);

  return DiagramElementCollection;
}(DiagramElement);



/***/ }),

/***/ "./src/js/diagram/Gesture.js":
/*!***********************************!*\
  !*** ./src/js/diagram/Gesture.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Diagram__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Diagram */ "./src/js/diagram/Diagram.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

 // eslint-disable-next-line import/no-cycle



var Gesture =
/*#__PURE__*/
function () {
  function Gesture(diagram) {
    _classCallCheck(this, Gesture);

    this.diagram = diagram; // console.log(diagram.canvas.offsetWidth)
    // this.diagram.canvas.onmousedown = this.mouseDownHandler.bind(this);
    // this.diagram.canvas.onmouseup = this.mouseUpHandler.bind(this);
    // this.diagram.canvas.onmousemove = this.mouseMoveHandler.bind(this);

    this.addEvent('mousedown', this.mouseDownHandler, false);
    this.addEvent('mouseup', this.mouseUpHandler, false);
    this.addEvent('mousemove', this.mouseMoveHandler, false);
    this.addEvent('touchstart', this.touchStartHandler, false);
    this.addEvent('touchend', this.touchEndHandler, false);
    this.addEvent('touchmove', this.touchMoveHandler, false); // this.diagram.canvas.addEventListener(
    //   'touchstart',
    //   this.touchStartHandler.bind(this), false,
    // );
    // this.diagram.canvas.addEventListener(
    //   'touchend',
    //   this.touchEndHandler.bind(this), false,
    // );
    // this.diagram.canvas.addEventListener(
    //   'touchmove',
    //   this.touchMoveHandler.bind(this), false,
    // );

    this.enable = true; // Override these if you want to use your own touch handlers

    this.start = this.diagram.touchDownHandler.bind(this.diagram);
    this.end = this.diagram.touchUpHandler.bind(this.diagram);
    this.move = this.diagram.touchMoveHandler.bind(this.diagram);
  }

  _createClass(Gesture, [{
    key: "addEvent",
    value: function addEvent(event, method, flag) {
      this.diagram.gestureCanvas.addEventListener(event, method.bind(this), flag);
    }
  }, {
    key: "removeEvent",
    value: function removeEvent(event, method, flag) {
      this.diagram.gestureCanvas.removeEventListener(event, method.bind(this), flag);
    }
  }, {
    key: "startHandler",
    value: function startHandler(point) {
      if (this.enable) {
        this.mouseDown = true;
        this.previousPoint = point;
        return this.start(point);
      }

      return false;
    }
  }, {
    key: "endHandler",
    value: function endHandler() {
      this.mouseDown = false;
      this.end();
    }
  }, {
    key: "moveHandler",
    value: function moveHandler(event, point) {
      if (this.enable && this.mouseDown) {
        var disableEvent = this.move(this.previousPoint, point);

        if (disableEvent) {
          event.preventDefault();
        }

        this.previousPoint = point;
      }

      event.preventDefault();
    }
  }, {
    key: "touchStartHandler",
    value: function touchStartHandler(event) {
      var touch = event.touches[0];
      var disableEvent = this.startHandler(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](touch.clientX, touch.clientY));

      if (disableEvent) {
        event.preventDefault();
      }
    }
  }, {
    key: "mouseDownHandler",
    value: function mouseDownHandler(event) {
      var disableEvent = this.startHandler(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](event.clientX, event.clientY));

      if (disableEvent) {
        event.preventDefault();
      }
    }
  }, {
    key: "touchMoveHandler",
    value: function touchMoveHandler(event) {
      var touch = event.touches[0];
      this.moveHandler(event, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](touch.clientX, touch.clientY));
    }
  }, {
    key: "mouseMoveHandler",
    value: function mouseMoveHandler(event) {
      this.moveHandler(event, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](event.clientX, event.clientY));
    }
  }, {
    key: "mouseUpHandler",
    value: function mouseUpHandler() {
      this.endHandler();
    }
  }, {
    key: "touchEndHandler",
    value: function touchEndHandler() {
      this.endHandler();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeEvent('mousedown', this.mouseDownHandler, false);
      this.removeEvent('mouseup', this.mouseUpHandler, false);
      this.removeEvent('mousemove', this.mouseMoveHandler, false);
      this.removeEvent('touchstart', this.touchStartHandler, false);
      this.removeEvent('touchend', this.touchEndHandler, false);
      this.removeEvent('touchmove', this.touchMoveHandler, false);
    }
  }]);

  return Gesture;
}();

/* harmony default export */ __webpack_exports__["default"] = (Gesture);

/***/ }),

/***/ "./src/js/diagram/webgl/GlobalAnimation.js":
/*!*************************************************!*\
  !*** ./src/js/diagram/webgl/GlobalAnimation.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Singleton class that contains projects global variables
var GlobalAnimation =
/*#__PURE__*/
function () {
  // Method for requesting the next animation frame
  // used to cancel animation frames
  function GlobalAnimation() {
    _classCallCheck(this, GlobalAnimation);

    // If the instance alread exists, then don't create a new instance.
    // If it doesn't, then setup some default values.
    if (!GlobalAnimation.instance) {
      this.requestNextAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
      GlobalAnimation.instance = this;
      this.drawQueue = [];
      this.nextDrawQueue = []; // this.drawScene = this.draw.bind(this);
    }

    return GlobalAnimation.instance;
  }

  _createClass(GlobalAnimation, [{
    key: "draw",
    value: function draw(now) {
      this.drawQueue = this.nextDrawQueue;
      this.nextDrawQueue = [];
      var nowSeconds = now * 0.001;

      for (var i = 0; i < this.drawQueue.length; i += 1) {
        this.drawQueue[i](nowSeconds);
      }

      this.drawQueue = [];
    }
  }, {
    key: "queueNextFrame",
    value: function queueNextFrame(func) {
      // if (!(func in this.nextDrawQueue)) {
      this.nextDrawQueue.push(func); // }
      // if (triggerFrameRequest) {
      //   this.animateNextFrame();
      // }

      if (this.nextDrawQueue.length === 1) {
        this.animateNextFrame();
      }
    } // Queue up an animation frame

  }, {
    key: "animateNextFrame",
    value: function animateNextFrame() {
      cancelAnimationFrame(this.animationId); // $FlowFixMe

      var nextFrame = this.requestNextAnimationFrame.call(window, this.draw.bind(this));
      this.animationId = nextFrame;
    }
  }]);

  return GlobalAnimation;
}(); // Do not automatically create and instance and return it otherwise can't
// mock elements in jest
// // const globalvars: Object = new GlobalVariables();
// // Object.freeze(globalvars);


/* harmony default export */ __webpack_exports__["default"] = (GlobalAnimation);

/***/ }),

/***/ "./src/js/diagram/webgl/shaders.js":
/*!*****************************************!*\
  !*** ./src/js/diagram/webgl/shaders.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var vertex = {
  simple: {
    source: 'attribute vec2 a_position;' + 'uniform mat3 u_matrix;' + 'uniform float u_z;' + 'void main() {' + 'gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, u_z, 1);' + '}',
    varNames: ['a_position', 'u_matrix', 'u_z']
  },
  withTexture: {
    source: 'attribute vec2 a_position;' + 'attribute vec2 a_texcoord;' + 'uniform mat3 u_matrix;' + 'uniform float u_z;' + 'varying vec2 v_texcoord;' + 'void main() {' + 'gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, u_z, 1);' + 'v_texcoord = a_texcoord;' + '}',
    varNames: ['a_position', 'a_texcoord', 'u_matrix', 'u_z']
  }
};
var fragment = {
  simple: {
    source: 'precision mediump float;' + 'uniform vec4 u_color;' + 'void main() {' + 'gl_FragColor = u_color;' + '}',
    varNames: ['u_color']
  },
  withTexture: {
    source: 'precision mediump float;' + 'uniform vec4 u_color;' + 'uniform int u_use_texture;' + 'uniform sampler2D u_texture;' + 'varying vec2 v_texcoord;' + 'void main() {' + 'if ( u_use_texture == 1) {' + 'gl_FragColor = texture2D(u_texture, v_texcoord);' + '} else {' + 'gl_FragColor = u_color;' + '}' + '}',
    varNames: ['u_color', 'u_use_texture', 'u_texture']
  },
  text: {
    source: 'precision mediump float;' + 'uniform vec4 u_color;' + 'uniform sampler2D u_texture;' + 'varying vec2 v_texcoord;' + 'void main() {' // + 'float a = texture2D(u_texture, v_texcoord).a;'
    // + 'if ( a < 0.2 ) {'
    //   + 'a = a / 1.2;'
    // + '}'
    // + 'gl_FragColor = vec4(u_color.rgb, min(a * 1.2, 1.0) * u_color.a);'
    // + '}'
    // + 'gl_FragColor = a * u_color;'
    + 'vec4 c = texture2D(u_texture, v_texcoord);' + 'gl_FragColor = vec4(c.a * u_color.rgb, c.a * u_color.a);' + '}',
    varNames: ['u_color', 'u_texture']
  }
};

var getShaders = function getShaders() {
  var vName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'simple';
  var fName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'simple';

  if (Object.hasOwnProperty.call(vertex, vName) && Object.hasOwnProperty.call(fragment, fName)) {
    return {
      vertexSource: vertex[vName].source,
      fragmentSource: fragment[fName].source,
      varNames: vertex[vName].varNames.concat(fragment[fName].varNames)
    };
  }

  return {
    vertexSource: '',
    fragmentSource: '',
    varNames: []
  };
};

/* harmony default export */ __webpack_exports__["default"] = (getShaders);

/***/ }),

/***/ "./src/js/diagram/webgl/webgl.js":
/*!***************************************!*\
  !*** ./src/js/diagram/webgl/webgl.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _shaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shaders */ "./src/js/diagram/webgl/shaders.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



function createProgram(gl, vertexShader, fragmentShader) {
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);

  if (success) {
    return program;
  }

  gl.deleteProgram(program);
  return null;
}

function createShader(gl, type, source) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

  if (success) {
    return shader;
  }

  gl.deleteShader(shader);
  return null;
}

function createProgramFromScripts(gl, vertexShaderSource, fragmentShaderSource) {
  // Get the strings for our GLSL shaders
  // const vertexShaderSource = document.getElementById(vertexScript).text;
  // const fragmentShaderSource = document.getElementById(fragScript).text;
  // create GLSL shaders, upload the GLSL source, compile the shaders
  var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource); // Link the two shaders into a program

  if (vertexShader && fragmentShader) {
    return createProgram(gl, vertexShader, fragmentShader);
  }

  return null;
}

function getGLLocations(gl, program, locationsList) {
  var i;
  var newLocations = {};
  var loc;

  for (i = 0; i < locationsList.length; i += 1) {
    loc = locationsList[i];

    if (loc[0] === 'a') {
      newLocations[loc] = gl.getAttribLocation(program, loc);
    }

    if (loc[0] === 'u') {
      newLocations[loc] = gl.getUniformLocation(program, loc);
    }
  }

  return newLocations;
} // function resizeCanvasToDisplaySize(canvas) {
//   // const mul = multiplier || 1;
//   const mul = window.devicePixelRatio || 1;
//   const width = canvas.clientWidth * mul || 0;
//   const height = canvas.clientHeight * mul || 0;
//   if (canvas.width !== width || canvas.height !== height) {
//     canvas.width = width;     // eslint-disable-line no-param-reassign
//     canvas.height = height;   // eslint-disable-line no-param-reassign
//     return true;
//   }
//   return false;
// }

/* eslint-disable */


function autoResize(event) {// let contRect = document.getElementById('container').getBoundingClientRect();
  // let diagRect = document.getElementById('diagram').getBoundingClientRect();
  // let textRect = document.getElementById('learning_text_container').getBoundingClientRect();
  // let canvRect = this.gl.canvas.getBoundingClientRect();
  // // console.log(contRect)
  // console.log(this.gl.canvas.getBoundingClientRect());
  // // this.gl.canvas.height = 500;
  // // this.gl.canvas.width = 500;
  // // this.gl.canvas.width=500;
  // // this.gl.viewport(diagRect.left, canvRect.height+canvRect.top, textRect.width, textRect.height); 
  // // this.gl.viewport(0,0,100,100);
  // // console.log(document.getElementById('Diagram').left);
}

var WebGLInstance =
/*#__PURE__*/
function () {
  _createClass(WebGLInstance, [{
    key: "addTexture",
    // locations: Object;
    value: function addTexture(id, glTexture, type) {
      if (this.textures[id] && this.textures[id].glTexture != null) {
        return this.textures[id].index;
      }

      var index = 0;

      if (this.textures[id]) {
        index = this.textures[id].index;
      } else {
        index = Object.keys(this.textures).length;
      }

      this.textures[id] = {
        glTexture: glTexture,
        index: index,
        type: type
      };
      return index;
    }
  }, {
    key: "getProgram",
    value: function getProgram(vertexShader, fragmentShader) {
      this.programs.forEach(function (program) {
        if (program.vertexShader === vertexShader && program.fragmentShader === fragmentShader) {
          return program.program;
        }
      });
      var shaders = Object(_shaders__WEBPACK_IMPORTED_MODULE_0__["default"])(vertexShader, fragmentShader);
      var newProgram = createProgramFromScripts(this.gl, shaders.vertexSource, shaders.fragmentSource);
      var programDetails = {
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        program: newProgram,
        locations: getGLLocations(this.gl, newProgram, shaders.varNames)
      };
      this.programs.push(programDetails);
      return this.programs.length - 1;
    }
  }, {
    key: "useProgram",
    value: function useProgram(programIndex) {
      var program = this.programs[programIndex];

      if (this.lastUsedProgram !== program) {
        this.gl.useProgram(program.program);
        this.lastUsedProgram = program.program;
      }

      return program.locations;
    }
  }]);

  function WebGLInstance(canvas, // vertexSource: string,
  // fragmentSource: string,
  backgroundColor) {
    _classCallCheck(this, WebGLInstance);

    var gl = canvas.getContext('webgl', {
      antialias: true
    });
    this.programs = [];
    this.lastUsedProgram = null;
    this.textures = {};

    if (gl instanceof WebGLRenderingContext) {
      this.gl = gl; // this.program = createProgramFromScripts(
      //   this.gl,
      //   vertexSource,
      //   fragmentSource,
      // );
      // this.locations = getGLLocations(this.gl, this.program, shaderLocations);
      // Prep canvas
      // resizeCanvasToDisplaySize(this.gl.canvas);

      this.resize(); // Tell WebGL how to convert from clip space to pixels
      // this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
      // gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      // this.gl.viewport(0, 500, 500, 500);   // Tell WebGL how to convert from clip space to pixels
      // Clear the canvas
      // const bc = backgroundColor;
      // this.gl.clearColor(bc[0], bc[1], bc[2], bc[3]);

      this.gl.clearColor(0, 0, 0, 0);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      this.gl.disable(this.gl.DEPTH_TEST);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.enable(gl.BLEND); // this.gl.useProgram(this.program);
      // window.addEventListener('resize', autoResize.bind(this, event));
    }
  }

  _createClass(WebGLInstance, [{
    key: "resize",
    value: function resize() {
      var realToCSSPixels = window.devicePixelRatio; // console.log("asdf");
      // Lookup the size the browser is displaying the canvas in CSS pixels
      // and compute a size needed to make our drawingbuffer match it in
      // device pixels.

      var displayWidth = Math.floor(this.gl.canvas.clientWidth * realToCSSPixels);
      var displayHeight = Math.floor(this.gl.canvas.clientHeight * realToCSSPixels); // Check if the canvas is not the same size.

      if (this.gl.canvas.width !== displayWidth || this.gl.canvas.height !== displayHeight) {
        // Make the canvas the same size
        this.gl.canvas.width = displayWidth;
        this.gl.canvas.height = displayHeight;
      }

      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
    } // resize() {
    //   var width = this.gl.canvas.clientWidth;
    //   var height = this.gl.canvas.clientHeight;
    //   if (this.gl.canvas.width != width ||
    //       this.gl.canvas.height != height) {
    //      this.gl.canvas.width = width;
    //      this.gl.canvas.height = height;
    //      return true;
    //   }
    //   return false;
    // }
    // var needToRender = true;  // draw at least once
    // function checkRender() {
    //    if (resize() || needToRender) {
    //      needToRender = false;
    //      drawStuff();
    //    }
    //    requestAnimationFrame(checkRender);
    // }
    // checkRender();

  }]);

  return WebGLInstance;
}();

/* harmony default export */ __webpack_exports__["default"] = (WebGLInstance);

/***/ }),

/***/ "./src/js/tools/color.js":
/*!*******************************!*\
  !*** ./src/js/tools/color.js ***!
  \*******************************/
/*! exports provided: RGBToArray, HexToArray, cssColorToArray, colorArrayToRGB, colorArrayToRGBA, getCSSColors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBToArray", function() { return RGBToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HexToArray", function() { return HexToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssColorToArray", function() { return cssColorToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colorArrayToRGB", function() { return colorArrayToRGB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colorArrayToRGBA", function() { return colorArrayToRGBA; });
/* harmony import */ var _colorNames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorNames */ "./src/js/tools/colorNames.js");
/* harmony import */ var _getCssColors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getCssColors */ "./src/js/tools/getCssColors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCSSColors", function() { return _getCssColors__WEBPACK_IMPORTED_MODULE_1__["default"]; });

 // official css color names

 // Function that converts any rgb or rgba string to an array of rgba numbers
// between 0 and 1

function RGBToArray(color) {
  // Reduce the rgb(a) string to just numbers
  var colString = color;
  colString = colString.replace(/.*\(/i, '');
  colString = colString.replace(/\)/i, '');
  var strArray = colString.split(','); // Go through each rgb(a) value and normalize to 1.0

  var value = strArray.map(function (x, index) {
    if (index < 3) {
      return parseInt(x, 10) / 255.0;
    }

    return parseFloat(x);
  }); // If an alpha value isn't included, then include it with default value 1.0

  if (value.length === 3) {
    value.push(1);
  }

  return value;
} // Function that converts any hex color string to an array of rgba numbers
// between 0 and 1 (where alpha is always 1)


function HexToArray(color) {
  var colHex = color.slice(1);

  if (colHex.length < 6) {
    colHex = "".concat(colHex[0]).concat(colHex[0]).concat(colHex[1]).concat(colHex[1]).concat(colHex[2]).concat(colHex[2]);
  }

  var col = [parseInt(colHex.slice(0, 2), 16) / 255.0, parseInt(colHex.slice(2, 4), 16) / 255.0, parseInt(colHex.slice(4, 6), 16) / 255.0, 1];
  return col;
}

function cssColorToArray(cssColorString) {
  var oNames = Object(_colorNames__WEBPACK_IMPORTED_MODULE_0__["default"])(); // Official css color names

  var color = cssColorString.slice(0); // If the color is an official name, then replace it with the hex rgb
  // equivalent

  if (color in oNames) {
    color = oNames[color];
  } // colorValue is the rgba array of colors between 0 and 1


  var colorValue = []; // If color string starts with 'rgb' (and therefore also 'rgba')

  if (color.toLowerCase().startsWith('rgb')) {
    colorValue = RGBToArray(color); // If color string starts with '#' it is hex
  } else if (color.startsWith('#')) {
    colorValue = HexToArray(color);
  } // If the color value array is defined, then add it to the final
  // dictionary


  if (colorValue.length > 0) {
    return colorValue;
  }

  return null;
}

function colorArrayToRGBA(color) {
  return "rgba(".concat(Math.floor(color[0] * 255), ",").concat(Math.floor(color[1] * 255), ",").concat(Math.floor(color[2] * 255), ",").concat(color[3], ")");
}

function colorArrayToRGB(color) {
  return "rgb(".concat(Math.floor(color[0] * 255), ",").concat(Math.floor(color[1] * 255), ",").concat(Math.floor(color[2] * 255), ")");
}



/***/ }),

/***/ "./src/js/tools/colorNames.js":
/*!************************************!*\
  !*** ./src/js/tools/colorNames.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// @ flow
function colorNames() {
  return {
    aliceblue: '#f0f8ff',
    antiquewhite: '#faebd7',
    aqua: '#00ffff',
    aquamarine: '#7fffd4',
    azure: '#f0ffff',
    beige: '#f5f5dc',
    bisque: '#ffe4c4',
    black: '#000000',
    blanchedalmond: '#ffebcd',
    blue: '#0000ff',
    blueviolet: '#8a2be2',
    brown: '#a52a2a',
    burlywood: '#deb887',
    cadetblue: '#5f9ea0',
    chartreuse: '#7fff00',
    chocolate: '#d2691e',
    coral: '#ff7f50',
    cornflowerblue: '#6495ed',
    cornsilk: '#fff8dc',
    crimson: '#dc143c',
    cyan: '#00ffff',
    darkblue: '#00008b',
    darkcyan: '#008b8b',
    darkgoldenrod: '#b8860b',
    darkgray: '#a9a9a9',
    darkgrey: '#a9a9a9',
    darkgreen: '#006400',
    darkkhaki: '#bdb76b',
    darkmagenta: '#8b008b',
    darkolivegreen: '#556b2f',
    darkorange: '#ff8c00',
    darkorchid: '#9932cc',
    darkred: '#8b0000',
    darksalmon: '#e9967a',
    darkseagreen: '#8fbc8f',
    darkslateblue: '#483d8b',
    darkslategray: '#2f4f4f',
    darkslategrey: '#2f4f4f',
    darkturquoise: '#00ced1',
    darkviolet: '#9400d3',
    deeppink: '#ff1493',
    deepskyblue: '#00bfff',
    dimgray: '#696969',
    dimgrey: '#696969',
    dodgerblue: '#1e90ff',
    firebrick: '#b22222',
    floralwhite: '#fffaf0',
    forestgreen: '#228b22',
    fuchsia: '#ff00ff',
    gainsboro: '#dcdcdc',
    ghostwhite: '#f8f8ff',
    gold: '#ffd700',
    goldenrod: '#daa520',
    gray: '#808080',
    grey: '#808080',
    green: '#008000',
    greenyellow: '#adff2f',
    honeydew: '#f0fff0',
    hotpink: '#ff69b4',
    indianred: '#cd5c5c',
    indigo: '#4b0082',
    ivory: '#fffff0',
    khaki: '#f0e68c',
    lavender: '#e6e6fa',
    lavenderblush: '#fff0f5',
    lawngreen: '#7cfc00',
    lemonchiffon: '#fffacd',
    lightblue: '#add8e6',
    lightcoral: '#f08080',
    lightcyan: '#e0ffff',
    lightgoldenrodyellow: '#fafad2',
    lightgray: '#d3d3d3',
    lightgrey: '#d3d3d3',
    lightgreen: '#90ee90',
    lightpink: '#ffb6c1',
    lightsalmon: '#ffa07a',
    lightseagreen: '#20b2aa',
    lightskyblue: '#87cefa',
    lightslategray: '#778899',
    lightslategrey: '#778899',
    lightsteelblue: '#b0c4de',
    lightyellow: '#ffffe0',
    lime: '#00ff00',
    limegreen: '#32cd32',
    linen: '#faf0e6',
    magenta: '#ff00ff',
    maroon: '#800000',
    mediumaquamarine: '#66cdaa',
    mediumblue: '#0000cd',
    mediumorchid: '#ba55d3',
    mediumpurple: '#9370db',
    mediumseagreen: '#3cb371',
    mediumslateblue: '#7b68ee',
    mediumspringgreen: '#00fa9a',
    mediumturquoise: '#48d1cc',
    mediumvioletred: '#c71585',
    midnightblue: '#191970',
    mintcream: '#f5fffa',
    mistyrose: '#ffe4e1',
    moccasin: '#ffe4b5',
    navajowhite: '#ffdead',
    navy: '#000080',
    oldlace: '#fdf5e6',
    olive: '#808000',
    olivedrab: '#6b8e23',
    orange: '#ffa500',
    orangered: '#ff4500',
    orchid: '#da70d6',
    palegoldenrod: '#eee8aa',
    palegreen: '#98fb98',
    paleturquoise: '#afeeee',
    palevioletred: '#db7093',
    papayawhip: '#ffefd5',
    peachpuff: '#ffdab9',
    peru: '#cd853f',
    pink: '#ffc0cb',
    plum: '#dda0dd',
    powderblue: '#b0e0e6',
    purple: '#800080',
    rebeccapurple: '#663399',
    red: '#ff0000',
    rosybrown: '#bc8f8f',
    royalblue: '#4169e1',
    saddlebrown: '#8b4513',
    salmon: '#fa8072',
    sandybrown: '#f4a460',
    seagreen: '#2e8b57',
    seashell: '#fff5ee',
    sienna: '#a0522d',
    silver: '#c0c0c0',
    skyblue: '#87ceeb',
    slateblue: '#6a5acd',
    slategray: '#708090',
    slategrey: '#708090',
    snow: '#fffafa',
    springgreen: '#00ff7f',
    steelblue: '#4682b4',
    tan: '#d2b48c',
    teal: '#008080',
    thistle: '#d8bfd8',
    tomato: '#ff6347',
    turquoise: '#40e0d0',
    violet: '#ee82ee',
    wheat: '#f5deb3',
    white: '#ffffff',
    whitesmoke: '#f5f5f5',
    yellow: '#ffff00',
    yellowgreen: '#9acd32'
  };
} // function a(input) {
//   console.log(input);
// }


/* harmony default export */ __webpack_exports__["default"] = (colorNames);

/***/ }),

/***/ "./src/js/tools/g2.js":
/*!****************************!*\
  !*** ./src/js/tools/g2.js ***!
  \****************************/
/*! exports provided: point, Point, line, Line, distance, minAngleDiff, deg, normAngle, Transform, TransformLimit, Rect, Translation, Scale, Rotation, spaceToSpaceTransform, getBoundingRect, linearPath, curvedPath, quadraticBezier, translationPath, polarToRect, rectToPolar, getDeltaAngle, normAngleTo90, threePointAngle, randomPoint, getMaxTimeFromVelocity, getMoveTime, parsePoint, clipAngle, spaceToSpaceScale */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "point", function() { return point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return Point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "line", function() { return line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minAngleDiff", function() { return minAngleDiff; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deg", function() { return deg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normAngle", function() { return normAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transform", function() { return Transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransformLimit", function() { return TransformLimit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rect", function() { return Rect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Translation", function() { return Translation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scale", function() { return Scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rotation", function() { return Rotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spaceToSpaceTransform", function() { return spaceToSpaceTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBoundingRect", function() { return getBoundingRect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearPath", function() { return linearPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "curvedPath", function() { return curvedPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadraticBezier", function() { return _quadraticBezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translationPath", function() { return translationPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polarToRect", function() { return polarToRect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rectToPolar", function() { return rectToPolar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDeltaAngle", function() { return getDeltaAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normAngleTo90", function() { return normAngleTo90; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "threePointAngle", function() { return threePointAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomPoint", function() { return randomPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMaxTimeFromVelocity", function() { return getMaxTimeFromVelocity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMoveTime", function() { return getMoveTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parsePoint", function() { return parsePoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipAngle", function() { return clipAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spaceToSpaceScale", function() { return spaceToSpaceScale; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./src/js/tools/math.js");
/* harmony import */ var _m2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./m2 */ "./src/js/tools/m2.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// 2D geometry functions including:
//  - Point
//  - Line
//  - minAngleDiff
//  - normAngle
 // import { Console } from '../../tools/tools';

 // function nullDefaultNum(input: number | null, defaultValue: number): number {
//   if (input === null) {
//     return defaultValue;
//   }
//   return input;
// }
// export type PointType = {
//   x: number;
//   y: number;
//   _dup(): PointType;
//   // sub(): PointType;
//   // add(): PointType;
//   // distance(): number;
//   // round(): PointType;
//   // rotate(): PointType;
//   // isEqualTo: boolean;
//   // isNotEqualTo: boolean;
//   // isOnLine: boolean;
//   // isOnUnboundLine: boolean;
//   // console: void;
//   // isInPolygon: boolean;
//   // isOnPolygon: boolean;
// };

function _quadraticBezier(P0, P1, P2, t) {
  return (1 - t) * ((1 - t) * P0 + t * P1) + t * ((1 - t) * P1 + t * P2);
}

function clipAngle(angleToClip, clipTo) {
  var angle = angleToClip;

  if (clipTo === '0to360') {
    if (angle < 0) {
      angle += Math.PI * 2;
    }

    if (angle >= Math.PI * 2) {
      angle -= Math.PI * 2;
    }
  }

  if (clipTo === '-180to180') {
    if (angle < -Math.PI) {
      angle += Math.PI * 2;
    }

    if (angle >= Math.PI) {
      angle -= Math.PI * 2;
    }
  }

  return angle;
}

var Rect =
/*#__PURE__*/
function () {
  function Rect(left, bottom, width, height) {
    _classCallCheck(this, Rect);

    this.left = left;
    this.width = width;
    this.height = height;
    this.bottom = bottom;
    this.top = bottom + height;
    this.right = left + width;
  }

  _createClass(Rect, [{
    key: "_dup",
    value: function _dup() {
      return new Rect(this.left, this.bottom, this.width, this.height);
    }
  }]);

  return Rect;
}();
/* eslint-disable comma-dangle */


var Point =
/*#__PURE__*/
function () {
  _createClass(Point, null, [{
    key: "zero",
    value: function zero() {
      return new Point(0, 0);
    }
  }, {
    key: "Unity",
    value: function Unity() {
      return new Point(1, 1);
    }
  }]);

  function Point(x, y) {
    _classCallCheck(this, Point);

    this.x = x;
    this.y = y;
  }

  _createClass(Point, [{
    key: "_dup",
    value: function _dup() {
      return new Point(this.x, this.y);
    }
  }, {
    key: "scale",
    value: function scale(scalar) {
      return new Point(this.x * scalar, this.y * scalar);
    }
  }, {
    key: "sub",
    value: function sub(qOrX) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (qOrX instanceof Point) {
        return new Point(this.x - qOrX.x, this.y - qOrX.y);
      }

      return new Point(this.x - qOrX, this.y - y);
    }
  }, {
    key: "add",
    value: function add(qOrX) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (qOrX instanceof Point) {
        return new Point(this.x + qOrX.x, this.y + qOrX.y);
      }

      return new Point(this.x + qOrX, this.y + y);
    }
  }, {
    key: "distance",
    value: function distance() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      return new Point(Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.x, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.y, precision));
    }
  }, {
    key: "clip",
    value: function clip(min, max) {
      var minX;
      var minY;
      var maxX;
      var maxY;

      if (min instanceof Point) {
        minX = min.x;
        minY = min.y;
      } else {
        minX = min;
        minY = min;
      }

      if (max instanceof Point) {
        maxX = max.x;
        maxY = max.y;
      } else {
        maxX = max;
        maxY = max;
      }

      var x = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(this.x, minX, maxX);
      var y = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(this.y, minY, maxY);
      return new Point(x, y);
    }
  }, {
    key: "transformBy",
    value: function transformBy(matrix) {
      var transformedPoint = _m2__WEBPACK_IMPORTED_MODULE_1__["transform"](matrix, this.x, this.y);
      return new Point(transformedPoint[0], transformedPoint[1]);
    }
  }, {
    key: "quadraticBezier",
    value: function quadraticBezier(p1, p2, t) {
      var bx = _quadraticBezier(this.x, p1.x, p2.x, t);

      var by = _quadraticBezier(this.y, p1.y, p2.y, t);

      return new Point(bx, by);
    }
  }, {
    key: "rotate",
    value: function rotate(angle, center) {
      var c = Math.cos(angle);
      var s = Math.sin(angle);
      var matrix = [c, -s, s, c]; // eslint-disable-line indent

      var centerPoint = center || new Point(0, 0);
      var pt = this.sub(centerPoint);
      return new Point(matrix[0] * pt.x + matrix[1] * pt.y + centerPoint.x, matrix[2] * pt.x + matrix[3] * pt.y + centerPoint.y);
    }
    /* eslint-enable comma-dangle */

  }, {
    key: "isEqualTo",
    value: function isEqualTo(q, precision) {
      var pr = this;
      var qr = q;

      if (typeof precision === 'number') {
        pr = this.round(precision);
        qr = qr.round(precision);
      }

      if (pr.x === qr.x && pr.y === qr.y) {
        return true;
      }

      return false;
    }
  }, {
    key: "isNotEqualTo",
    value: function isNotEqualTo(q, precision) {
      return !this.isEqualTo(q, precision);
    }
    /* eslint-disable no-use-before-define */

  }, {
    key: "isOnLine",
    value: function isOnLine(l, precision) {
      return l.hasPointOn(this, precision);
    }
  }, {
    key: "getShaddowOnLine",
    value: function getShaddowOnLine(l) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var shaddow = new Line(this, 1, l.angle() + Math.PI / 2);

      var _shaddow$intersectsWi = shaddow.intersectsWith(l),
          intersect = _shaddow$intersectsWi.intersect; // console.log(intersect, inLine, onLine, )


      if (intersect != null && intersect.isOnLine(l, precision)) {
        return intersect;
      }

      return null;
    }
  }, {
    key: "shaddowIsOnLine",
    value: function shaddowIsOnLine(l) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var intersect = this.getShaddowOnLine(l, precision);

      if (intersect != null) {
        return true;
      }

      return false;
    }
  }, {
    key: "isOnUnboundLine",
    value: function isOnUnboundLine(l, precision) {
      return l.hasPointAlong(this, precision);
    }
    /* eslint-enable no-use-before-define */
    // console(text?: string) {
    //   Console(`${text || ''} + ${this.x}, ${this.y}`);
    // }

  }, {
    key: "isInPolygon",
    value: function isInPolygon(polygonVertices) {
      var windingNumber = 0;
      var n = polygonVertices.length - 1;
      var v = polygonVertices.slice();
      var p = this;
      var popLastPoint = false; // polygonVertices needs to have the last vertex the same as the first vertex

      if (v[0].isNotEqualTo(v[n])) {
        v.push(v[0]);
        popLastPoint = true;
        n += 1;
      }

      for (var i = 0; i < n; i += 1) {
        if (v[i].y <= p.y) {
          if (v[i + 1].y > p.y) {
            // an upward crossing
            if (Point.isLeft(v[i], v[i + 1], p) > 0) {
              // P left of  edge
              windingNumber += 1; // have  a valid up intersect
            }
          }
        } else if (v[i + 1].y <= p.y) {
          // start y > P.y (no test needed)
          // a downward crossing
          if (Point.isLeft(v[i], v[i + 1], p) < 0) {
            // P right of  edge
            windingNumber -= 1; // have  a valid down intersect
          }
        }
      }

      if (popLastPoint) {
        v.pop();
      }

      if (windingNumber === 0) {
        return false;
      }

      return true;
    }
  }, {
    key: "isOnPolygon",
    value: function isOnPolygon(polygonVertices) {
      var popLastPoint = false;
      var p = this;
      var n = polygonVertices.length - 1; // Number of sides

      var v = polygonVertices.slice(); // polygonVertices needs to have the last vertex the same as the first vertex

      if (v[0].isNotEqualTo(v[n])) {
        v.push(v[0]);
        popLastPoint = true;
        n += 1;
      }

      for (var i = 0; i < n; i += 1) {
        // if(p.isEqualTo(v[i])) {
        //   return true;
        // }

        /* eslint-disable-next-line  no-use-before-define */
        var l = line(v[i], v[i + 1]);

        if (p.isOnLine(l)) {
          if (popLastPoint) {
            v.pop();
          }

          return true;
        }
      }

      if (p.isInPolygon(polygonVertices)) {
        if (popLastPoint) {
          v.pop();
        }

        return true;
      }

      if (popLastPoint) {
        v.pop();
      }

      return false;
    }
  }, {
    key: "toPolar",
    value: function toPolar() {
      return {
        mag: Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2)),
        angle: Math.atan2(this.y, this.x)
      };
    }
  }, {
    key: "toDelta",
    value: function toDelta(delta, percent) {
      var translationStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'linear';
      var translationOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        rot: 1,
        magnitude: 0.5,
        offset: 0.5,
        controlPoint: null,
        direction: ''
      };
      // eslint-disable-next-line no-use-before-define
      var pathPoint = translationPath(translationStyle, this._dup(), delta, percent, translationOptions);
      return pathPoint;
    }
  }], [{
    key: "isLeft",
    value: function isLeft(p0, p1, p2) {
      return (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y);
    }
  }]);

  return Point;
}();

function linearPath(start, delta, percent) {
  return start.add(delta.x * percent, delta.y * percent);
}

function curvedPath(start, delta, percent, options) {
  var o = options;
  var angle = Math.atan2(delta.y, delta.x);
  var midPoint = start.add(new Point(delta.x * o.offset, delta.y * o.offset));
  var dist = delta.toPolar().mag * o.magnitude;
  var controlPoint = options.controlPoint;

  if (controlPoint == null) {
    var direction = options.direction;
    var xDelta = Math.cos(angle + o.rot * Math.PI / 2);
    var yDelta = Math.sin(angle + o.rot * Math.PI / 2);

    if (direction === 'up') {
      if (yDelta < 0) {
        yDelta = Math.sin(angle + o.rot * Math.PI / 2 + Math.PI);
      }
    } else if (direction === 'down') {
      if (yDelta > 0) {
        yDelta = Math.sin(angle + o.rot * Math.PI / 2 + Math.PI);
      }
    } else if (direction === 'left') {
      if (xDelta > 0) {
        xDelta = Math.cos(angle + o.rot * Math.PI / 2 + Math.PI);
      }
    } else if (direction === 'right') {
      if (xDelta < 0) {
        xDelta = Math.cos(angle + o.rot * Math.PI / 2 + Math.PI);
      }
    }

    controlPoint = new Point(midPoint.x + dist * xDelta, midPoint.y + dist * yDelta);
  }

  var p0 = start;
  var p1 = controlPoint;
  var p2 = start.add(delta);
  var t = percent;

  var bx = _quadraticBezier(p0.x, p1.x, p2.x, t);

  var by = _quadraticBezier(p0.y, p1.y, p2.y, t);

  return new Point(bx, by);
}

function translationPath() {
  var pathType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'linear';
  var start = arguments.length > 1 ? arguments[1] : undefined;
  var delta = arguments.length > 2 ? arguments[2] : undefined;
  var percent = arguments.length > 3 ? arguments[3] : undefined;
  var options = arguments.length > 4 ? arguments[4] : undefined;

  if (pathType === 'linear') {
    return linearPath(start, delta, percent);
  }

  if (pathType === 'curved') {
    return curvedPath(start, delta, percent, options);
  }

  return new Point(0, 0);
}

function point(x, y) {
  return new Point(x, y);
}

function pointinRect(q, p1, p2, precision) {
  if (precision === undefined || precision === null) {
    if (q.x >= Math.min(p1.x, p2.x) && q.x <= Math.max(p1.x, p2.x) && q.y >= Math.min(p1.y, p2.y) && q.y <= Math.max(p1.y, p2.y)) {
      return true;
    }
  } else if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(q.x, precision) >= Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(Math.min(p1.x, p2.x), precision) && Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(q.x, precision) <= Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(Math.max(p1.x, p2.x), precision) && Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(q.y, precision) >= Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(Math.min(p1.y, p2.y), precision) && Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(q.y, precision) <= Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(Math.max(p1.y, p2.y), precision)) {
    return true;
  }

  return false;
}

function distance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function deg(angle) {
  return angle * 180 / Math.PI;
}

function minAngleDiff(angle1, angle2) {
  if (angle1 === angle2) {
    return 0;
  }

  return Math.atan2(Math.sin(angle1 - angle2), Math.cos(angle1 - angle2));
}

function normAngle(angle) {
  var newAngle = angle;

  while (newAngle >= Math.PI * 2.0) {
    newAngle -= Math.PI * 2.0;
  }

  while (newAngle < 0) {
    newAngle += Math.PI * 2.0;
  }

  return newAngle;
}

function normAngleTo90(angle) {
  var newAngle = normAngle(angle);

  if (newAngle > Math.PI / 2 && newAngle < Math.PI) {
    newAngle += Math.PI;
  }

  if (newAngle === Math.PI) {
    newAngle = 0;
  }

  if (newAngle > Math.PI && newAngle < Math.PI * 3 / 2) {
    newAngle -= Math.PI;
  }

  return newAngle;
}

function getDeltaAngle(startAngle, targetAngle) {
  var rotDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var start = normAngle(startAngle);
  var target = normAngle(targetAngle);
  var dir = rotDirection;

  if (start === target) {
    return 0;
  }

  if (dir === 2) {
    if (start > target) {
      dir = -1;
    } else {
      dir = 1;
    }
  }

  if (rotDirection === 0) {
    return minAngleDiff(target, start);
  }

  if (rotDirection === 1) {
    if (start > target) {
      return Math.PI * 2 - start + target;
    }
  }

  if (rotDirection === -1) {
    if (target > start) {
      return -start - (Math.PI * 2 - target);
    }
  }

  return target - start; // if (rotDirection === 2) {
  //   if (target > start) {
  //     return target - start;
  //   }
  // }
  // if (rotDirection === 2) {
  //   if (start + rotDiff < 0) {
  //     rotDiff = Math.PI * 2 + rotDiff;
  //   } else if (start + rotDiff > Math.PI * 2) {
  //     rotDiff = -(Math.PI * 2 - rotDiff);
  //   }
  // } else if (rotDiff * rotDirection < 0) {
  //   rotDiff = rotDirection * Math.PI * 2.0 + rotDiff;
  // }
  // return rotDiff;
}

var Line =
/*#__PURE__*/
function () {
  function Line(p1, p2OrMag) {
    var angle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, Line);

    this.p1 = p1._dup();

    if (p2OrMag instanceof Point) {
      this.p2 = p2OrMag._dup();
      this.ang = Math.atan2(this.p2.y - this.p1.y, this.p2.x - this.p1.x);
    } else {
      this.p2 = this.p1.add(p2OrMag * Math.cos(angle), p2OrMag * Math.sin(angle));
      this.ang = angle;
    }

    this.A = this.p2.y - this.p1.y;
    this.B = this.p1.x - this.p2.x;
    this.C = this.A * this.p1.x + this.B * this.p1.y;
    this.distance = distance(this.p1, this.p2);
  }

  _createClass(Line, [{
    key: "getPoint",
    value: function getPoint() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      if (index === 2) {
        return this.p2;
      }

      return this.p1;
    }
  }, {
    key: "getYFromX",
    value: function getYFromX(x) {
      if (this.B !== 0) {
        return (this.C - this.A * x) / this.B;
      }

      return null;
    }
  }, {
    key: "getXFromY",
    value: function getXFromY(y) {
      if (this.A !== 0) {
        return (this.C - this.B * y) / this.A;
      }

      return null;
    }
  }, {
    key: "angle",
    value: function angle() {
      return this.ang;
    }
  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      var lineRounded = new Line(this.p1, this.p2);
      lineRounded.A = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(lineRounded.A, precision);
      lineRounded.B = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(lineRounded.B, precision);
      lineRounded.C = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(lineRounded.C, precision);
      lineRounded.ang = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(lineRounded.ang, precision);
      lineRounded.distance = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(lineRounded.distance, precision);
      return lineRounded;
    }
  }, {
    key: "length",
    value: function length() {
      // return this.p1.sub(this.p2).distance();
      return this.distance;
    }
    /* eslint-disable comma-dangle */

  }, {
    key: "midpoint",
    value: function midpoint() {
      var length = this.length();
      var direction = this.p2.sub(this.p1);
      var angle = Math.atan2(direction.y, direction.x);
      var midpoint = point(this.p1.x + length / 2 * Math.cos(angle), this.p1.y + length / 2 * Math.sin(angle));
      return midpoint;
    }
    /* eslint-enable comma-dangle */

  }, {
    key: "hasPointAlong",
    value: function hasPointAlong(p, precision) {
      if (precision === undefined || precision === null) {
        if (this.C === this.A * p.x + this.B * p.y) {
          return true;
        }
      } else if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.C, precision) === Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.A * p.x + this.B * p.y, precision)) {
        return true;
      }

      return false;
    } // perpendicular distance of line to point

  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(p, precision) {
      return Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(Math.abs(this.A * p.x + this.B * p.y - this.C) / Math.sqrt(Math.pow(this.A, 2) + Math.pow(this.B, 2)), precision);
    }
  }, {
    key: "hasPointOn",
    value: function hasPointOn(p, precision) {
      if (this.hasPointAlong(p, precision)) {
        if (pointinRect(p, this.p1, this.p2, precision)) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "isEqualTo",
    value: function isEqualTo(line2, precision) {
      var l1 = this;
      var l2 = line2;

      if (typeof precision === 'number') {
        l1 = l1.round(precision);
        l2 = l2.round(precision);
        l1.p1 = l1.p1.round(precision);
        l1.p2 = l1.p2.round(precision);
        l2.p1 = l2.p1.round(precision);
        l2.p2 = l2.p2.round(precision);
      }

      if (l1.A !== l2.A) {
        return false;
      }

      if (l1.B !== l2.B) {
        return false;
      }

      if (l1.C !== l2.C) {
        return false;
      }

      if (l1.p1.isNotEqualTo(l2.p1) && l1.p1.isNotEqualTo(l2.p2)) {
        return false;
      }

      if (l1.p2.isNotEqualTo(l2.p1) && l1.p2.isNotEqualTo(l2.p2)) {
        return false;
      }

      return true;
    }
  }, {
    key: "isOnSameLineAs",
    value: function isOnSameLineAs(line2) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var l1 = this.round(precision);
      var l2 = line2.round(precision); // If A and B are zero, then this is not a line

      if (l1.A === 0 && l1.B === 0 || l2.A === 0 && l2.B === 0) {
        return false;
      } // If A is 0, then it must be 0 on the other line. Similar with B


      if (l1.A !== 0) {
        var scale = l2.A / l1.A;

        if (l1.B * scale !== l2.B) {
          return false;
        }

        if (l1.C * scale !== l2.C) {
          return false;
        }

        return true;
      }

      if (l2.A !== 0) {
        var _scale = l1.A / l2.A;

        if (l2.B * _scale !== l1.B) {
          return false;
        }

        if (l2.C * _scale !== l1.C) {
          return false;
        }

        return true;
      }

      if (l1.B !== 0) {
        var _scale2 = l2.B / l1.B;

        if (l1.A * _scale2 !== l2.A) {
          return false;
        }

        if (l1.C * _scale2 !== l2.C) {
          return false;
        }

        return true;
      }

      if (l2.B !== 0) {
        var _scale3 = l1.B / l2.B;

        if (l2.A * _scale3 !== l1.A) {
          return false;
        }

        if (l2.C * _scale3 !== l1.C) {
          return false;
        }

        return true;
      }

      return true;
    }
  }, {
    key: "intersectsWith",
    value: function intersectsWith(line2) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var l2 = line2; // line2.round(precision);

      var l1 = this; // this.round(precision);

      var det = l1.A * l2.B - l2.A * l1.B;

      if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(det, precision) !== 0) {
        var i = point(0, 0);
        i.x = (l2.B * l1.C - l1.B * l2.C) / det;
        i.y = (l1.A * l2.C - l2.A * l1.C) / det;

        if (pointinRect(i, l1.p1, l1.p2, precision) && pointinRect(i, l2.p1, l2.p2, precision)) {
          return {
            onLine: true,
            inLine: true,
            intersect: i
          };
        }

        return {
          onLine: true,
          inLine: false,
          intersect: i
        };
      }

      if (det === 0 && l1.isOnSameLineAs(l2, precision)) {
        // if the lines are colliner then:
        //   - if overlapping,
        //   - if partially overlapping: the intersect point is halfway between
        //     overlapping ends
        //   - if one line is within the other line, the intersect point is
        //     halfway between the midpoints
        //   - if not overlapping, the intersect point is halfway between the nearest ends
        // let l1 = this;
        if (!l1.p1.isOnLine(l2, precision) && !l1.p2.isOnLine(l2, precision) && !l2.p1.isOnLine(l1, precision) && !l2.p2.isOnLine(l1, precision)) {
          var line11 = new Line(l1.p1, l2.p1);
          var line12 = new Line(l1.p1, l2.p2);
          var line21 = new Line(l1.p2, l2.p1);
          var line22 = new Line(l1.p2, l2.p2);

          var _i2 = line11.midpoint();

          var len = line11.length();

          if (line12.length() < len) {
            _i2 = line12.midpoint();
            len = line12.length();
          }

          if (line21.length() < len) {
            _i2 = line21.midpoint();
            len = line21.length();
          }

          if (line22.length() < len) {
            _i2 = line22.midpoint();
            len = line22.length();
          }

          return {
            onLine: true,
            inLine: false,
            intersect: _i2
          };
        }

        if (l1.p1.isOnLine(l2, precision) && l1.p2.isOnLine(l2, precision) && (!l2.p1.isOnLine(l1, precision) || !l2.p2.isOnLine(l1, precision)) || l2.p1.isOnLine(l1, precision) && l2.p2.isOnLine(l1, precision) && (!l1.p1.isOnLine(l2, precision) || !l1.p2.isOnLine(l2, precision))) {
          var _midLine = new Line(l1.midpoint(), l2.midpoint());

          return {
            onLine: true,
            inLine: true,
            intersect: _midLine.midpoint()
          };
        }

        var midLine;

        if (l1.p1.isOnLine(l2, precision) && !l1.p2.isOnLine(l2, precision) && l2.p1.isOnLine(l1, precision) && !l2.p2.isOnLine(l1, precision)) {
          midLine = new Line(l1.p1, l2.p1);
        }

        if (l1.p1.isOnLine(l2, precision) && !l1.p2.isOnLine(l2, precision) && !l2.p1.isOnLine(l1, precision) && l2.p2.isOnLine(l1, precision)) {
          midLine = new Line(l1.p1, l2.p2);
        }

        if (!l1.p1.isOnLine(l2, precision) && l1.p2.isOnLine(l2, precision) && l2.p1.isOnLine(l1, precision) && !l2.p2.isOnLine(l1, precision)) {
          midLine = new Line(l1.p2, l2.p1);
        }

        if (!l1.p1.isOnLine(l2, precision) && l1.p2.isOnLine(l2, precision) && !l2.p1.isOnLine(l1, precision) && l2.p2.isOnLine(l1, precision)) {
          midLine = new Line(l1.p2, l2.p2);
        }

        var _i;

        if (midLine instanceof Line) {
          _i = midLine.midpoint();
        }

        return {
          onLine: true,
          inLine: true,
          intersect: _i
        };
      }

      return {
        onLine: false,
        inLine: false,
        intersect: undefined
      };
    }
  }]);

  return Line;
}();

function line(p1, p2) {
  return new Line(p1, p2);
}

var Rotation =
/*#__PURE__*/
function () {
  function Rotation(angle) {
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    _classCallCheck(this, Rotation);

    this.r = angle;
    this.name = name;
  }

  _createClass(Rotation, [{
    key: "matrix",
    value: function matrix() {
      return _m2__WEBPACK_IMPORTED_MODULE_1__["rotationMatrix"](this.r);
    }
  }, {
    key: "sub",
    value: function sub() {
      var rotToSub = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Rotation(0, this.name);
      return new Rotation(this.r - rotToSub.r, this.name);
    }
  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      return new Rotation(Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.r, precision), this.name);
    }
  }, {
    key: "add",
    value: function add() {
      var rotToAdd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Rotation(0, this.name);
      return new Rotation(this.r + rotToAdd.r, this.name);
    }
  }, {
    key: "mul",
    value: function mul() {
      var rotToMul = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Rotation(1, this.name);
      return new Rotation(this.r * rotToMul.r, this.name);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      return new Rotation(this.r, this.name);
    }
  }]);

  return Rotation;
}();

var Translation =
/*#__PURE__*/
function (_Point) {
  _inherits(Translation, _Point);

  function Translation(tx) {
    var _this;

    var ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

    _classCallCheck(this, Translation);

    if (tx instanceof Point) {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Translation).call(this, tx.x, tx.y)); // this.x = tx.x;
      // this.y = tx.y;
    } else {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Translation).call(this, tx, ty)); // this.x = tx;
      // this.y = ty;
    }

    _this.name = name;
    return _possibleConstructorReturn(_this);
  }

  _createClass(Translation, [{
    key: "matrix",
    value: function matrix() {
      return _m2__WEBPACK_IMPORTED_MODULE_1__["translationMatrix"](this.x, this.y);
    }
  }, {
    key: "sub",
    value: function sub() {
      var translationToSub = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Translation(0, 0);
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var t = new Point(0, 0);

      if (typeof translationToSub === 'number') {
        t = new Translation(translationToSub, y);
      } else {
        t = translationToSub;
      }

      return new Translation(this.x - t.x, this.y - t.y, this.name);
    }
  }, {
    key: "add",
    value: function add() {
      var translationToAdd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Translation(0, 0);
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var t = new Point(0, 0);

      if (typeof translationToAdd === 'number') {
        t = new Translation(translationToAdd, y);
      } else {
        t = translationToAdd;
      }

      return new Translation(this.x + t.x, this.y + t.y, this.name);
    }
  }, {
    key: "mul",
    value: function mul() {
      var translationToMul = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Translation(1, 1);
      return new Translation(this.x * translationToMul.x, this.y * translationToMul.y, this.name);
    }
  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      return new Translation(Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.x, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.y, precision), this.name);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      return new Translation(this.x, this.y, this.name);
    }
  }]);

  return Translation;
}(Point);

var Scale =
/*#__PURE__*/
function (_Point2) {
  _inherits(Scale, _Point2);

  function Scale(sx, sy) {
    var _this2;

    var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

    _classCallCheck(this, Scale);

    if (sx instanceof Point) {
      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Scale).call(this, sx.x, sx.y)); // this.x = sx.x;
      // this.y = sx.y;
    } else {
      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Scale).call(this, sx, sy)); // this.x = sx;
      // this.y = sy;
    }

    _this2.name = name;
    return _possibleConstructorReturn(_this2);
  }

  _createClass(Scale, [{
    key: "matrix",
    value: function matrix() {
      return _m2__WEBPACK_IMPORTED_MODULE_1__["scaleMatrix"](this.x, this.y);
    }
  }, {
    key: "sub",
    value: function sub() {
      var scaleToSub = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Scale(0, 0);
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var s = new Point(0, 0);

      if (typeof scaleToSub === 'number') {
        s = new Scale(scaleToSub, y);
      } else {
        s = scaleToSub;
      }

      return new Scale(this.x - s.x, this.y - s.y, this.name);
    }
  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      return new Scale(Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.x, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.y, precision), this.name);
    }
  }, {
    key: "add",
    value: function add() {
      var scaleToAdd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Scale(0, 0);
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var s = new Point(0, 0);

      if (typeof scaleToAdd === 'number') {
        s = new Scale(scaleToAdd, y);
      } else {
        s = scaleToAdd;
      }

      return new Scale(this.x + s.x, this.y + s.y, this.name);
    }
  }, {
    key: "mul",
    value: function mul() {
      var scaleToMul = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Scale(1, 1);

      if (scaleToMul instanceof Scale || scaleToMul instanceof Point) {
        return new Scale(this.x * scaleToMul.x, this.y * scaleToMul.y);
      }

      return new Scale(this.x * scaleToMul, this.y * scaleToMul, this.name);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      return new Scale(this.x, this.y, this.name);
    }
  }]);

  return Scale;
}(Point);

var TransformLimit =
/*#__PURE__*/
function () {
  function TransformLimit(scale, rotation, translation) {
    _classCallCheck(this, TransformLimit);

    this.scale = scale;
    this.rotation = rotation;
    this.translation = translation;
  }

  _createClass(TransformLimit, [{
    key: "_dup",
    value: function _dup() {
      return new TransformLimit(this.scale, this.rotation, this.translation);
    }
  }]);

  return TransformLimit;
}();

var Transform =
/*#__PURE__*/
function () {
  function Transform() {
    var orderOrName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    _classCallCheck(this, Transform);

    if (typeof orderOrName === 'string') {
      this.order = [];
      this.name = orderOrName;
    } else {
      this.order = orderOrName.map(function (t) {
        return t._dup();
      });
      this.name = name;
    } // this.order = order.slice();


    this.index = this.order.length;
    this.calcMatrix();
  }

  _createClass(Transform, [{
    key: "translate",
    value: function translate(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var translation = new Translation(x, y, this.name);
      var order = this.order.slice();

      if (this.index === this.order.length) {
        order.push(translation);
      } else {
        this.order[this.index] = translation;
        this.index += 1;
        this.calcMatrix();
        return this;
      }

      return new Transform(order, this.name);
    }
  }, {
    key: "rotate",
    value: function rotate(r) {
      var rotation = new Rotation(r, this.name);
      rotation.name = this.name;
      var order = this.order.slice();

      if (this.index === this.order.length) {
        order.push(rotation);
      } else {
        this.order[this.index] = rotation;
        this.index += 1;
        this.calcMatrix();
        return this;
      } // this.order.push(new Rotation(r));
      // this.calcMatrix();


      return new Transform(order, this.name);
    }
  }, {
    key: "scale",
    value: function scale(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var scale = new Scale(x, y, this.name);
      var order = this.order.slice();

      if (this.index === this.order.length) {
        order.push(scale);
      } else {
        this.order[this.index] = scale;
        this.index += 1;
        this.calcMatrix();
        return this;
      }

      return new Transform(order, this.name);
    }
  }, {
    key: "calcMatrix",
    value: function calcMatrix() {
      var m = _m2__WEBPACK_IMPORTED_MODULE_1__["identity"]();

      for (var i = this.order.length - 1; i >= 0; i -= 1) {
        m = _m2__WEBPACK_IMPORTED_MODULE_1__["mul"](m, this.order[i].matrix());
      } // this.mat = m2.copy(m);
      // return m;


      this.mat = m;
    }
  }, {
    key: "update",
    value: function update(index) {
      if (index < this.order.length) {
        this.index = index;
      }

      return this;
    }
  }, {
    key: "t",
    value: function t() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var count = 0;

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Translation) {
          if (count === index) {
            return new Point(t.x, t.y);
          }

          count += 1;
        }
      }

      return null;
    }
  }, {
    key: "clipRotation",
    value: function clipRotation(clipTo) {
      for (var i = 0; i < this.order.length; i += 1) {
        var transformStep = this.order[i];

        if (transformStep instanceof Rotation) {
          transformStep.r = clipAngle(transformStep.r, clipTo);
        }
      }
    }
  }, {
    key: "updateTranslation",
    value: function updateTranslation(x) {
      var yOrIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var count = 0;
      var actualIndex = index;

      if (x instanceof Point) {
        actualIndex = yOrIndex;
      }

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Translation) {
          if (count === actualIndex) {
            this.order[i] = new Translation(x, yOrIndex, this.name);
            this.calcMatrix();
            return;
          }

          count += 1;
        }
      }
    }
  }, {
    key: "s",
    value: function s() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var count = 0;

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Scale) {
          if (count === index) {
            return new Point(t.x, t.y);
          }

          count += 1;
        }
      }

      return null;
    }
  }, {
    key: "toDelta",
    value: function toDelta(delta, percent, translationStyle, translationOptions) // translationPath: (Point, Point, number, ?number, ?number) => Point,
    // direction: number = 1,
    // mag: number = 0.5,
    // offset: number = 0.5,
    {
      var calcTransform = this._dup();

      for (var i = 0; i < this.order.length; i += 1) {
        var stepStart = this.order[i];
        var stepDelta = delta.order[i];

        if (stepStart instanceof Scale && stepDelta instanceof Scale) {
          calcTransform.order[i] = stepStart.add(stepDelta.mul(percent));
        }

        if (stepStart instanceof Rotation && stepDelta instanceof Rotation) {
          calcTransform.order[i] = new Rotation(stepStart.r + stepDelta.r * percent);
        }

        if (stepStart instanceof Translation && stepDelta instanceof Translation) {
          calcTransform.order[i] = new Translation(translationPath(translationStyle, stepStart, stepDelta, percent, translationOptions));
        }
      }

      return calcTransform;
    }
  }, {
    key: "updateScale",
    value: function updateScale(x) {
      var yOrIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var count = 0;
      var actualIndex = index;

      if (x instanceof Point) {
        actualIndex = yOrIndex;
      }

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Scale) {
          if (count === actualIndex) {
            this.order[i] = new Scale(x, yOrIndex, this.name);
            this.calcMatrix();
            return;
          }

          count += 1;
        }
      }
    }
  }, {
    key: "r",
    value: function r() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var count = 0;

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Rotation) {
          if (count === index) {
            return t.r;
          }

          count += 1;
        }
      }

      return null;
    }
  }, {
    key: "updateRotation",
    value: function updateRotation(r) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var count = 0;

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Rotation) {
          if (count === index) {
            this.order[i] = new Rotation(r, this.name);
            this.calcMatrix();
            return;
          }

          count += 1;
        }
      }
    }
  }, {
    key: "m",
    value: function m() {
      return this.mat;
    }
  }, {
    key: "matrix",
    value: function matrix() {
      return this.mat;
    }
  }, {
    key: "isSimilarTo",
    value: function isSimilarTo(transformToCompare) {
      if (transformToCompare.order.length !== this.order.length) {
        return false;
      }

      for (var i = 0; i < this.order.length; i += 1) {
        if (this.order[i].constructor.name !== transformToCompare.order[i].constructor.name) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "isEqualTo",
    value: function isEqualTo(transformToCompare) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;

      // if (transformToCompare.order.length !== this.order.length) {
      //   return false;
      // }
      if (!this.isSimilarTo(transformToCompare)) {
        return false;
      }

      for (var i = 0; i < this.order.length; i += 1) {
        var compare = transformToCompare.order[i];
        var thisTrans = this.order[i];

        if (thisTrans.constructor.name !== compare.constructor.name) {
          return false;
        }

        if (thisTrans instanceof Translation && compare instanceof Translation || thisTrans instanceof Scale && compare instanceof Scale) {
          if (compare.isNotEqualTo(thisTrans, precision)) {
            return false;
          }
        }

        if (thisTrans instanceof Rotation) {
          if (compare.r !== thisTrans.r) {
            return false;
          }
        }
      }

      return true;
    } // Subtract a transform from the current one.
    // If the two transforms have different order types, then just return
    // the current transform.

  }, {
    key: "sub",
    value: function sub() {
      var transformToSubtract = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Transform();

      if (!this.isSimilarTo(transformToSubtract)) {
        return new Transform(this.order, this.name);
      }

      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        // $FlowFixMe (this is already fixed in isSimilarTo check above)
        order.push(this.order[i].sub(transformToSubtract.order[i]));
      }

      return new Transform(order, this.name);
    } // Add a transform to the current one.
    // If the two transforms have different order types, then just return
    // the current transform.

  }, {
    key: "add",
    value: function add() {
      var transformToAdd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Transform();

      if (!this.isSimilarTo(transformToAdd)) {
        return new Transform(this.order, this.name);
      }

      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        // $FlowFixMe (this is already fixed in isSimilarTo check above)
        order.push(this.order[i].add(transformToAdd.order[i]));
      }

      return new Transform(order, this.name);
    } // transform step wise multiplication

  }, {
    key: "mul",
    value: function mul() {
      var transformToMul = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Transform();

      if (!this.isSimilarTo(transformToMul)) {
        return new Transform(this.order, this.name);
      }

      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        // $FlowFixMe (this is already fixed in isSimilarTo check above)
        order.push(this.order[i].mul(transformToMul.order[i]));
      }

      return new Transform(order, this.name);
    }
  }, {
    key: "transform",
    value: function transform(_transform) {
      var t = new Transform([], this.name);
      t.order = _transform.order.concat(this.order);
      t.mat = _m2__WEBPACK_IMPORTED_MODULE_1__["mul"](this.matrix(), _transform.matrix());
      return t;
    }
  }, {
    key: "transformBy",
    value: function transformBy(transform) {
      var t = new Transform([], this.name);
      t.order = this.order.concat(transform.order);
      t.mat = _m2__WEBPACK_IMPORTED_MODULE_1__["mul"](transform.matrix(), this.matrix());
      return t;
    }
  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        order.push(this.order[i].round(precision));
      }

      return new Transform(order, this.name);
    }
  }, {
    key: "clip",
    value: function clip(minTransform, maxTransform, limitLine) {
      if (!this.isSimilarTo(minTransform) || !this.isSimilarTo(maxTransform)) {
        return this._dup();
      }

      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];
        var min = minTransform.order[i];
        var max = maxTransform.order[i];

        if (t instanceof Translation && min instanceof Translation && max instanceof Translation) {
          var x = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(t.x, min.x, max.x);
          var y = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(t.y, min.y, max.y);
          order.push(new Translation(x, y, this.name));
        } else if (t instanceof Rotation && min instanceof Rotation && max instanceof Rotation) {
          order.push(new Rotation(Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(t.r, min.r, max.r), this.name));
        } else if (t instanceof Scale && min instanceof Scale && max instanceof Scale) {
          var _x = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(t.x, min.x, max.x);

          var _y = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(t.y, min.y, max.y);

          order.push(new Scale(_x, _y, this.name));
        }
      }

      var clippedTransform = new Transform(order, this.name);

      if (limitLine != null) {
        var _t = clippedTransform.t();

        if (_t != null) {
          var perpLine = new Line(_t, 1, limitLine.angle() + Math.PI / 2);

          var _perpLine$intersectsW = perpLine.intersectsWith(limitLine),
              intersect = _perpLine$intersectsW.intersect;

          if (intersect) {
            if (intersect.isOnLine(limitLine, 4)) {
              clippedTransform.updateTranslation(intersect);
            } else {
              var p1Dist = distance(intersect, limitLine.p1);
              var p2Dist = distance(intersect, limitLine.p2);

              if (p1Dist < p2Dist) {
                clippedTransform.updateTranslation(limitLine.p1);
              } else {
                clippedTransform.updateTranslation(limitLine.p2);
              }
            }
          }
        }
      }

      return clippedTransform;
    }
  }, {
    key: "clipMag",
    value: function clipMag(zeroThresholdTransform, maxTransform) {
      var vector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      // const min = 0.00001;
      // const max = 1 / min;
      // const zeroS = zeroThresholdTransform.s() || new Point(min, min);
      // const zeroR = zeroThresholdTransform.r() || min;
      // const zeroT = zeroThresholdTransform.t() || new Point(min, min);
      // const maxS = maxTransform.s() || new Point(max, max);
      // const maxR = maxTransform.r() || max;
      // const maxT = maxTransform.t() || new Point(max, max);
      // if (!this.isSimilarTo(zeroThresholdTransform) ||
      //     !this.isSimilarTo(maxTransform)) {
      //   return new Transform(this.order);
      // }
      var order = [];
      var z = zeroThresholdTransform;
      var max = maxTransform;

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Translation) {
          if (vector) {
            var _t$toPolar = t.toPolar(),
                mag = _t$toPolar.mag,
                angle = _t$toPolar.angle;

            var clipM = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(mag, z.translation, max.translation);

            order.push(new Translation(clipM * Math.cos(angle), clipM * Math.sin(angle), this.name));
          } else {
            var x = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(t.x, z.translation, max.translation);

            var y = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(t.y, z.translation, max.translation);

            order.push(new Translation(x, y, this.name));
          }
        } else if (t instanceof Rotation) {
          var r = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(t.r, z.rotation, max.rotation);

          order.push(new Rotation(r, this.name));
        } else if (t instanceof Scale) {
          if (vector) {
            var _t$toPolar2 = t.toPolar(),
                _mag = _t$toPolar2.mag,
                _angle = _t$toPolar2.angle;

            var _clipM = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(_mag, z.scale, max.scale);

            order.push(new Scale(_clipM * Math.cos(_angle), _clipM * Math.sin(_angle), this.name));
          } else {
            var _x2 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(t.x, z.scale, max.scale);

            var _y2 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(t.y, z.scale, max.scale);

            order.push(new Scale(_x2, _y2, this.name));
          }
        }
      }

      return new Transform(order, this.name);
    }
  }, {
    key: "constant",
    value: function constant() {
      var _constant = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Translation) {
          order.push(new Translation(_constant, _constant, this.name));
        } else if (t instanceof Rotation) {
          order.push(new Rotation(_constant, this.name));
        } else if (t instanceof Scale) {
          order.push(new Scale(_constant, _constant, this.name));
        }
      }

      return new Transform(order, this.name);
    }
  }, {
    key: "zero",
    value: function zero() {
      return this.constant(0);
    }
  }, {
    key: "isZero",
    value: function isZero() {
      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Translation || t instanceof Scale) {
          if (t.x !== 0 || t.y !== 0) {
            return false;
          }
        } else if (t instanceof Rotation) {
          if (t.r !== 0) {
            return false;
          }
        }
      }

      return true;
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var t = new Transform(this.order, this.name);
      t.index = this.index;
      return t;
    }
  }, {
    key: "decelerate",
    value: function decelerate(velocity, deceleration, deltaTime, zeroThreshold) {
      var nextV = new Transform();
      var nextT = new Transform();
      var z = zeroThreshold;
      var d = deceleration;

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];
        var v = velocity.order[i]; // const z = zeroThreshold.order[i];

        if (t instanceof Translation && v instanceof Translation) {
          var _v$toPolar = v.toPolar(),
              mag = _v$toPolar.mag,
              angle = _v$toPolar.angle;

          var next = Object(_math__WEBPACK_IMPORTED_MODULE_0__["decelerate"])(0, mag, d.translation, deltaTime, z.translation);

          nextV = nextV.translate(next.v * Math.cos(angle), next.v * Math.sin(angle));
          nextT = nextT.translate(t.x + next.p * Math.cos(angle), t.y + next.p * Math.sin(angle));
        } else if (t instanceof Rotation && v instanceof Rotation) {
          var r = Object(_math__WEBPACK_IMPORTED_MODULE_0__["decelerate"])(t.r, v.r, d.rotation, deltaTime, z.rotation);

          nextV = nextV.rotate(r.v);
          nextT = nextT.rotate(r.p);
        } else if (t instanceof Scale && v instanceof Scale) {
          var _v$toPolar2 = v.toPolar(),
              _mag2 = _v$toPolar2.mag,
              _angle2 = _v$toPolar2.angle;

          var _next = Object(_math__WEBPACK_IMPORTED_MODULE_0__["decelerate"])(0, _mag2, d.scale, deltaTime, z.scale);

          nextV = nextV.scale(_next.v * Math.cos(_angle2), _next.v * Math.sin(_angle2));
          nextT = nextT.scale(t.x + _next.p * Math.cos(_angle2), t.y + _next.p * Math.sin(_angle2));
        } else {
          return {
            v: new Transform(),
            t: new Transform()
          };
        }
      }

      return {
        v: nextV,
        t: nextT
      };
    } // Return the velocity of each element in the transform
    // If the current and previous transforms are inconsistent in type order,
    // then a transform of value 0, but with the same type order as "this" will
    // be returned.

  }, {
    key: "velocity",
    value: function velocity(previousTransform, deltaTime, zeroThreshold, maxTransform) {
      var order = [];

      if (!this.isSimilarTo(previousTransform)) {
        return this.zero();
      }

      var deltaTransform = this.sub(previousTransform);

      for (var i = 0; i < deltaTransform.order.length; i += 1) {
        var t = deltaTransform.order[i];

        if (t instanceof Translation) {
          order.push(new Translation(t.x / deltaTime, t.y / deltaTime));
        } else if (t instanceof Rotation) {
          order.push(new Rotation(t.r / deltaTime));
        } else if (t instanceof Scale) {
          order.push(new Scale(t.x / deltaTime, t.y / deltaTime));
        }
      }

      var v = new Transform(order); // let z = zeroThreshold;
      // let m = maxTransform;
      // if (!this.isSimilarTo(zeroThreshold)) {
      //   z = this.constant(0);
      // }
      // if (!this.isSimilarTo(maxTransform)) {
      //   m = v._dup();
      // }

      return v.clipMag(zeroThreshold, maxTransform);
    }
  }]);

  return Transform;
}();

function spaceToSpaceTransform(s1, s2) {
  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var xScale = s2.x.width / s1.x.width;
  var yScale = s2.y.height / s1.y.height;
  var t = new Transform(name).scale(xScale, yScale).translate(s2.x.bottomLeft - s1.x.bottomLeft * xScale, s2.y.bottomLeft - s1.y.bottomLeft * yScale);
  return t;
}

function spaceToSpaceScale(s1, s2) {
  var xScale = s2.x.width / s1.x.width;
  var yScale = s2.y.height / s1.y.height;
  return new Point(xScale, yScale);
}

function comparePoints(p, currentMin, currentMax, firstPoint) {
  var min = new Point(0, 0);
  var max = new Point(0, 0);

  if (firstPoint) {
    min.x = p.x;
    min.y = p.y;
    max.x = p.x;
    max.y = p.y;
  } else {
    min.x = p.x < currentMin.x ? p.x : currentMin.x;
    min.y = p.y < currentMin.y ? p.y : currentMin.y;
    max.x = p.x > currentMax.x ? p.x : currentMax.x;
    max.y = p.y > currentMax.y ? p.y : currentMax.y;
  }

  return {
    min: min,
    max: max
  };
}

function polarToRect(mag, angle) {
  return new Point(mag * Math.cos(angle), mag * Math.sin(angle));
}

function rectToPolar(x) {
  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var rect;

  if (typeof x === 'number') {
    rect = new Point(x, y);
  } else {
    rect = x;
  }

  var mag = rect.distance();
  var angle = Math.atan2(rect.y, rect.x);

  if (angle < 0) {
    angle += Math.PI * 2;
  }

  return {
    mag: mag,
    angle: angle
  };
} // $FlowFixMe


function getBoundingRect(pointArrays) {
  var firstPoint = true;
  var result = {
    min: new Point(0, 0),
    max: new Point(0, 0)
  };
  pointArrays.forEach(function (pointOrArray) {
    if (Array.isArray(pointOrArray)) {
      pointOrArray.forEach(function (p) {
        result = comparePoints(p, result.min, result.max, firstPoint);
        firstPoint = false;
      });
    } else {
      result = comparePoints(pointOrArray, result.min, result.max, firstPoint);
    }

    firstPoint = false;
  });
  return new Rect(result.min.x, result.min.y, result.max.x - result.min.x, result.max.y - result.min.y);
}

function threePointAngle(p2, p1, p3) {
  var p12 = distance(p1, p2);
  var p13 = distance(p1, p3);
  var p23 = distance(p2, p3);
  return Math.acos((Math.pow(p12, 2) + Math.pow(p13, 2) - Math.pow(p23, 2)) / (2 * p12 * p13));
}

function randomPoint(withinRect) {
  var randPoint = Object(_math__WEBPACK_IMPORTED_MODULE_0__["rand2D"])(withinRect.left, withinRect.bottom, withinRect.right, withinRect.top);
  return new Point(randPoint.x, randPoint.y);
}

function getMaxTimeFromVelocity(startTransform, stopTransform, velocityTransform) {
  var rotDirection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var deltaTransform = stopTransform.sub(startTransform);
  var time = 0;
  deltaTransform.order.forEach(function (delta, index) {
    if (delta instanceof Translation || delta instanceof Scale) {
      var v = velocityTransform.order[index];

      if ((v instanceof Translation || v instanceof Scale) && v.x !== 0 && v.y !== 0) {
        var xTime = Math.abs(delta.x) / v.x;
        var yTime = Math.abs(delta.y) / v.y;
        time = xTime > time ? xTime : time;
        time = yTime > time ? yTime : time;
      }
    }

    var start = startTransform.order[index];
    var target = stopTransform.order[index];

    if (delta instanceof Rotation && start instanceof Rotation && target instanceof Rotation) {
      var rotDiff = getDeltaAngle(start.r, target.r, rotDirection); // eslint-disable-next-line no-param-reassign

      delta.r = rotDiff;
      var _v = velocityTransform.order[index];

      if (_v instanceof Rotation && _v !== 0) {
        var rTime = Math.abs(delta.r / _v.r);
        time = rTime > time ? rTime : time;
      }
    }
  });
  return time;
}

function getMoveTime(startTransform, stopTransform) // 100%/s
{
  var rotDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var translationVelocity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Point(0.25, 0.25);
  var rotationVelocity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2 * Math.PI / 6;
  var scaleVelocity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Point(1, 1);
  var startTransforms;

  if (startTransform instanceof Transform) {
    startTransforms = [startTransform];
  } else {
    startTransforms = startTransform;
  }

  var stopTransforms;

  if (stopTransform instanceof Transform) {
    stopTransforms = [stopTransform];
  } else {
    stopTransforms = stopTransform;
  }

  if (stopTransforms.length !== startTransforms.length) {
    return 0;
  }

  var maxTime = 0;
  startTransforms.forEach(function (startT, index) {
    var stopT = stopTransforms[index];

    var velocity = startT._dup();

    for (var i = 0; i < velocity.order.length; i += 1) {
      var v = velocity.order[i];

      if (v instanceof Translation) {
        v.x = translationVelocity.x;
        v.y = translationVelocity.y;
      } else if (v instanceof Rotation) {
        v.r = rotationVelocity;
      } else {
        v.x = scaleVelocity.x;
        v.y = scaleVelocity.y;
      }
    }

    var time = getMaxTimeFromVelocity(startT, stopT, velocity, rotDirection);

    if (time > maxTime) {
      maxTime = time;
    }
  });
  return maxTime;
}

// point can be defined as:
//    - Point instance
//    - [1, 1]
//    - { x: 1, y: 1 }
function parsePoint(p, onFail) {
  if (p instanceof Point) {
    return p;
  }

  var onFailToUse = onFail;

  if (onFailToUse == null) {
    onFailToUse = null;
  }

  if (Array.isArray(p)) {
    if (p.length === 2) {
      return new Point(p[0], p[1]);
    }

    return onFailToUse;
  }

  if (_typeof(p) === 'object') {
    var keys = Object.keys(p);

    if (keys.indexOf('x') > -1 && keys.indexOf('y') > -1) {
      return new Point(p.x, p.y);
    }
  }

  return onFailToUse;
}



/***/ }),

/***/ "./src/js/tools/getCssColors.js":
/*!**************************************!*\
  !*** ./src/js/tools/getCssColors.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getCSSColors; });
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ "./src/js/tools/color.js");
/* harmony import */ var _getCssVariables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getCssVariables */ "./src/js/tools/getCssVariables.js");


var baseColors = ['blue', 'red', 'yellow', 'green', 'cyan', 'brown', 'orange', 'violet', 'grey', 'black', 'white'];
var shades = ['base', 'lighter', 'light', 'dark', 'darker', 'higher', 'high', 'low', 'lower'];
var paletteColorNames = [];
baseColors.forEach(function (color) {
  shades.forEach(function (shade) {
    paletteColorNames.push("--palette-".concat(color, "-").concat(shade));
  });
});
var diagramColorNames = ['--diagram-background', '--diagram-primary', '--diagram-warning', '--diagram-safe', '--diagram-passive', '--diagram-construction1', '--diagram-construction2', '--diagram-construction3', '--diagram-construction4', '--diagram-construction5', '--diagram-construction6', '--diagram-construction7', '--diagram-construction8', '--diagram-construction9', '--diagram-disabled', '--diagram-disabledDark', '--diagram-disabledDarker', '--diagram-disabledDarkest', '--diagram-push', '--diagram-action', '--diagram-text-base', '--diagram-text-warning', '--diagram-text-plot', '--diagram-text-keyword', '--diagram-text-keyword2', '--diagram-text-latin', '--diagram-text-greek', '--diagram-text-english', '--diagram-quizCheck'];
function getCSSColors() {
  var customColorNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var colors = {};
  var paletteColors = {};
  var diagramColors = {};
  var colorNames = customColorNames.map(function (name) {
    return "--colors-".concat(name);
  });
  var _document = document,
      body = _document.body;

  if (body) {
    colors = Object(_getCssVariables__WEBPACK_IMPORTED_MODULE_1__["getDefinedCSSVariables"])(body, colorNames, '--colors-', false, // $FlowFixMe
    _color__WEBPACK_IMPORTED_MODULE_0__["cssColorToArray"]);
    paletteColors = Object(_getCssVariables__WEBPACK_IMPORTED_MODULE_1__["getDefinedCSSVariables"])(body, paletteColorNames, '--palette-', false, // $FlowFixMe
    _color__WEBPACK_IMPORTED_MODULE_0__["cssColorToArray"]);
    diagramColors = Object(_getCssVariables__WEBPACK_IMPORTED_MODULE_1__["getDefinedCSSVariables"])(body, diagramColorNames, '--diagram-', false, // $FlowFixMe
    _color__WEBPACK_IMPORTED_MODULE_0__["cssColorToArray"]);
  }

  colors.palette = paletteColors;
  colors.diagram = diagramColors;
  return colors;
}

/***/ }),

/***/ "./src/js/tools/getCssVariables.js":
/*!*****************************************!*\
  !*** ./src/js/tools/getCssVariables.js ***!
  \*****************************************/
/*! exports provided: getCSSVariables, getDefinedCSSVariables, searchObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCSSVariables", function() { return getCSSVariables; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefinedCSSVariables", function() { return getDefinedCSSVariables; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "searchObject", function() { return searchObject; });
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ "./src/js/tools/tools.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

 // export default function getCSSVariables(
//   id: string,
//   varNames: Array<string>,
//   prefix: string = '',
// ): Object {
//   const elem = document.getElementById('lesson__container_name');
//   const output = {};
//   if (elem) {
//     const style = window.getComputedStyle(elem);
//     if (style) {
//       varNames.forEach((varName) => {
//         const fullName = prefix + varName;
//         output[varName] = parseFloat(style.getPropertyValue(fullName));
//       });
//     }
//   }
//   return output;
// }

function searchObject(obj, path, text) {
  var results = [];
  Object.keys(obj).forEach(function (key) {
    var newPath = "".concat(path, ".").concat(key);

    if (key.includes(text)) {
      results.push(newPath);
    } else if (_typeof(obj[key]) === 'object') {
      var newResult = searchObject(obj[key], newPath, text);

      if (newResult) {
        results = results.concat(newResult);
      }
    } else if (typeof obj[key] === 'string') {
      if (obj[key].includes(text)) {
        results.push(newPath);
      }
    }
  });
  return results;
}

function toCamelCase(input, prefix) {
  var rePrefix = new RegExp(prefix, 'g');
  var reCamelCase1 = /-[a-z]/g;
  var reCamelCase2 = /_[a-z]/g;

  var repl = function repl(str) {
    return str[1].toUpperCase();
  };

  var noPrefix = input.replace(rePrefix, '');
  var camelCase1 = noPrefix.replace(reCamelCase1, repl);
  var camelCase2 = camelCase1.replace(reCamelCase2, repl);
  var noDash = camelCase2.replace(/-/g, '');
  return noDash;
}

function getDefinedCSSVariables(idOrElement, propertyNames) {
  var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var makeFlat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var modifier = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (a) {
    return a;
  };
  var variables = {};
  var elem = idOrElement;

  if (typeof idOrElement === 'string') {
    elem = document.getElementById(idOrElement);
  }

  if (elem instanceof HTMLElement) {
    var style = window.getComputedStyle(elem);

    if (style) {
      propertyNames.forEach(function (propertyName) {
        var value = style.getPropertyValue(propertyName).trim();
        var fValue = parseFloat(value);
        var valueToAdd = value;

        if (!Number.isNaN(fValue)) {
          valueToAdd = fValue;
        }

        valueToAdd = modifier(valueToAdd);

        if (makeFlat) {
          var shortName = toCamelCase(propertyName, prefix);
          variables[shortName] = valueToAdd;
        } else {
          var rePrefix = new RegExp(prefix, 'g');
          var noPrefix = propertyName.replace(rePrefix, '');
          Object(_tools__WEBPACK_IMPORTED_MODULE_0__["addToObject"])(variables, noPrefix, valueToAdd, '-');
        }
      });
    }
  }

  return variables;
}

function getCSSVariables(idOrElement) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var makeFlat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var variables = {};
  var elem = idOrElement;

  if (typeof idOrElement === 'string') {
    elem = document.getElementById(idOrElement);
  }

  if (elem instanceof HTMLElement) {
    var style = window.getComputedStyle(elem);

    if (style) {
      var numProperties = style.length;

      for (var i = 0; i < numProperties; i += 1) {
        var propertyName = style[i];

        if (prefix === '' || propertyName.startsWith(prefix)) {
          var value = style.getPropertyValue(propertyName).trim();
          var fValue = parseFloat(value);
          var valueToAdd = value;

          if (!Number.isNaN(fValue)) {
            valueToAdd = fValue;
          }

          if (makeFlat) {
            var shortName = toCamelCase(propertyName, prefix);
            variables[shortName] = valueToAdd;
          } else {
            var rePrefix = new RegExp(prefix, 'g');
            var noPrefix = propertyName.replace(rePrefix, '');
            Object(_tools__WEBPACK_IMPORTED_MODULE_0__["addToObject"])(variables, noPrefix, valueToAdd, '-');
          }
        }
      }
    }
  }

  return variables;
}



/***/ }),

/***/ "./src/js/tools/htmlGenerator.js":
/*!***************************************!*\
  !*** ./src/js/tools/htmlGenerator.js ***!
  \***************************************/
/*! exports provided: actionWord, click, highlight, addClass, addId, onClickId, highlightWord, centerV, centerH, centerVH, toHTML, clickWord, itemSelector, unit, applyModifiers, setOnClicks, setHTML */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "actionWord", function() { return actionWord; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "click", function() { return click; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "highlight", function() { return highlight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addClass", function() { return addClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addId", function() { return addId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onClickId", function() { return onClickId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "highlightWord", function() { return highlightWord; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "centerV", function() { return centerV; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "centerH", function() { return centerH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "centerVH", function() { return centerVH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toHTML", function() { return toHTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clickWord", function() { return clickWord; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "itemSelector", function() { return itemSelector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unit", function() { return unit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyModifiers", function() { return applyModifiers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setOnClicks", function() { return setOnClicks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setHTML", function() { return setHTML; });
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ "./src/js/tools/color.js");


function convertTextArrayToParagraphs(text) {
  var textToUse = '';

  if (Array.isArray(text)) {
    textToUse = "<p>".concat(text.join('</p><p>'), "</p>");
  } else {
    textToUse = text;
  }

  return textToUse;
}

function centerV() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var textToUse = convertTextArrayToParagraphs(text);
  return "<div style=\"display: table; height: 100%;\">\n        <div style=\"display: table-cell; vertical-align: middle\">\n        ".concat(textToUse, "</div></div>");
}

function centerVH() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var textToUse = convertTextArrayToParagraphs(text);
  return "<div style=\"display: table; height: 100%; text-align:center; width:100%\">\n        <div style=\"display: table-cell; vertical-align: middle\">\n        ".concat(textToUse, "</div></div>");
}

function centerH() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var textToUse = convertTextArrayToParagraphs(text);
  return "<div style=\"text-align:center;\">\n        ".concat(textToUse, "</div>");
}

function itemSelector() {
  var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [''];
  var classes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var selectorIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var outStr = "<ul id=\"id__lesson_item_selector_".concat(selectorIndex, "\" \n                    class=").concat(classes, ">");
  items.forEach(function (item, index) {
    outStr += "<li id=\"id__lesson_item_selector_".concat(index, "\">").concat(item, "</li>");
  });
  outStr += '</ul>';
  return outStr;
}

var unit = function unit(deg, rad) {
  return "<span class=\"lesson__unit_deg\">".concat(deg, "</span><span class=\"lesson__unit_rad\">").concat(rad, "</span>\n  ");
};

function toHTML() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var idStr = '';

  if (id) {
    idStr = " id=\"".concat(id, "\"");
  }

  var classStr = '';

  if (classes) {
    classStr = " class=\"".concat(classes, "\"");
  }

  var colorStr = '';

  if (color) {
    colorStr = " style=\"color:".concat(Object(_color__WEBPACK_IMPORTED_MODULE_0__["colorArrayToRGBA"])(color), ";\"");
  }

  return {
    replacementText: "<span".concat(idStr).concat(classStr, "\"").concat(colorStr, ">").concat(text.replace(RegExp(/_/, 'gi'), ' ').trim(), "</span>")
  };
}

function highlight() {
  var classesOrColor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var classStr = 'highlight_word';

  if (typeof classesOrColor === 'string') {
    classStr = "".concat(classesOrColor, " ").concat(classStr);
  }

  var color = null;

  if (Array.isArray(classesOrColor)) {
    color = classesOrColor;
  }

  return {
    replacementText: function replacementText(text) {
      return toHTML(text, '', classStr, color);
    }
  };
}

function highlightWord(text) {
  var classesOrColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var classStr = 'highlight_word';

  if (typeof classesOrColor === 'string') {
    classStr = "".concat(classesOrColor, " ").concat(classStr);
  }

  var color = null;

  if (Array.isArray(classesOrColor)) {
    color = classesOrColor;
  }

  return {
    replacementText: toHTML(text, '', classStr, color).replacementText
  };
}

function addClass() {
  var classes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return {
    replacementText: function replacementText(text) {
      return toHTML(text, '', classes);
    } // id: '',

  };
}

function addId() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return {
    replacementText: function replacementText(text) {
      return toHTML(text, id);
    } // id: '',

  };
}

function clickWord(textToUse, id, actionMethod, bind) {
  var classesOrColor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var interactive = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
  var classStr = 'action_word';

  if (interactive) {
    classStr = "".concat(classStr, " interactive_word");
  }

  if (typeof classesOrColor === 'string') {
    classStr = "".concat(classesOrColor, " ").concat(classStr);
  }

  var color = null;

  if (Array.isArray(classesOrColor)) {
    color = classesOrColor;
  }

  var idToUse = function idToUse() {
    return id;
  }; // const id = `lesson__id_${textToUse}`;


  return {
    replacementText: function replacementText() {
      return toHTML(textToUse, idToUse(), classStr, color);
    },
    id: idToUse,
    actionMethod: actionMethod,
    bind: bind
  };
}

function click(actionMethod, bind) {
  var classesOrColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var interactive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var id = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
  var classStr = 'action_word';

  if (interactive) {
    classStr = "".concat(classStr, " interactive_word");
  }

  if (typeof classesOrColor === 'string') {
    classStr = "".concat(classesOrColor, " ").concat(classStr);
  }

  var color = null;

  if (Array.isArray(classesOrColor)) {
    color = classesOrColor;
  }

  var idToUse = function idToUse(text) {
    return "lesson__id_".concat(text).concat(id);
  };

  return {
    replacementText: function replacementText(text) {
      return toHTML(text, idToUse(text), classStr, color);
    },
    id: idToUse,
    actionMethod: actionMethod,
    bind: bind
  };
}

function actionWord(text) {
  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var classesOrColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var interactive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var classStr = 'action_word';

  if (interactive) {
    classStr = "".concat(classStr, " interactive_word");
  }

  if (typeof classesOrColor === 'string') {
    classStr = "".concat(classesOrColor, " ").concat(classStr);
  }

  var color = null;

  if (Array.isArray(classesOrColor)) {
    color = classesOrColor;
  }

  return {
    replacementText: toHTML(text, id, classStr, color).replacementText,
    id: id
  };
}

function modifyText(text, key, mod) {
  var outText = '';
  var expression = new RegExp("\\|".concat(key, "\\|"), 'gi');
  var replacement = '';

  if (typeof mod.replacementText === 'string') {
    replacement = mod.replacementText;
  } else {
    replacement = mod.replacementText(key).replacementText; // console.log(replacement)
  }

  outText = text.replace(expression, replacement);
  return outText;
}

function onClickId(id, actionMethod, bind) {
  var additionalClassesToAdd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
  var element = document.getElementById(id);

  if (element) {
    element.classList.add('action_word_enabled');
    additionalClassesToAdd.split(' ').forEach(function (classString) {
      if (classString) {
        element.classList.add(classString);
      }
    });

    if (bind.length === 1) {
      element.onclick = actionMethod.bind(bind[0]);
    }

    if (bind.length === 2) {
      element.onclick = actionMethod.bind(bind[0], bind[1]);
    }

    if (bind.length === 3) {
      element.onclick = actionMethod.bind(bind[0], bind[1], bind[2]);
    }

    if (bind.length === 4) {
      element.onclick = actionMethod.bind(bind[0], bind[1], bind[2], bind[3]);
    }

    if (bind.length === 5) {
      element.onclick = actionMethod.bind(bind[0], bind[1], bind[2], bind[3], bind[4]);
    }

    if (bind.length === 6) {
      element.onclick = actionMethod.bind(bind[0], bind[1], bind[2], bind[3], bind[4], bind[5]);
    }

    if (bind.length === 7) {
      element.onclick = actionMethod.bind(bind[0], bind[1], bind[2], bind[3], bind[4], bind[5], bind[6]);
    }

    if (bind.length === 8) {
      element.onclick = actionMethod.bind(bind[0], bind[1], bind[2], bind[3], bind[4], bind[5], bind[6], bind[7]);
    }

    if (bind.length === 9) {
      element.onclick = actionMethod.bind(bind[0], bind[1], bind[2], bind[3], bind[4], bind[5], bind[6], bind[7], bind[8]);
    }
  }
}

function applyModifiers(text, modifiers) {
  var highlightClass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'highlight_word';
  var monochrome = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var outText = text;
  Object.keys(modifiers).forEach(function (key) {
    var mod = modifiers[key];
    outText = modifyText(outText, key, mod);
  });
  var r = RegExp(/\|([^|]*)\|/, 'gi');
  outText = outText.replace(r, "<span class=\"".concat(highlightClass, "\">$1</span>"));

  if (monochrome) {
    var c = RegExp(/style="color:rgba\([^)]*\);"/, 'gi');
    outText = outText.replace(c, '');
    var h = RegExp(/highlight_word/, 'gi');
    outText = outText.replace(h, '');
    var i = RegExp(/interactive_word/, 'gi');
    outText = outText.replace(i, '');
    var id = RegExp(/id="[^"]*"/, 'gi');
    outText = outText.replace(id, '');
  }

  return outText;
}

function setOnClicks(modifiers) {
  var additionalClassesToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  Object.keys(modifiers).forEach(function (key) {
    var mod = modifiers[key];

    if ('actionMethod' in mod) {
      onClickId(mod.id(key), mod.actionMethod, mod.bind, additionalClassesToAdd);
    }
  });
}

function setHTML(element, text) {
  var modifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var classesToAdd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
  var modifiedText = applyModifiers(text, modifiers); // eslint-disable-next-line no-param-reassign

  element.innerHTML = modifiedText;
  setOnClicks(modifiers, classesToAdd);
}



/***/ }),

/***/ "./src/js/tools/m2.js":
/*!****************************!*\
  !*** ./src/js/tools/m2.js ***!
  \****************************/
/*! exports provided: mul, identity, t, copy, translate, rotate, transform, scale, inverse, rotationMatrix, translationMatrix, scaleMatrix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return t; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotationMatrix", function() { return rotationMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translationMatrix", function() { return translationMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleMatrix", function() { return scaleMatrix; });
// 2D Matrix functions
function mul(a, b) {
  return [a[0] * b[0] + a[1] * b[3] + a[2] * b[6], a[0] * b[1] + a[1] * b[4] + a[2] * b[7], a[0] * b[2] + a[1] * b[5] + a[2] * b[8], a[3] * b[0] + a[4] * b[3] + a[5] * b[6], a[3] * b[1] + a[4] * b[4] + a[5] * b[7], a[3] * b[2] + a[4] * b[5] + a[5] * b[8], a[6] * b[0] + a[7] * b[3] + a[8] * b[6], a[6] * b[1] + a[7] * b[4] + a[8] * b[7], a[6] * b[2] + a[7] * b[5] + a[8] * b[8]];
}

function t(a) {
  return [a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]];
}

function identity() {
  return [1, 0, 0, 0, 1, 0, 0, 0, 1];
}

function copy(a) {
  return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]];
}

function translationMatrix(tx, ty) {
  return [1, 0, tx, 0, 1, ty, 0, 0, 1];
}

function translate(m, tx, ty) {
  return mul(m, translationMatrix(tx, ty));
}

function rotationMatrix(angle) {
  var c = Math.cos(angle);
  var s = Math.sin(angle);
  return [c, -s, 0, s, c, 0, 0, 0, 1];
}

function rotate(m, angle) {
  return mul(m, rotationMatrix(angle));
}

function scaleMatrix(sx, sy) {
  return [sx, 0, 0, 0, sy, 0, 0, 0, 1];
}

function scale(m, sx, sy) {
  return mul(m, scaleMatrix(sx, sy));
}

function transform(m, px, py) {
  return [m[0] * px + m[1] * py + m[2], m[3] * px + m[4] * py + m[5]];
}

function inverse(m) {
  var det = m[0] * (m[4] * m[8] - m[7] * m[5]) - // eslint-disable-line
  m[1] * (m[3] * m[8] - m[5] * m[6]) + // eslint-disable-line
  m[2] * (m[3] * m[7] - m[4] * m[6]);
  var invdet = 1 / det;
  var minv00 = (m[4] * m[8] - m[7] * m[5]) * invdet;
  var minv01 = (m[2] * m[7] - m[1] * m[8]) * invdet;
  var minv02 = (m[1] * m[5] - m[2] * m[4]) * invdet;
  var minv10 = (m[5] * m[6] - m[3] * m[8]) * invdet;
  var minv11 = (m[0] * m[8] - m[2] * m[6]) * invdet;
  var minv12 = (m[3] * m[2] - m[0] * m[5]) * invdet;
  var minv20 = (m[3] * m[7] - m[6] * m[4]) * invdet;
  var minv21 = (m[6] * m[1] - m[0] * m[7]) * invdet;
  var minv22 = (m[0] * m[4] - m[3] * m[1]) * invdet;
  return [minv00, minv01, minv02, minv10, minv11, minv12, minv20, minv21, minv22];
}



/***/ }),

/***/ "./src/js/tools/math.js":
/*!******************************!*\
  !*** ./src/js/tools/math.js ***!
  \******************************/
/*! exports provided: round, roundNum, decelerate, easeinout, easeout, easein, sinusoid, linear, clipMag, clipValue, range, randInt, rand, randElement, removeRandElement, randElements, rand2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "roundNum", function() { return roundNum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decelerate", function() { return decelerate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeinout", function() { return easeinout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeout", function() { return easeout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easein", function() { return easein; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinusoid", function() { return sinusoid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipMag", function() { return clipMag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipValue", function() { return clipValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randInt", function() { return randInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rand", function() { return rand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randElement", function() { return randElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeRandElement", function() { return removeRandElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randElements", function() { return randElements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rand2D", function() { return rand2D; });
var roundNum = function roundNum(value) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  var multiplier = Math.pow(10, precision);
  var result = Math.round(value * multiplier) / multiplier;

  if (Object.is(result, -0)) {
    result = 0;
  }

  return result;
};

function round(arrayOrValue) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  var result = 0;

  if (Array.isArray(arrayOrValue)) {
    result = arrayOrValue.map(function (elem) {
      return round(elem, precision);
    });
  }

  if (typeof arrayOrValue === 'number') {
    result = roundNum(arrayOrValue, precision);
  } // $FlowFixMe


  return result;
} // // clipValue clips a value to either 0 if it's small enough, or to a max value
// // Value, and maxValue are sign independent. e.g.
// //    * value, maxValue = 2, 1 => clips to 1
// //    * value, maxValue = -2, -1 => clips to -1
// //    * value, maxValue = -2, 1 => clips to -1
// //    * value, maxValue = 2, -1 => clips to 1
// function clipValue(
//   value: number,
//   zeroThreshold: number,
//   maxValue: number = 0,
// ) {
//   let result = value;
//   let zero = zeroThreshold;
//   if (zero < 0) {
//     zero = -zero;
//   }
//   if (value > -zero && value < zero) {
//     return 0;
//   }
//   let max = maxValue;
//   if (max < 0) {
//     max = -max;
//   }
//   if (value > max) {
//     result = max;
//   }
//   if (value < -max) {
//     result = -max;
//   }
//   return result;
// }
// Clip a value to either max velocity, or 0 once under the minimum
// threashold.
//  * velocity: can be positive or negative
//  * maxVelocity will clip velocity to:
//      * |maxVelocity| if velocity > 0
//      * -|maxVelocity| if velcity < 0
//  * zeroThreshold will clip velocity to:
//       * 0 if velocity is larger than -|zeroThreshold| and smaller than
//         |zeroThreshold|.


function clipMag(value, zeroThreshold, maxValue) {
  var result = value;
  var zeroT = zeroThreshold;
  var maxV = maxValue;

  if (zeroT === null) {
    zeroT = 0;
  }

  if (zeroT < 0) {
    zeroT = -zeroT;
  }

  if (maxV === null) {
    return result;
  }

  if (maxV < 0) {
    maxV = -maxV;
  }

  if (value >= -zeroT && value <= zeroT) {
    result = 0;
  }

  if (value > maxV) {
    result = maxV;
  }

  if (value < -maxV) {
    result = -maxV;
  }

  return result;
}

function clipValue(value, minValue, maxValue) {
  var clipped = value;

  if (minValue !== null) {
    if (value < minValue) {
      clipped = minValue;
    }
  }

  if (maxValue !== null) {
    if (value > maxValue) {
      clipped = maxValue;
    }
  }

  return clipped;
}

var decelerate = function getPositionVelocityFromDecAndTime(position, velocity, magDeceleration, time, zeroThreshold) {
  var zeroT = 0;

  if (zeroThreshold !== null) {
    zeroT = zeroThreshold;
  }

  var decel = 0;

  if (magDeceleration !== null) {
    decel = magDeceleration;
  } // If the velocity is currently 0, then no further deceleration can occur, so
  // return the current velocity and position


  var v = clipMag(velocity, zeroT, velocity);

  if (v === 0) {
    return {
      p: position,
      v: 0
    };
  }

  var d = decel;

  if (decel < 0) {
    d = -d;
  } // If there is some initial velocity, then calc its sign and


  var sign = velocity / Math.abs(velocity);
  var newVelocity = velocity - sign * d * time; // if the new velocity changes sign, then it should go to 0. If it doesn't
  // change sign, then clip incase it should go to 0 because it is below
  // the zero velocity threshold.

  var newSign = newVelocity / Math.abs(newVelocity);

  if (newSign !== sign) {
    newVelocity = 0;
  } else {
    newVelocity = clipMag(newVelocity, zeroT, newVelocity);
  } // If the new velocity is clipped, then we need to use the time to where the
  // velocity crosses the clipping point.
  // v_new = v_init + a*t
  // Therefore, if v_new = zeroT: t = (zeroT - vi)/a


  var t = time;

  if (newVelocity === 0) {
    var z = zeroT;
    var zSign = z / Math.abs(z);

    if (zSign !== sign) {
      z = -z;
    }

    t = Math.abs((z - velocity) / d);
  } // Now can calculate the new position


  var newPosition = position + velocity * t - sign * 0.5 * d * t * t;
  return {
    p: newPosition,
    v: newVelocity
  };
};

var linear = function linear(percentTime) {
  var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (invert) {
    return percentTime;
  }

  return percentTime;
};

var easeinout = function easeinout(percentTime) {
  var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (invert) {
    var a = percentTime;
    return (2 * a - Math.sqrt(-4 * a * a + 4 * a)) / (4 * a - 2);
  }

  var x = percentTime;
  var percentDistance = Math.pow(x, 2) / (Math.pow(x, 2) + Math.pow(1 - x, 2));
  return percentDistance;
}; // TODO fix invert


function easeout(percentTime) {
  var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (invert) {
    var a = percentTime;
    var b = (2 * a - Math.sqrt(-4 * a * a + 4 * a)) / (4 * a - 2); // return (b - 0.5) * 2;

    return b;
  }

  var x = 0.5 + percentTime / 2;
  var power = 2;
  var percentDistance = Math.pow(x, power) / (Math.pow(x, power) + Math.pow(1 - x, power));
  return (percentDistance - 0.5) * 2;
} // TODO fix invert


function easein(percentTime) {
  var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (invert) {
    var a = percentTime;
    var b = (2 * a - Math.sqrt(-4 * a * a + 4 * a)) / (4 * a - 2); // return (b - 0.5) * 2;

    return b;
  }

  var x = percentTime / 2;
  var power = 2;
  var percentDistance = Math.pow(x, power) / (Math.pow(x, power) + Math.pow(1 - x, power));
  return percentDistance * 2;
}

function sinusoid() {
  var deltaTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  var frequency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var bias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var mag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var phaseOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  return bias + mag * Math.sin(deltaTime * frequency * 2.0 * Math.PI + phaseOffset);
} // const animationPhase = (transform, time, rotDirection = 0, animationStyle = easeinout) => {
//     return {
//         transform: transform._dup(),
//         time: time,
//         rotDirection: rotDirection,
//         animationStyle: animationStyle,
//     }
// }


function range(start, stop) {
  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var out = [];

  for (var i = start; i <= stop + step * 0.5; i += step) {
    out.push(i);
  }

  return out;
}

function randInt(minOrMax) {
  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (max != null) {
    var min = minOrMax;
    return Math.floor(Math.random() * Math.floor(max - min) + Math.floor(min));
  }

  return Math.floor(Math.random() * Math.floor(minOrMax));
}

function rand(minOrMax) {
  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (max != null) {
    var min = minOrMax;
    return Math.random() * (max - min) + min;
  }

  return Math.random() * minOrMax;
}

function randElement(inputArray) {
  var index = randInt(inputArray.length);
  return inputArray[index];
}

function removeRandElement(inputArray) {
  var index = rand(inputArray.length);
  return inputArray.splice(index, 1)[0];
}

function randElements(num, inputArray) {
  var possibleIndeces = range(0, inputArray.length - 1, 1);
  var elements = [];

  for (var i = 0; i < num; i += 1) {
    var index = removeRandElement(possibleIndeces);
    elements.push(inputArray[index]);
  }

  return elements;
}

function rand2D(minX, minY, maxX, maxY) {
  return {
    x: rand(minX, maxX),
    y: rand(minY, maxY)
  };
}



/***/ }),

/***/ "./src/js/tools/styleSheets.js":
/*!*************************************!*\
  !*** ./src/js/tools/styleSheets.js ***!
  \*************************************/
/*! exports provided: getCSSVariables, getDefinedCSSVariables, searchObject, getCSSColors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _getCssVariables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getCssVariables */ "./src/js/tools/getCssVariables.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCSSVariables", function() { return _getCssVariables__WEBPACK_IMPORTED_MODULE_0__["getCSSVariables"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDefinedCSSVariables", function() { return _getCssVariables__WEBPACK_IMPORTED_MODULE_0__["getDefinedCSSVariables"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "searchObject", function() { return _getCssVariables__WEBPACK_IMPORTED_MODULE_0__["searchObject"]; });

/* harmony import */ var _getCssColors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getCssColors */ "./src/js/tools/getCssColors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCSSColors", function() { return _getCssColors__WEBPACK_IMPORTED_MODULE_1__["default"]; });





/***/ }),

/***/ "./src/js/tools/tools.js":
/*!*******************************!*\
  !*** ./src/js/tools/tools.js ***!
  \*******************************/
/*! exports provided: divide, mulToString, add, Console, classify, extractFrom, ObjectKeyPointer, getElement, addToObject, duplicateFromTo, isTouchDevice, generateUniqueId, joinObjects, cleanUIDs, loadRemote, loadRemoteCSS, deleteKeys, copyKeysFromTo, generateRandomString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mulToString", function() { return mulToString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Console", function() { return Console; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "classify", function() { return classify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractFrom", function() { return extractFrom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectKeyPointer", function() { return ObjectKeyPointer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getElement", function() { return getElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addToObject", function() { return addToObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "duplicateFromTo", function() { return duplicateFromTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTouchDevice", function() { return isTouchDevice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateUniqueId", function() { return generateUniqueId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "joinObjects", function() { return joinObjects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cleanUIDs", function() { return cleanUIDs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRemote", function() { return loadRemote; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRemoteCSS", function() { return loadRemoteCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteKeys", function() { return deleteKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyKeysFromTo", function() { return copyKeysFromTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateRandomString", function() { return generateRandomString; });
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Console = function Console(text) {
  console.log(text); // eslint-disable-line no-console
};

function add(a, b) {
  return a + b;
}

function mulToString(a, b) {
  return (a * b).toString();
}

var divide = function divide(a, b) {
  return a / b;
};

var classify = function classify(key, value) {
  var nonEmpty = value || key;
  var withKey = nonEmpty[0] === '-' || nonEmpty.startsWith("".concat(key, "-")) ? "".concat(key, " ").concat(nonEmpty) : nonEmpty;
  var joinStr = " ".concat(key, "-");
  return "".concat(withKey.split(' -').join(joinStr));
};

var ObjectKeyPointer =
/*#__PURE__*/
function () {
  function ObjectKeyPointer(object, key) {
    _classCallCheck(this, ObjectKeyPointer);

    this.object = object;
    this.key = '';

    if (key in object) {
      this.key = key;
    }
  }

  _createClass(ObjectKeyPointer, [{
    key: "setValue",
    value: function setValue(value) {
      if (this.key) {
        this.object[this.key] = value;
      }
    }
  }, {
    key: "execute",
    value: function execute() {
      if (this.key) {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return this.object[this.key].apply(null, args);
      }

      return undefined;
    }
  }, {
    key: "value",
    value: function value() {
      if (this.key) {
        return this.object[this.key];
      }

      return undefined;
    }
  }]);

  return ObjectKeyPointer;
}(); //


function extractFrom(objectToExtractFrom, keyValues) {
  var keyPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var out = [];

  if (typeof keyValues === 'string') {
    if (keyPrefix + keyValues in objectToExtractFrom) {
      return new ObjectKeyPointer(objectToExtractFrom, keyPrefix + keyValues);
    }

    var keyHeirarchy = keyValues.split('_');
    var keys = keyHeirarchy.filter(function (k) {
      return k.length > 0;
    });

    if (keys.length > 1) {
      if (keyPrefix + keys[0] in objectToExtractFrom) {
        return extractFrom(objectToExtractFrom[keyPrefix + keys[0]], keys.slice(1).join('_'), keyPrefix);
      }
    } else if (keys.length === 1) {
      if (keyPrefix + keys[0] in objectToExtractFrom) {
        return new ObjectKeyPointer(objectToExtractFrom, keyPrefix + keys[0]);
      }
    }

    return undefined;
  }

  if (Array.isArray(keyValues)) {
    keyValues.forEach(function (kv) {
      var result = extractFrom(objectToExtractFrom, kv, keyPrefix);

      if (result !== undefined) {
        out.push(result);
      }
    });
  } else {
    Object.keys(keyValues).forEach(function (key) {
      if (keyPrefix + key in objectToExtractFrom) {
        out.push({
          obj: new ObjectKeyPointer(objectToExtractFrom, keyPrefix + key),
          // $FlowFixMe
          value: keyValues[key]
        });
      }
    });
  }

  return out;
}

function getElement(collection, keyValues) {
  return extractFrom(collection, keyValues, '_');
}

function addToObject(obj, nameToAdd, valueToAdd) {
  var splitStr = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '-';
  var levels = nameToAdd.split(splitStr);
  var currentLevel = obj;
  levels.forEach(function (level, index) {
    if (index === levels.length - 1) {
      currentLevel[level] = valueToAdd;
      return;
    }

    if (!Object.prototype.hasOwnProperty.call(currentLevel, level)) {
      currentLevel[level] = {};
    }

    currentLevel = currentLevel[level];
  });
}

function duplicateFromTo(fromObject, toObject) {
  var exceptKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  var copyValue = function copyValue(value) {
    if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'string' || value == null || typeof value === 'function') {
      return value;
    }

    if (typeof value._dup === 'function') {
      return value._dup();
    }

    if (Array.isArray(value)) {
      var arrayCopy = [];
      value.forEach(function (arrayElement) {
        return arrayCopy.push(copyValue(arrayElement));
      });
      return arrayCopy;
    }

    if (_typeof(value) === 'object') {
      var objectCopy = {};
      Object.keys(value).forEach(function (key) {
        var v = copyValue(value[key]);
        objectCopy[key] = v;
      });
      return objectCopy;
    }

    return value;
  };

  Object.keys(fromObject).forEach(function (key) {
    if (exceptKeys.indexOf(key) === -1) {
      // eslint-disable-next-line no-param-reassign
      toObject[key] = copyValue(fromObject[key]);
    }
  });
} // joins objects like object.assign but goes as many levels deep as the object
// is. Objects later in the arrawy overwrite objects earlier.


function joinObjects() {
  // if (typeof objects === 'object') {
  //   return objects;
  // }
  var assignObjectFromTo = function assignObjectFromTo(fromObject, toObject) {
    Object.keys(fromObject).forEach(function (key) {
      var value = fromObject[key];

      if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'string' || value == null || typeof value === 'function' || typeof value._dup === 'function' || Array.isArray(value)) {
        // console.log(value, toObject[key])
        if (value !== undefined || toObject[key] === undefined) {
          // eslint-disable-next-line no-param-reassign
          toObject[key] = value;
        }
      } else {
        var toValue = toObject[key];

        if (typeof toValue === 'number' || typeof toValue === 'boolean' || typeof toValue === 'string' || toValue == null || typeof toValue === 'function' || Array.isArray(toValue)) {
          // eslint-disable-next-line no-param-reassign
          toObject[key] = {};
        }

        assignObjectFromTo(value, toObject[key]);
      }
    });
  };

  var num = arguments.length;
  var out = arguments.length <= 0 ? undefined : arguments[0];

  for (var i = 1; i < num; i += 1) {
    var o = i < 0 || arguments.length <= i ? undefined : arguments[i];

    if (o != null) {
      assignObjectFromTo(o, out);
    }
  }

  return out;
}

function generateUniqueId() {
  var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  var randomString = function randomString(s) {
    return "".concat(s).concat(Math.floor(Math.random() * 1000000));
  };

  var seedToUse = seed;

  if (seedToUse.length === 0) {
    seedToUse = 'id_random_';
  }

  var idExists = true;
  var newId = randomString(seedToUse);

  while (idExists) {
    newId = randomString(seedToUse);
    var element = document.getElementById(newId);

    if (element == null) {
      idExists = false;
    }
  }

  return newId;
}

function isTouchDevice() {
  var prefixes = ' -webkit- -moz- -o- -ms- '.split(' ');

  var mq = function mq(query) {
    return window.matchMedia(query).matches;
  };
  /* eslint-disable no-undef, no-mixed-operators */
  // $FlowFixMe


  if ('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch) {
    return true;
  }
  /* eslint-enable no-undef, no-mixed-operators */
  // include the 'heartz' as a way to have a non matching MQ to help terminate the join
  // https://git.io/vznFH


  var query = ['(', prefixes.join('touch-enabled),('), 'heartz', ')'].join('');
  return mq(query);
}

function loadRemote(scriptId, url) {
  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var existingScript = document.getElementById(scriptId);

  if (!existingScript) {
    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = url;
    script.id = scriptId; // e.g., googleMaps or stripe

    if (document.body) {
      document.body.appendChild(script);
    }

    script.onload = function () {
      if (callback != null) {
        callback(scriptId, url);
      }
    };
  } else if (callback != null) {
    callback(scriptId, url);
  }
}

function loadRemoteCSS(id, url) {
  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var existingScript = document.getElementById(id);

  if (!existingScript) {
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = url;
    link.id = id; // e.g., googleMaps or stripe

    if (document.body) {
      document.body.appendChild(link);
    }

    link.onload = function () {
      if (callback != null) {
        callback(id, url);
      }
    };
  } else if (callback != null) {
    callback(id, url);
  }
} // function remoteLoadToObject(
//   scriptId: string,
//   url: string,
//   toObject: {},
//   callback: null | (string, string) => void = null,
// ) {
//   loadRemote(scriptId, url, callback);
// }


var cleanUIDs = function cleanUIDs(objectToClean) {
  var genericUID = '0000000000';

  if (objectToClean == null) {
    return;
  }

  if ('uid' in objectToClean) {
    if (objectToClean.uid === genericUID) {
      return;
    } // eslint-disable-next-line no-param-reassign


    objectToClean.uid = genericUID;
  }

  var keys = Object.keys(objectToClean);

  for (var i = 0; i < keys.length; i += 1) {
    var key = keys[i];
    var value = objectToClean[key];

    if (_typeof(value) === 'object' && !Array.isArray(value) && value != null && typeof value !== 'function' && typeof value !== 'number' && typeof value !== 'boolean' && typeof value !== 'string') {
      cleanUIDs(value);
    }
  }
};

function deleteKeys(obj, keys) {
  keys.forEach(function (key) {
    if (obj[key] !== undefined) {
      // eslint-disable-next-line no-param-reassign
      delete obj[key];
    }
  });
}

function copyKeysFromTo(source, destination, keys) {
  keys.forEach(function (key) {
    if (source[key] !== undefined) {
      // eslint-disable-next-line no-param-reassign
      destination[key] = source[key];
    }
  });
}

function generateRandomString() {
  return (Math.random() * 1e18).toString(36);
}



/***/ })

/******/ });
});
//# sourceMappingURL=index.js.map